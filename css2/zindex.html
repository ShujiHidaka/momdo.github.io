<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="ja">

<HEAD>
<TITLE>Elaborate description of Stacking Contexts</TITLE>
<link rel="stylesheet" href="style/default.css" type="text/css">
<link rel="stylesheet" href="http://www.w3.org/StyleSheets/TR/W3C-ED.css" type="text/css">
<link rel="prev" href="sample.html">
<link rel="next" href="propidx.html">
<link rel="contents" href="cover.html#minitoc">
<link rel="CSS-properties" href="propidx.html" title="properties">
<link rel="index" href="indexlist.html" title="index">
<link rel="first" href="cover.html">

</HEAD>
<BODY>
<div class="navbar">
<p><a href="sample.html">前章</a> &nbsp; <a href="propidx.html">次章</a> &nbsp; <a href="cover.html#minitoc">目次</a> &nbsp; <a href="propidx.html">プロパティ</a> &nbsp; <a href="indexlist.html">索引</a> &nbsp;
</div>
<hr class="navbar">

<H1><a name="q0">付録 E. スタックコンテキストの詳説</a></H1>
<div class="subtoc">
<p><strong>目次</strong>
  <ul class="toc">
    <li class="tocline2"><a href="zindex.html#stacking-defs" class="tocxref">E.1 定義</a>
    </li><li class="tocline2"><a href="zindex.html#painting-order" class="tocxref">E.2 描画順序</a>
    </li><li class="tocline2"><a href="zindex.html#stacking-notes" class="tocxref">E.3 ノート</a>
  </li></ul>
</div>

<p>この章では、仕様の残りでの説明よりも詳細にCSS 2.1描画順序を定義する。</p>

<h2>E.1 <a name="stacking-defs">定義</a></h2>

<dl>

<dt>ツリー順</dt>

<dd>周りのボックスを移動するプロパティを考慮した後、双方向のコンテンツのための（視覚でなく）論理的な順序で、レンダリング<em>ツリー</em>の先行順に深さ探索すること。</dd>

<dt>要素</dt>

<dd>この説明で"要素"は、実際の要素、擬似要素、および匿名ボックスを指す。擬似要素と匿名ボックスは適切な場所で子孫として扱われる。たとえば、外側のリストマーカーはラインボックスに隣接する':before'ボックスの前に来るが、これは、ボックス内容の前に来る、など。</dd>

</dl>

<h2>E.2 <a name="painting-order">描画順序</a></h2>

    <p>スタックの最下部はユーザーから最も遠いが、スタックの最上位はユーザーに最も近い:

<pre>
	     |	   |	     |	  |
	     |		|    |	  |	⇦ ☻
	     |		|	  |	ユーザー
z-index:  canvas  -1	0    1	  2
</pre>

    <p>スタックコンテキストの背景と最も負の位置のスタックコンテキストは、スタックの下部にあり、一方最も正の位置スタックコンテキストはスタックの最上位にある。

    <p>別の内側に含まれる場合はキャンバスは透明であり、そうでない場合はユーザーエージェント定義の色が与えられる。範囲内で無限大であり、ルート要素を含む。初めに、ビューポートは、キャンバスの原点で左上隅で固定される。

    <p> スタックコンテキスト（ <a href="visuren.html#propdef-z-index" class="noxref"><span
    class="propinst-z-index">'z-index'</span></a>プロパティを参照）を生成する要素の子孫の塗装順序は次のとおり:

    <ol class=stack>
      <li>
	<p>要素がルート要素の場合：
	<ol>
	  <li>全体のキャンバス上の要素の背景色を指定する。

	  </li><li>ルート要素に塗装された場合、全体のキャンバス一面に、要素の背景画像は使用され原点に固定される。
	</li></ol>

      </li><li>
	<p>要素が、ブロック、リスト項目、または他のブロックと等価である場合：
	<ol>
	  <li>ルート要素である場合を除き、要素の背景色。

	  </li><li>ルート要素である場合を除き、要素の背景画像。

	  </li><li>要素のボーダー。
	</li></ol>

	<p>そうでなければ、要素がブロックレベルのテーブルの場合：
	<ol>
	  <li>ルート要素である場合を除き、テーブルの背景（色、次に画像）。

	  </li><li>列グループの背景（色、次に画像）。
	  </li><li>列の背景（色、次に画像）。
	  </li><li>行グループの背景（色、次に画像）。
	  </li><li>行の背景（色、次に画像）。
	  </li><li>セルの背景（色、次に画像）。
	  </li><li>すべてのテーブルのボーダー（分離ボーダーによるツリー順で）。
	</li></ol>

      </li><li>
	<p>z-indexの順（最も負のものが最初）でz-index（0を除く）とともに配置された子孫によって形成されたスタックコンテキスト、次にツリーの順。

      </li><li>
	<p>要素が、ブロック、リスト項目、または他のブロックと等価である場合、ツリーの順でほとんどすべてのフロー内、非配置、ブロックレベルの子孫：
	<ol>
	  <li>要素の背景色。
	  </li><li>要素の背景画像。
	  </li><li>要素のボーダー。
	</li></ol>

	<p>そうでなければ、要素がテーブル：
	<ol>
	  <li>テーブルの背景（色、次に画像）。
	  </li><li>列グループの背景（色、次に画像）。
	  </li><li>列の背景（色、次に画像）。
	  </li><li>行グループの背景（色、次に画像）。
	  </li><li>行の背景（色、次に画像）。
	  </li><li>セルの背景（色、次に画像）。
	  </li><li>すべてのテーブルのボーダー（分離ボーダーによるツリー順で）。
	</li></ol>

      </li><li>
	<p>すべての非配置浮動子孫は、ツリーの順。これらのそれぞれについて、あたかも新しいスタックコンテキストを作成したかのように要素を扱うが、実際に新しいスタックコンテキストを作成し、任意の配置子孫と子孫は、親スタックコンテキストではなく、この新しいものの一部と見なされるべきである。

      </li><li>
	<p>要素は、その後、スタックコンテキストを生成し、インライン要素である場合：
	<ol>
	  <li>
	    <p>要素であるそれぞれの行ボックスの場合：
	    <ol>
	      <li>その行ボックス内の要素のボックスの<a href="#each-box">7.2.1</a>にジャンプする（ツリー順に）。
	    </li></ol>
	</li></ol>

      </li><li>
	<p>そうでなければ、最初に要素に対して、次にすべてのフロー、非配置、ブロックレベルの子孫のツリー順に：
	<ol>
	  <li>
	    <p>要素がブロックレベル置換要素の場合、原始的な置換内容。

	  </li><li>
	    <p>そうでなければ、その要素の各行ボックスに対して：
	    <ol>
	      <li id=each-box>
		<p>その行ボックスで、各ボックスにその要素の子である。ツリーの順序で：
		<ol>
		  <li>
		    <p>要素の背景色。
		  </li><li>
		    <p>要素の背景画像。
		  </li><li>
		    <p>要素のボーダー。
		  </li><li>
		    <p>インライン要素に対して：
		    <ol>
		      <li>
			<p>すべての要素のフロー内、非配置、この行のボックスにあるインラインレベルの子供、この行のボックス上にある要素内のテキストのすべての実行、ツリーの順序で：
			<ol>
			  <li>
			    <p>テキストの実行である場合：
			    <ol>
			      <li>下線を適用する要素のツリー順で、要素のテキストに影響を与える下線（もしあれば、最も深い要素の下線が最上位とルート要素の下線を描かれているような、もしあれば、一番下の描画されるような）。

			      </li><li>上線を適用する要素のツリー順で、要素のテキストに影響を与える上線（もしあれば、最も深い要素の上線が最上位とルート要素の上線を描かれているような、もしあれば、一番下の描画されるような）。

			      </li><li>テキスト。

			      </li><li>中央線を適用する要素のツリー順で、要素のテキストに影響を与える中央線（もしあれば、最も深い要素の中央線が最上位とルート要素の中央線を描かれているような、もしあれば、一番下の描画されるような）。
			    </li></ol>

			  </li><li>
			    <p>そうでなければ、その要素に対して<a
			    href="#each-box">7.2.1</a>に飛ぶ。
			</li></ol>
		    </li></ol>

		    <p>インラインブロックおよびインラインテーブル要素に対して：
		    <ol>
		      <li>これらのそれぞれについて、あたかも新しいスタックコンテキストを作成したかのように要素を扱うが、実際に新しいスタックコンテキストを作成し、任意の配置子孫と子孫は、親スタックコンテキストではなく、この新しいものの一部と見なされるべきである。
		    </li></ol>

		    <p>インラインレベル置換要素に対して：
		    <ol>
		      <li>原始的に置換内容。
		    </li></ol>
		</li></ol>

		<p class=note>ボックスの一部は、行分割、またはUnicode双方向アルゴリズムによって生成されていてもよい。

	      </li><li>
		<p>必要に応じて、要素のアウトライン（<a
		href="#outlines">以下10</a>を参照）。
	    </li></ol>

	  </li><li>
	    <p>必要に応じて、要素がブロックレベルであれば、要素のアウトライン（<a href="#outlines">以下10</a>を参照）。
	</li></ol>

      </li><li>
	<p>ツリーの順序で、'z-index: auto'または 'z-index: 0'をもつすべての配置子孫。 'z-index: auto'をもつこれらにとっては、新しいスタックコンテキストを作成したかのように要素を扱うが、実際に新しいスタックコンテキストを作成し、任意の配置子孫と子孫は、新しいものではなく、親スタックコンテキストの一部と考慮されるべきである。'z-index: 0'をこれらのために、原始的な生成スタックコンテキストを扱う。

      </li><li>
	<p>z-indexの順序（最小が最初）、ツリーの順序でのz-indexが1以上と配置子孫によって形成されたスタックコンテキスト。

      </li><li id=outlines>
	<p>最後に、上記の手順で輪郭を描画しない実装では、この段階では、このスタックコンテキストからアウトラインを描画しなければならない。（この手順でアウトラインの描画を推奨する。）
    </li></ol>

    <h2>E.3 <a name="stacking-notes">ノート</a></h2>

    <p>ルート要素の背景は、全体のキャンバス一面に一度だけ描かれる。

    <p>双方向のインラインの背景はツリー順で描かれている一方、視覚的な順序で配置される。インライン背景の配置はCSS 2.1で指定されてないので、これらの2つの要件の正確な結果は、ユーザーエージェント定義である。CSS3は、詳細に定義するかもしれない。

<hr class="navbar">

<div class="navbar">
<p><a href="sample.html">前章</a> &nbsp; <a href="propidx.html">次章</a> &nbsp; <a href="cover.html#minitoc">目次</a> &nbsp; <a href="propidx.html">プロパティ</a> &nbsp; <a href="indexlist.html">索引</a> &nbsp;
</div>
</BODY>
</HTML>
