<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01//EN'>
<html lang="ja">

<head>
<title>Selectors</title>
<link rel="stylesheet" href="http://www.w3.org/StyleSheets/TR/W3C-ED.css" type="text/css">
<link rel="stylesheet" href="style/default.css" type="text/css">
<link rel="prev" href="syndata.html">
<link rel="next" href="cascade.html">
<link rel="contents" href="cover.html#minitoc">
<link rel="CSS-properties" href="propidx.html" title="properties">
<link rel="index" href="indexlist.html" title="index">
<link rel="first" href="cover.html">

</head>
<body>
<div class="navbar">
<p><a href="syndata.html">前章</a> &nbsp; <a href="cascade.html">次章</a> &nbsp; <a href="cover.html#minitoc">目次</a> &nbsp; <a href="propidx.html">プロパティー</a> &nbsp; <a href="indexlist.html">索引</a> &nbsp;
</div>
<hr class="navbar">

<h1><a name="q0">5 セレクタ</a></h1>
<div class="subtoc">
<p><strong>目次</strong>
  <ul class="toc">
    <li class="tocline2"><a href="selector.html#pattern-matching" class="tocxref">5.1 パターンマッチ</a>
    </li><li class="tocline2"><a href="selector.html#selector-syntax" class="tocxref">5.2 セレクタの構文</a>
    <ul class="toc">
      <li class="tocline3"><a href="selector.html#grouping" class="tocxref">5.2.1 グループ化</a>
    </li></ul>
    </li><li class="tocline2"><a href="selector.html#universal-selector" class="tocxref">5.3 全称セレクタ</a>
    </li><li class="tocline2"><a href="selector.html#type-selectors" class="tocxref">5.4 型セレクタ</a>
    </li><li class="tocline2"><a href="selector.html#descendant-selectors" class="tocxref">5.5 子孫セレクタ</a>
    </li><li class="tocline2"><a href="selector.html#child-selectors" class="tocxref">5.6 子セレクタ</a>
    </li><li class="tocline2"><a href="selector.html#adjacent-selectors" class="tocxref">5.7 隣接セレクタ</a>
    </li><li class="tocline2"><a href="selector.html#attribute-selectors" class="tocxref">5.8 属性セレクタ</a>
    <ul class="toc">
      <li class="tocline3"><a href="selector.html#matching-attrs" class="tocxref">5.8.1 属性および属性値のマッチング</a>
      </li><li class="tocline3"><a href="selector.html#default-attrs" class="tocxref">5.8.2 DTDにおける属性の規定値</a>
      </li><li class="tocline3"><a href="selector.html#class-html" class="tocxref">5.8.3 クラスセレクタ</a>
    </li></ul>
    </li><li class="tocline2"><a href="selector.html#id-selectors" class="tocxref">5.9 IDセレクタ</a>
    </li><li class="tocline2"><a href="selector.html#pseudo-elements" class="tocxref">5.10 擬似要素と擬似クラス</a>
    </li><li class="tocline2"><a href="selector.html#pseudo-class-selectors" class="tocxref">5.11 擬似クラス</a>
    <ul class="toc">
      <li class="tocline3"><a href="selector.html#first-child" class="tocxref">5.11.1 :first-child 擬似クラス</a>
      </li><li class="tocline3"><a href="selector.html#link-pseudo-classes" class="tocxref">5.11.2 リンク擬似クラス：<span class="index-def" title="pseudo-classes:::link|:link|link (pseudo-class)">:link</span>と<span class="index-def" title="pseudo-classes:::visited|:visited|visited (pseudo-class)">:visited</span></a>
      </li><li class="tocline3"><a href="selector.html#dynamic-pseudo-classes" class="tocxref">5.11.3 動的擬似クラス：<span class="index-def" title="pseudo-classes:::hover|:hover|hover (pseudo-class)">:hover</span>、<span class="index-def" title="pseudo-classes:::active|:active|active (pseudo-class)">:active</span>、<span class="index-def" title="pseudo-classes:::focus|:focus|focus (pseudo-class)">:focus</span></a>
      </li><li class="tocline3"><a href="selector.html#lang" class="tocxref">5.11.4 言語擬似クラス：<span class="index-def" title="pseudo-classes:::lang|:lang|lang (pseudo-class)">:lang</span></a>
    </li></ul>
    </li><li class="tocline2"><a href="selector.html#pseudo-element-selectors" class="tocxref">5.12 擬似要素</a>
    <ul class="toc">
      <li class="tocline3"><a href="selector.html#first-line-pseudo" class="tocxref">5.12.1 <span class="index-def" title="pseudo-elements:::first-line|:first-line|first-line">:first-line</span>擬似要素</a>
      </li><li class="tocline3"><a href="selector.html#first-letter" class="tocxref">5.12.2 <span class="index-def" title="pseudo-elements:::first-letter|:first-letter|first-letter">:first-letter</span>疑似要素</a>
      </li><li class="tocline3"><a href="selector.html#before-and-after" class="tocxref">5.12.3 <span class="index-def" title="pseudo-elements:::before|:before">:before</span>および<span class="index-def" title="pseudo-elements:::after|:after">:after</span>疑似要素</a>
    </li></ul>
  </li></ul>
</div>


<h2>5.1 <a name="pattern-matching">パターンマッチ</a></h2>

<p>CSSにおいて、パターンマッチ規則は<a href="conform.html#doctree">文書ツリー</a>内のどの要素にスタイル規則を適用するかを決定する。<a name="x0"><span class="index-inst"
title="selector">セレクタ</span></a>と呼ばれるこれらのパターンは、単純な要素名から豊富な文脈上のパターンへと多岐にわたる。パターン内のすべての条件が特定の要素に対して該当する場合、セレクタは要素に<a name="x1"><span class="index-def"
title="match|selector::match"><dfn>マッチする</dfn></span></a>。

<P>セレクタについて文書言語の要素名における大文字・小文字の区別は、文書言語に依存する。たとえば、HTMLで要素名は大文字・小文字不区別であるが、XMLにおいては大文字・小文字区別となる。

<P>The following table summarizes CSS&nbsp;2.2 selector syntax:</P>

<table border=1>
<TR><TH>パターン</TH><TH>意味</TH><TH>解説する節</TH></TR>
<TR><TD>*</TD><TD>すべての要素にマッチする。</TD><TD><a href="#universal-selector">全称セレクタ</a></TD></TR>
<TR><TD>E</TD><TD>E要素にマッチする（すなわち、E要素型）。</TD><TD><a href="#type-selectors">型セレクタ</a></TD></TR>
<TR><TD>E F</TD><TD>E要素の子孫であるF要素にマッチする。</TD><TD><a href="#descendant-selectors">子孫セレクタ</a></TD></TR>
<TR><TD>E &gt; F</TD><TD>E要素の子であるF要素にマッチする。</TD><TD><a href="#child-selectors">子セレクタ</a></TD></TR>
<TR><TD>E:first-child</TD><TD>親要素の最初の子であるE要素にマッチする。
</TD><TD><a href="#first-child">:first-child擬似クラス</a></TD></TR>

<TR><TD>E:link<br>E:visited  </TD><TD>ハイパーリンクのアンカーであるE要素のうち、未訪問（:link）であるもの、訪問済み（:visited）であるものにマッチする。
</TD><TD><a href="#link-pseudo-classes">リンク疑似クラス</a></TD></TR>
<TR><TD>E:active<br>E:hover<br>E:focus  </TD><TD>特定のユーザーアクション状態にあるE要素にマッチする。
</TD><TD><a href="#dynamic-pseudo-classes">動的疑似クラス</a>
</TD></TR><TR><TD>E:lang(c)  </TD><TD>言語cを持つE要素にマッチする（言語情報の決定方法は文書言語が規定する）。
</TD><TD><a href="#lang">:lang()疑似クラス</a>
</TD></TR><TR><TD>E + F</TD><TD>E要素の直後に現れるF要素にマッチする。</TD><TD><a href="#adjacent-selectors">隣接セレクタ</a>
</TD></TR>
<TR><TD>E[foo]</TD><TD>（値にかかわらず）"foo"属性を設定されたE要素にマッチする。
</TD><TD><a href="#attribute-selectors">属性セレクタ</a>
</TD></TR>
<TR><TD>E[foo="warning"]</TD><TD>"foo"属性の値が"warning"であるE要素にマッチする。
</TD><TD><a href="#attribute-selectors">属性セレクタ</a>
</TD></TR>
<TR><TD>E[foo~="warning"]</TD><TD>"foo"属性が空白区切りの値をとり、その値の1つが"warning"であるE要素にマッチする。
</TD><TD><a href="#attribute-selectors">属性セレクタ</a>
</TD></TR>
<TR><TD>E[lang|="en"]</TD><TD>"lang"属性が"en"で（左から）始まるハイフン区切りのリストをもつE要素にマッチする。
</TD><TD><a href="#attribute-selectors">属性セレクタ</a>
</TD></TR>
<TR><TD>DIV.warning</TD><TD><em>言語固有。</em>（HTMLでは、DIV[class~="warning"]と同義。）
</TD><TD><a href="#class-html">クラスセレクタ</a></TD></TR>
<TR><TD>E#myid</TD><TD>"myid"と同値のIDをもつE要素にマッチする。</TD><TD><a href="#id-selectors">IDセレクタ</a></TD></TR>
</table>


<h2>5.2 <a name="selector-syntax">セレクタの構文</a></h2>

<P><span class="index-def" title="simple selector"><a
name="simple-selector"><dfn>単体セレクタ</dfn></a></span>は、<a href="#type-selectors">型セレクタ</a>または<a
href="#universal-selector">全称セレクタ</a>のいずれかの直後に、0個以上の<a href="#attribute-selectors">属性セレクタ</a>、<a href="#id-selectors">IDセレクタ</a>、<a
href="#pseudo-classes">擬似クラス</a>が任意の順序で続くものである。セレクタの構成要素のすべてがマッチする場合、単体セレクタはマッチする。

<p class="note">Note: the terminology used here in CSS&nbsp;2.2 is different from what is used in CSS3. For example, a "simple selector" refers to a smaller part of a selector in CSS3 than in CSS&nbsp;2.2. CSS3セレクタモジュール<a href="refs.html#ref-CSS3SEL" rel="biblioentry" class="noxref"><span class="informref">[CSS3SEL]</span></a>を参照のこと。

<P><a name="x4"><span class="index-def"
title="selector"><dfn>セレクタ</dfn></span></a>は、結合子で区切られた1つ以上の単体セレクタからなる。<span class="index-def"
title="combinator"><a
name="combinator"><dfn>結合子</dfn></a></span>は、空白、"&gt;"、"+"がある。空白は結合子と単体セレクタの間およびその前後に出現してもよい。

<P>セレクタにマッチする文書ツリーの要素は、セレクタの<span class="index-def" title="subject (of selector)|selector::subject
of"><a name="subject"><dfn>対象</dfn></a></span>と呼ばれる。単一の単体セレクタから成るセレクタは、その要件を満たすすべての要素にマッチする。単体セレクタおよび結合子を列の先頭に追加することは、追加のマッチング制約を課すことになる。よってセレクタの対象は、常に最後の単体セレクタに一致する要素のサブセットである。

<P>単一の<a href="#pseudo-elements">擬似要素</a>は、連鎖の最後の単純セレクタに追加してもよい。その場合、スタイル情報は各対象の一部に適用される。

<h3>5.2.1 <a name="grouping">グループ化</a></h3>

<p>複数のセレクタが同じ宣言を共有する場合、セレクタをコンマ区切りのリストにグループ化してもよい。</p>

<div class="example"><P style="display:none">例：</P>
<P>この例において、同一の宣言を持つ3つの規則を1つに簡略化する。つまり、

<pre>
h1 { font-family: sans-serif }
h2 { font-family: sans-serif }
h3 { font-family: sans-serif }
</pre>

<p>これは以下と同等である：</p>

<pre>
h1, h2, h3 { font-family: sans-serif }
</pre>
</div>

<P>CSSは、<span class="index-def" title="multiple declarations"><a name="x8" href="syndata.html#declaration">複数の宣言</a></span>や<span class="index-inst" title="shorthand property"><a name="x9"
href="about.html#shorthand">略式プロパティー</a></span>を含む、他の"略式"のメカニズムを提供する。

<h2>5.3 <a name="universal-selector">全称セレクタ</a></h2>

<P>"*"と書き表される<a name="x10"><span class="index-def" title="universal selector">全称セレクタ</span></a>は、すべての要素型の名前とマッチする。全称セレクタは、<a
href="conform.html#doctree">文書ツリー</a>内の任意の単一要素にマッチする。


<P>全称セレクタが<a
href="#simple-selector">単体セレクタ</a>の唯一の構成要素でない場合、"*"を省略してもよい。たとえば：</P>

<ul>
<li><code>*[LANG=fr]</code>と<code>[LANG=fr]</code>は等価である。
</li><li><code>*.warning</code>と<code>.warning</code>は等価である。
</li><li><code>*#myid</code>と<code>#myid</code>は等価である。
</li></ul>

<h2>5.4 <a name="type-selectors">型セレクタ</a></h2>

<p><a name="x11"><span class="index-def" title="type selector"><em>型セレクタ</em></span></a>は、文書言語の要素型の名前とマッチする。型セレクタは、文書ツリー内の要素型の全インスタンスとマッチする。

<div class="example"><P style="display:none">例：</P>
<P>次の規則は、文書ツリー内のすべてのH1要素とマッチする。</p>

<pre>
h1 { font-family: sans-serif }
</pre>
</div>

<h2>5.5 <a name="descendant-selectors">子孫セレクタ</a></h2>

<p>ときには、著者はセレクタが文書ツリー内の別の要素の子孫である要素とマッチさせたいこともあってもよい（たとえば、H1要素に含まれるEM要素にマッチさせる）。<a name="x12"><span
class="index-def" title="descendant-selectors">子孫セレクタ</span></a>は、パターン内のそのような関係を表現する。子孫セレクタは、<a href="syndata.html#whitespace">空白</a>で区切られた2つ以上のセレクタで構成される。形式"<code>A B</code>"の子孫セレクタは、要素<code>B</code>が、ある<a
href="conform.html#doctree">祖先</a>要素<code>A</code>の任意の子孫である場合にマッチする。

<div class="example"><P style="display:none">例：</P><p>
たとえば、次の規則を考えてみる：</p>

<pre>
h1 { color: red }
em { color: red }
</pre>

<p>この規則の意図するところは、文字色の変更によってテキストを強調することだが、次のような場合にその効果は失われる。</p>

<pre class="html-example">
&lt;H1&gt;This headline is &lt;EM&gt;very&lt;/EM&gt; important&lt;/H1&gt;
</pre>

<p>この場合、どこかのH1内にEMが出現する際にいつでも文字色を青に設定する規則を、以前の規則に補完することによって対処する：</p>

<pre>
h1 { color: red }
em { color: red }
h1 em { color: blue }
</pre>

<p>3番目の規則は以下の断片でEMとマッチする：</p>

<pre class="html-example">
&lt;H1&gt;This &lt;SPAN class="myclass"&gt;headline 
is &lt;EM&gt;very&lt;/EM&gt; important&lt;/SPAN&gt;&lt;/H1&gt;
</pre>
</div>

<div class="example"><P style="display:none">例：</P><P>
以下のセレクタは:</p>

<PRE>
div * p 
</PRE>

<P>DIV要素の孫またはそれ以上の代の子孫となるP要素にマッチする。"*"の両側の空白は、全称セレクタの一部でないことに注意する。空白は、DIVが要素の祖先でなければならないこと、およびその要素がPの祖先でなければならないことを意味する結合子である。
</div>

<div class="example"><P style="display:none">例：</P><p>
子孫セレクタと<a href="#attribute-selectors">属性セレクタ</a>を組み合わせたものが以下の規則である。このセレクタは、(1) "href"属性が設定されており、(2) DIVの内側にあってPの内部にある任意の要素にマッチする。</p>

<pre>
div p *[href]
</pre>
</div>

<h2>5.6 <a name="child-selectors">子セレクタ</a></h2>

<p>要素がある要素の<a
href="conform.html#doctree">子</a>である場合、<a name="x13"><span class="index-def" title="child selector"><em>子セレクタ</em></span></a>はマッチする。子セレクタは"&gt;"で区切られた2つ以上のセレクタで構成される。

<div class="example"><P style="display:none">例：</P><p>
次の規則は、BODYの子であるすべてのP要素にスタイルを設定する:</p>

<pre>
body &gt; P { line-height: 1.3 }
</pre>
</div>

<div class="example"><P style="display:none">例：</P><P>
次の例は、子孫セレクタと子セレクタを組み合わせている:</p>
<pre>
div ol&gt;li p
</pre>

<P>このセレクタはLIの子孫であるP要素にマッチする。LI要素はOL要素の子でなければならず、OL要素はDIVの子孫でなければならない。"&gt;"結合子の前後の空白が省略されていることに注意する。
</div>

<P>ある要素における最初の子のセレクタに関する詳細は、<a href="#first-child">:first-child</a>擬似クラスの節を参照のこと。 

<h2>5.7 <a name="adjacent-selectors">隣接兄弟セレクタ</a></h2>

<p>隣接兄弟セレクタはE1 + E2の構文を持つ。この場合E2がセレクタの主体である。E1とE2が文書ツリーで同じ親を共有し、かつE1の直後にE2が続く場合、非要素ノード（テキストノードやコメントなど）を無視してセレクタはマッチする。

<div class="example"><P style="display:none">例：</P><p>
したがって、次の規則は、P要素がMATH要素の直後に続く場合、P要素をインデントすべきでないことを提示している：</p>

<pre>
math + p { text-indent: 0 } 
</pre>

<p>次の例は、H1とその直後に続くH2の間にある垂直方向のスペースを削減する：</p>

<pre>
h1 + h2 { margin-top: -5mm }   
</pre>
</div>

<div class="example"><P style="display:none">例：</P><p> 
次の規則は、クラスセレクタが追加されたことを除けば、上の例と同様である。したがって、H1が<samp>class="opener"</samp>を持つ場合に限り、特別な整形効果が現れる：</p>

<pre>
h1.opener + h2 { margin-top: -5mm }   
</pre>
</div>

<h2>5.8 <a name="attribute-selectors">属性セレクタ</a></h2>

<p>CSS&nbsp;2.2 allows authors to specify rules that match elements
which have certain attributes defined
in the source document.



<h3>5.8.1 <a name="matching-attrs">属性および属性値のマッチング</a></h3>

<P>属性セレクタは、4つの方法でマッチしてもよい：</p>

<dl>
<dt><code>[att]</code>
<dd>要素の"att"属性が任意の値を設定する場合にマッチする。
<dt><a name="x14"><span class="index-def" title="exact
matching|="><code>[att=val]</code></span></a>
<dd>要素の"att"属性値が厳密に"val"である場合にマッチする。
<dt><a name="x16"><span class="index-def" title="space-separated
matching|~="><code>[att~=val]</code></span></a>
<dd>空白区切りのリストで、そのうちの1つの単語が厳密に"val"であるような<code>att</code>属性値を持つ要素を意味する。"val"が空白に相当する場合、（単語が空白<em>区切り</em>なので）何かを意味することは決してない。"val"が空の文字列の場合、いずれも意味するものではない。
<dt><a name="x18"><span class="index-def" title="hyphen-separated
matching||="><code>[att|=val]</code></span></a>
<dd>値が厳密に"val"または"val"で始まり直後に"-"（U+002D）が続くいずれかの<code>att</code>属性を持つ要素を意味する。これは、主にBCP 47（<a href="refs.html#ref-BCP47" rel="biblioentry" class="noxref"><span class="informref">[BCP47]</span></a>）またはその後継で説明されるような<a name="x20"><span
class="index-inst" title="language code">言語のサブコード</span></a>とマッチすることを意図している（たとえば、HTMLの<code>a</code>要素における<code>hreflang</code>属性）。<code>lang</code>（あるいは<code>xml:lang</code>）の言語のサブコードのマッチについては、<a
href="#lang"><code>:lang</code>擬似クラス</a>を参照のこと。
</dl>

<p>属性値は、識別子または文字列でなければならない。セレクタの属性名と属性値について、大文字・小文字区別は文書言語に依存する。

<div class="example"><P style="display:none">例：</P><p>
たとえば、以下の属性セレクタは、値にかかわらず"title"属性を指定するすべてのH1要素とマッチする：</p>

<pre>
h1[title] { color: blue; }
</pre>
</div>

<div class="example"><P style="display:none">例：</P><p>
次の例で、セレクタは、"class"属性が厳密に値"example"を持つすべてのSPAN要素にマッチする：</p>

<pre>
span[class=example] { color: blue; }
</pre>
</div>

<P>複合的な属性セレクタは、ある要素の複数の属性、または同一属性の複数回の参照できる。

<div class="example"><P style="display:none">例：</P><p>
ここでセレクタは、"hello"属性が厳密に値"Cleveland"を持ち、"goodbye"属性が厳密に値 "Columbus"を持つすべてのSPAN要素にマッチする：</P>

<pre>
span[hello="Cleveland"][goodbye="Columbus"] { color: blue; }
</pre>
</div>

<div class="example"><P style="display:none">例：</P><p>
以下のセレクタは"="と"~="の違いを示している。たとえば、最初のセレクタは、"rel"属性の値"copyright copyleft copyeditor"とマッチする。2つめのセレクタは、"href"属性が値"http://www.w3.org/"を持つ場合のみマッチする。
</p>

<pre>
a[rel~="copyright"]
a[href="http://www.w3.org/"]
</pre>
</div>

<div class="example"><P style="display:none">例：</P><P>
次の規則は、"lang"属性値が"fr"（フランス語）となっているすべての要素を非表示にする。

<PRE>
*[lang=fr] { display : none }
</PRE>
</div>

<div class="example"><P style="display:none">例：</P><P>
次の規則は、"lang"属性値が"en"で始まるものにマッチする。これは、"en"、"en-US"、"en-cockney"などを含む：</p>

<PRE>
*[lang|="en"] { color : red }
</PRE>
</div>

<div class="example"><P style="display:none">例：</P><P>
同様に、次の聴覚スタイルシートの規則は、セリフを各役割ごとに異なる声で読み上げさせる：</p>

<pre class="example">
DIALOGUE[character=romeo] 
     { voice-family: "Laurence Olivier", charles, male }
      
DIALOGUE[character=juliet]  
     { voice-family: "Vivien Leigh", victoria, female }
</pre>
</div>

<H3>5.8.2 <a name="default-attrs">DTDにおける属性の規定値</a></H3>

<P>マッチングは、文書ツリーの属性値に対して行われる。デフォルトの属性値は<a name="x21"><span class="index-inst"
title="DTD">DTD</span></a>または他の場所で定義されてもよいが、常に属性セレクタを選択できるとは限らない。スタイルシートは、デフォルト値が文書ツリーに含まれない場合でも動作するように設計されるべきである。

<p>より正確には、ユーザーエージェントは、DTDの"外部サブセット"を読んで、文書中にデフォルト属性値を検索することを要求され<em>なく</em>てよいが、文書の"内部サブセット"においては要求<em>されて</em>もよい（これらのサブセットの定義については、<a href="refs.html#ref-XML10" rel="biblioentry" class="noxref"><span class="normref">[XML10]</span></a>を参照のこと）。DTDの外部サブセットで定義されるデフォルトの属性値が文書ツリーに出現するかどうかは、ユーザーエージェントに依存する。

<p>ユーザーエージェントはXML名前空間<a href="refs.html#ref-XMLNAMESPACES" rel="biblioentry" class="noxref"><span class="informref">[XMLNAMESPACES]</span></a>を認識してもよいが、名前空間が文書に存在したかどうかにかかわらず、デフォルトの属性値を扱うために名前空間の知識を要求されない。（たとえば、XHTMLユーザーエージェントは、XHTMLのDTDの組み込み知識の使用を要求されない。）

<p class="note">一般に、実装は外部サブセットの無視を選択することに注意する。

<div class="example"><P style="display:none">例：</P>
<P style="display:none">Example:</P>
<P>たとえば、デフォルト値"decimal"である属性"notation"を持つ要素の例を考える。DTD断片はこのようになる

<pre class="dtd-example">
&lt;!ATTLIST EXAMPLE notation (decimal,octal) "decimal"&gt;
</pre>

<p>スタイルシートが次の規則を含むとすると

<pre class="example">
EXAMPLE[notation=decimal] { /*... 規定のプロパティー設定 ...*/ }
EXAMPLE[notation=octal]   { /*... 別の設定 ...*/ }
</pre>

<p>最初の規則は、その"notation"属性がデフォルトで設定されている要素とマッチしない場合がある。すなわち、明示的に設定されていないことがある。すべての場合を捕らえるには、デフォルト値の属性セレクタを削除しなければならない：</p>

<pre class="example">
EXAMPLE                   { /*... 規定のプロパティー設定 ...*/ }
EXAMPLE[notation=octal]   { /*... 別の設定 ...*/ }
</pre>

<p>ここで、セレクタ<code>EXAMPLE[notation=octal]</code>が単独の型セレクタよりも<a href="cascade.html#specificity">詳細</a>であるので、2番目の規則でのスタイル宣言は、"notation"の属性値"octal"を持つ要素が最初のものを上書きする。デフォルトの場合のみに適用される任意のプロパティーの宣言は、非デフォルトの場合のスタイル規則で上書きされることに配慮する必要がある。
</div>


<h3>5.8.3 <a name="class-html">クラスセレクタ</a></h3> 

<p>HTMLと連携する場合、著者は<code>class</code>属性を表す場合<code>~=</code>表記の代わりにピリオド（<code>.</code>）を使用してもよい。したがって、HTMLに対して、<code>div.value</code>と<code>div[class~=value]</code>は同じ意味を持つ。属性値は、"ピリオド"（<code>.</code>）の直後に続かなければならない。ユーザーエージェントは、それぞれの名前空間の"class"属性を決定するための名前空間固有の知識を持つ場合、XML文書にピリオド（.）表記を用いてセレクタを適用してもよい。名前空間固有の知識の一例は、特定の名前空間の仕様における文である（たとえば、SVG 1.1<a href="refs.html#ref-SVG11" rel="biblioentry" class="noxref"><span class="informref">[SVG11]</span></a>は<a
href="http://www.w3.org/TR/2003/REC-SVG11-20030114/styling.html#ClassAttribute">SVG"class"属性</a>およびユーザーエージェントが属性をどのように解釈すべきかを説明する。同様にMathML 3.0<a href="refs.html#ref-MATH30" rel="biblioentry" class="noxref"><span class="informref">[MATH30]</span></a>は<a
href="http://www.w3.org/TR/MathML2/chapter2.html#fund.globatt">MathML"class"属性</a>を説明する）。

<div class="example"><P style="display:none">例：</P><p>
たとえば、以下のように<samp>class~="pastoral"</samp>を持つすべての要素にスタイル情報を割り当て可能である：</p>

<pre>
*.pastoral { color: green }  /* class~=pastoralを持つ全要素 */
</pre>

または単に

<pre>
.pastoral { color: green }  /* class~=pastoralを持つ全要素 */
</pre>

<p>以下は、<samp>class~="pastoral"</samp>であるH1要素にのみスタイルを割り当てる：</p>

<pre>
H1.pastoral { color: green }  /* class~=pastoralを持つH1要素 */
</pre>

<p>この規則を考えると、以下の最初のH1要素のテキストは緑色にならないが、2番目のH1要素は緑色となる：</p>

<pre>
&lt;H1&gt;Not green&lt;/H1&gt;
&lt;H1 class="pastoral"&gt;Very green&lt;/H1&gt;
</pre>
</div>

<p>"class"値のサブセットをマッチングさせるには、"."の直後にそれぞれの値が存在しなければならない。</P>

<div class="example"><P style="display:none">例：</P><P>
たとえば、以下の規則は、"class"属性がスペース区切りのリストに"pastoral"と"marine"を含んだすべてのP要素とマッチする：</p>

<pre> 
p.marine.pastoral { color: green }
</pre>

<p>この規則は、<samp>class="pastoral blue aqua marine"</samp>とマッチするが、<samp>class="pastoral blue"</samp>とはマッチしない。
</div>

<div class="note"><p> <em><strong>注。</strong> CSSは、"class"属性に非常に大きな力を与える。したがって著者は、ほとんど見栄えに関係しない要素（HTMLでのDIVやSPANなど）のスタイル情報に基づき、"class"属性を使用して割り当てた独自の"文書言語"を設計することができる。著者は、文書言語の構造要素が意味を認識し受け入れていることが多いので、このような用法を避けるべきである。著者が定義したクラス名は認識されないかもしれない。</em>
</div>

<div class="note"><p><em><strong>注：</strong>要素が複数のクラス属性を持つ場合、クラスを検索する前にクラス値の間をスペースで連結されなければならない。しかし、執筆時点でワーキンググループはこの状況に到達する可能なすべての方法を認識していないため、本仕様においてこの動作は明確に非規範的である。</em>
</div>

<h2>5.9 <a name="id-selectors">IDセレクタ</a></h2>

<P>文書言語は、ID型と宣言される属性を含んでもよい。ID型属性の特殊さは、2つの属性が同値を持つことができないことにある。どのような文書言語でも、ID属性は一意に要素を識別するために使用できる。HTMLですべてのID属性は"id"と名付けられる。XMLアプリケーションは、異なるID属性に名前を付けてもよいが、同じ制約が適用される。

<p>文書言語のID属性は、文書ツリー内の1つの要素インスタンスに識別子を割り当て可能である。CSS IDセレクタは、その識別子に基づいて要素のインスタンスにマッチする。CSS IDセレクタは、"#"の直後にID値が続く識別子でなければならない。</p>

<p class=note>CSSはユーザーエージェントが要素のID属性を識別する方法を規定しないことに注意する。たとえば、ユーザーエージェントは文書のDTDを読むかもしれないし、決め打ちされた情報を持つかもしれないし、ユーザーに尋ねるかもしれない。

<div class="example"><P style="display:none">例：</P><p> 
以下のIDセレクタは、ID属性値"chapter1"であるH1要素とマッチする。</p>

<PRE>
h1#chapter1 { text-align: center }
</PRE>
</div>

<div class="html-example"><p> 
次の例でスタイル規則は、ID値"z98y"を持つ要素にマッチする。規則は、このようにP要素に対してマッチする:</p>

<pre>
&lt;HEAD&gt;
  &lt;TITLE&gt;Match P&lt;/TITLE&gt;
  &lt;STYLE type="text/css"&gt;
    *#z98y { letter-spacing: 0.3em }
  &lt;/STYLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
   &lt;P id=z98y&gt;Wide text&lt;/P&gt;
&lt;/BODY&gt;
</pre>

<p>しかし、次の例でスタイル規則は、"z98y"のID値を持つH1要素とマッチする。規則は、この例でP要素とマッチしない。</p>

<pre>
&lt;HEAD&gt;
  &lt;TITLE&gt;Match H1 only&lt;/TITLE&gt;
  &lt;STYLE type="text/css"&gt;
    H1#z98y { letter-spacing: 0.5em }
  &lt;/STYLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
   &lt;P id=z98y&gt;Wide text&lt;/P&gt;
&lt;/BODY&gt;
</pre>
</div>

<P>IDセレクタは属性セレクタよりも高い詳細度を持つ。たとえばHTMLで、セレクタ<samp>#p123</samp>は、<a
href="cascade.html">カスケード</a>の面で<samp>[id=p123]</samp>より詳細である。

<div class="note">
<p><em><strong>注。</strong>XML 1.0<a href="refs.html#ref-XML10" rel="biblioentry" class="noxref"><span class="informref">[XML10]</span></a>において、どの属性が要素のIDを含むかに関する情報は、DTDに含まれる。XMLを解析する際、ユーザーエージェントは常にDTDを読むとは限らないため、どの要素のIDであるかを識別できないかもしれない。スタイルシートの設計者がこのような場合になると知っている、もしくは疑う場合、<code>#p371</code>の代わりに<code>[name=p371]</code>のような通常の属性セレクタを使用すべきである。しかし、通常の属性セレクタのカスケード順序は、IDセレクタとは異なる。<code>[name=p371] {color: red ! important}</code> のように、宣言に"!important"プロパティーを追加する必要があるかもしれない。</em>
</div>

<p>要素が複数のID属性を持つ場合、ID属性のすべては、IDセレクタのために、その要素のIDとして扱われなければならない。このような状況は、xml:id <a href="refs.html#ref-XMLID" rel="biblioentry" class="noxref"><span class="informref">[XMLID]</span></a>、DOM3 Core <a href="refs.html#ref-DOM-LEVEL-3-CORE" rel="biblioentry" class="noxref"><span class="informref">[DOM-LEVEL-3-CORE]</span></a>、XML DTD <a href="refs.html#ref-XML10" rel="biblioentry" class="noxref"><span class="informref">[XML10]</span></a>と名前空間固有の知識の混合物を使用して達せられるだろう。

<h2>5.10 <a name="pseudo-elements">疑似要素</a>と<a
name="pseudo-classes">疑似クラス</a></h2>

<p>In CSS&nbsp;2.2, style is normally attached to an element based on its position in the <a href="conform.html#doctree">document tree</a>. この単純なモデルは、多くの場合十分だが、一部の一般的な公開シナリオは、<a
href="conform.html#doctree">文書ツリー</a>の構造に起因しない場合がある。たとえば、HTML 4（<a href="refs.html#ref-HTML4" rel="biblioentry" class="noxref"><span class="normref">[HTML4]</span></a>を参照）において、段落の最初の行を参照する要素は存在せず、したがってその行を参照してもよい単体CSSセレクタは存在しない。</p>

<p>CSSは、文書ツリーの外側にある情報に基づいた書式設定を可能にするために、<a name="x22"><span class="index-def"
title="擬似要素"><dfn>擬似要素</dfn></span></a>や<a name="x23"><span
class="index-def"
title="pseudo-classes"><dfn>擬似クラス</dfn></span></a>の概念を導入する。 </p>

<ul>
<li>擬似要素は、文書言語によって指定された範囲を超えて、文書ツリーに関する抽象概念を作成する。たとえば、文書言語は、要素の内容の最初の文字または最初の行にアクセスする仕組みを提供しない。CSS擬似要素は、スタイルシートの設計者がこのアクセスできない情報を参照することができる。また、擬似要素はスタイルシートの設計者がソース文書内で存在しない内容にスタイルを割り当てる手段を提供してもよい（たとえば、<a
href="generate.html#before-after-content">:beforeおよび:after</a>擬似要素が生成内容にアクセスできる）。

</li><li>疑似クラスは、要素の名前、属性またはコンテンツ以外の特徴で要素を分類する。その特徴は原則として、文書ツリーから推測できないものである。疑似クラスは、ユーザーが文書と対話する間、要素が擬似クラスを獲得したり喪失したりするという意味で、動的であってもよい。例外は、文書ツリーから推測<em>できる</em><a href="#first-child">':first-child'</a>、および場合によっては文書ツリーから推測できる<a href="#lang">':lang()'</a>である。
</li></ul>

<P>擬似要素も擬似クラスのいずれも文書ソースまたは文書ツリーに出現しない。

<P>疑似クラスは、セレクタ内のどこにでも許可されるが、擬似要素はセレクタの最後の単体セレクタの後にのみ追加してもよい。
</p>


<p>擬似要素および擬似クラスの名前は、大文字・小文字不区別である。</p>

<P>一部の擬似クラスは相互に排他的である一方、同じ要素に同時に適用可能なものもある。規則が競合する場合、通常の<a href="cascade.html#cascading-order">カスケード順序</A>が結果を決定する。

<h2>5.11 <a name="pseudo-class-selectors">擬似クラス</a></h2>

<h3>5.11.1 <a name="first-child">:first-child</a>擬似クラス</h3>

<P><a name="x24"><span class="index-def"
title="first-child|:first-child">:first-child</span></a>擬似クラスは、ある別の要素における最初の子要素にマッチする。

<div class="example"><P style="display:none">例：</P><P>
次の例において、セレクタはDIV要素の最初の子であるすべてのP要素にマッチする。規則は、DIVの第一段落のインデントを禁止する。</p>

<PRE>
div &gt; p:first-child { text-indent: 0 }
</PRE>

このセレクタは、以下の断片でDIV中のPにマッチする：

<pre class="html-example">
&lt;P&gt; The last P before the note.
&lt;DIV class="note"&gt;
   &lt;P&gt; The first P inside the note.
&lt;/DIV&gt;
</pre>

しかし、以下の断片で2つめのPにはマッチしない：

<pre class="html-example">
&lt;P&gt; The last P before the note.
&lt;DIV class="note"&gt;
   &lt;H2&gt;Note&lt;/H2&gt;
   &lt;P&gt; The first P inside the note.
&lt;/DIV&gt;
</pre>
</div>

<div class="example"><P style="display:none">例：</P>
<p>次の規則は、P要素の子孫であって最初の子であるEM要素に対して'bold'にフォントの太さを設定する：</p>

<pre>
p:first-child em { font-weight : bold }
</pre>
</div>

<P><a href="visuren.html#anonymous">匿名</a>ボックスは、文書ツリーの一部ではないので、最初の子を数えるときに匿名ボックスがカウントされないことに注意する。</p>

<div class="html-example"><P>
たとえば、EMについて：</p>

<PRE>
&lt;P&gt;abc &lt;EM&gt;default&lt;/EM&gt; 
</PRE>

これは、Pの最初の子である。
</div>

<P>次の2つのセレクタは等価である：</p>

<PRE>
* &gt; a:first-child   /* A要素は任意の要素の最初の子 */
a:first-child       /* 上に同じ */
</PRE>


<h3>5.11.2 <a name="link-pseudo-classes">リンク擬似クラス</a>：<a name="x26"><span
class="index-def" title="pseudo-classes:::link|:link|link
(pseudo-class)">:link</span></a>と<a name="x29"><span class="index-def"
title="pseudo-classes:::visited|:visited|visited
(pseudo-class)">:visited</span></a></h3>

<p>ユーザーエージェントは一般に、未訪問のリンクと訪問済みのリンクを区別して表示する。CSSは、これらを区別するために擬似クラス':link'および':visited'を提供する:</p>

<ul>
<li> :link擬似クラスは、未訪問のリンクに適用される。

</li><li> :visited擬似クラスは、ユーザーが一度訪問したリンクに適用される。
</li></ul>

<p>ユーザーエージェントは、ある時点で訪問済みリンクを（未訪問の）':link'状態に戻してもよい。

<P>2つの状態は互いに排他的である。

<p>どの要素がハイパーリンクのソースアンカーかについては、文書言語が決定する。たとえば、HTML4において、リンク擬似クラスは"href"属性を持つA要素に適用される。Thus, the following two CSS&nbsp;2.2 declarations have similar effect:</p>

<pre>
a:link { color: red }
:link  { color: red }
</pre>

<div class="example"><P style="display:none">例：</P><p>
次のリンクの場合：</p>

<pre class="html-example">
&lt;A class="external" href="http://out.side/"&gt;external link&lt;/A&gt;
</pre>

訪問済みの場合、この規則は：

<pre>
a.external:visited { color: blue }
</pre>

青色にする。
</div>

<p class=note>注。スタイルシート著者は、ユーザーの同意なしにユーザの訪問済みサイトを決定するために:linkおよび:visited擬似クラスを悪用することが可能である。

<p>したがって、ユーザーエージェントは、未訪問のリンクなどのすべてのリンクを扱う一方で、訪問済みまたは未訪問のリンクを異なるものとしてレンダリングし、ユーザのプライバシーを保護する他の手段を実装してもよい。プライバシーの取り扱いの詳細については<a href="refs.html#ref-P3P" rel="biblioentry" class="noxref"><span class="informref">[P3P]</span></a>を参照のこと。

<h3>5.11.3 <a name="dynamic-pseudo-classes">動的疑似クラス：</a><a name="x32"><span class="index-def" title="pseudo-classes:::hover|:hover|hover
(pseudo-class)">:hover</span></a>、<a name="x35"><span class="index-def"
title="pseudo-classes:::active|:active|active
(pseudo-class)">:active</span></a>、<a name="x38"><span class="index-def"
title="pseudo-classes:::focus|:focus|focus
(pseudo-class)">:focus</span></a></h3>

<p>対話的なユーザーエージェントは、時にはユーザーの動作に応じてレンダリングを変更する。CSSは、一般的な場合の3つの擬似クラスを提供する：</p>

<ul>
<li> :hover擬似クラスは、ユーザーが（ポインティングデバイスで）アクティブではない要素を指定する間に適用される。たとえば、視覚系ユーザーエージェントは、要素が生成したボックス上にカーソル（マウスポインタ）を置いたとき、この擬似クラスを適用できる。<a href="media.html#interactive-media-group">インタラクティブメディア</a>をサポートしないユーザーエージェントは、この擬似クラスをサポートする必要はない。<a href="media.html#interactive-media-group">インタラクティブメディア</a>をサポートする一部の適合ユーザーエージェントは、この擬似クラスをサポートできないかもしれない（たとえば、ペンデバイス）。

</li><li> :active擬似クラスは、ユーザーが要素をアクティブにする間に適用される。たとえば、ユーザーがマウスのボタンを押してから離すまでの間である。

</li><li> :focus疑似クラスは、フォーカスしている（キーボードイベントやテキスト入力の他の形態を受け入れる）間に適用する。
</li></ul>

<p>要素は複数の擬似クラスと同時にマッチしてもよい。

<p>CSSは、どの要素が上記の状態にあってもよいか、どのように状態が入力または出力されるかを定義しない。スクリプトは、要素がユーザーイベントに反応するかどうかを変更してもよく、異なるデバイスやユーザーエージェントは要素を指示したり、アクティブにするさまざまな方法があってもよい。

<p>CSS&nbsp;2.2 does not define if the parent of an element that is
':active' or ':hover' is also in that state.



<p>ユーザーエージェントは、擬似クラスの遷移のために現在表示されている文書のリフローを要求しない。たとえば、スタイルシートは、非アクティブなリンクよりもアクティブなリンクの<a href="fonts.html#propdef-font-size" class="noxref"><span
class="propinst-font-size">'font-size'</span></a>を大きくするよう指定してもよいが、これは読者がリンクを選択する際の文字の位置を変更してもよいため、ユーザーエージェントは対応するスタイル規則を無視してもよい。</p>

<div class="example"><P style="display:none">例：</P><p>

<pre>
A:link    { color: red }    /* 未訪問のリンク */
A:visited { color: blue }   /* 訪問済みリンク */
A:hover   { color: yellow } /* ユーザがマウスポインタを重ねている */
A:active  { color: lime }   /* アクティブなリンク */
</pre>

<p>A:hoverはA:linkとA:visitedの後に配置しなければならないことに注意する。そうでなければカスケーディング規則がA:hover規則の<a href="colors.html#propdef-color" class="noxref"><span
class="propinst-color">'color'</span></a>プロパティーを無効にしてしまうことになる。同様に、A:activeはA:hoverの後に配置されるため、A要素上でアクティブとホバーのどちらの場合でもアクティブ色（ライム色）が適用される。
</div>

<div class="example"><P style="display:none">例：</P>
<p>動的擬似クラスを組み合わた例:

<pre>
a:focus { background: yellow }
a:focus:hover { background: white }
</pre>

<P>最後のセレクタは、:focus疑似クラスかつ:hover擬似クラスであるA要素とマッチする。

</div>

 

<P>フォーカスアウトラインの表示については、<a href="ui.html#dynamic-outlines">動的なフォーカスアウトライン</a>の節を参照のこと。

<div class="note"><P>
<em><strong>注。</strong> CSS1において、':active'疑似クラスは、':link'および':visited'と相互に排他的であった。これはもはや当てはまらない。要素は、':visited'と':active'（または':link'と':active'）の両方になることができ、スタイル宣言が適用されるかどうかを通常のカスケード規則が決定する。
</em>
</div>

<div class="note"><P>
<em><strong>注。</strong> また、CSS1において':active'疑似クラスはリンクにのみ適用されることに注意する。</em>
</div>

<h3>5.11.4 <a name="lang">言語疑似クラス：</a><a name="x41"><span
class="index-def" title="pseudo-classes:::lang|:lang|lang
(pseudo-class)">:lang</span></a></h3>

<p>文書言語が要素の<a name="x44"><span class="index-inst"
title="language (human)">自然言語</span></a>を決定する方法を指定する場合、その言語に基づく要素とマッチするようなCSSのセレクタを記述可能である。たとえば、HTML<a href="refs.html#ref-HTML4" rel="biblioentry" class="noxref"><span class="normref">[HTML4]</span></a>で、"lang"属性、META要素、ことによると（HTTPヘッダのような）プロトコルからの情報の組み合わせで言語は決定される。XMLは、xml:langと呼ばれる属性を使用し、言語を決定するための他の文書の言語固有の方法があってもよい。

<p>擬似クラス':lang(C)'は言語Cの要素が存在すればマッチする。単に識別子のCに対して要素の言語の値と等しい場合でも、ハイフン区切りの部分文字列でも、あたかも<a
href="#attribute-selectors">'|='</a>演算子によって実行されたかのように同じ方法でマッチする。要素の言語の値に対するCのマッチングは、ASCIIの範囲内の文字において大文字・小文字不区別で行われる。識別子Cは妥当な言語名である必要はない。</p>

<p>Cは空であってはならない。

<p class=note>注：文書やプロトコルは、BCP 47 <a href="refs.html#ref-BCP47" rel="biblioentry" class="noxref"><span class="informref">[BCP47]</span></a>またはその後続由来のコードを用いて言語を指示することが推奨される。また、XMLベースの文書の場合は"xml:lang"属性による言語の指示が推奨される<a href="refs.html#ref-XML10" rel="biblioentry" class="noxref"><span class="normref">[XML10]</span></a>。<a
href="http://www.w3.org/International/questions/qa-lang-2or3"> "FAQ: Two-letter or three-letter language codes."</a>を参照のこと。</p>

<div class="example"><P style="display:none">例：</P>
<p>次の規則は、カナダにおけるフランス語またはドイツ語のいずれかのHTML文書に対して引用符を設定する：</p>

<pre>
html:lang(fr-ca) { quotes: '« ' ' »' }
html:lang(de) { quotes: '»' '«' '\2039' '\203A' }
:lang(fr) &gt; Q { quotes: '« ' ' »' }
:lang(de) &gt; Q { quotes: '»' '«' '\2039' '\203A' }
</pre>

<p>2番目の規則のペアは、実際には親要素の言語に従ってQ要素に<a href="generate.html#propdef-quotes" class="noxref"><span
class="propinst-quotes">'quotes'</span></a>プロパティーを設定する。一般に引用符の選択は、引用文自身ではなく、引用文の周囲にある要素の言語に基づくため、このような方法がとられる。英文中のフランス語の断片"à L' improviste"は英語の引用符を使用するのである。  </div>

<div class=note>
  <p><strong>注</strong> [lang|=xx]と:lang(xx)の違いに注意する。このHTMLの例において、BODYのみ[lang|=fr]にマッチする（LANG属性を持つため）。しかし、BODYとPの両方が:lang(fr)にマッチする（両方ともフランス語のため）。

  <pre>&lt;body lang=fr&gt;
  &lt;p&gt;Je suis Français.&lt;/p&gt;
&lt;/body&gt;</pre>
</div>

<h2>5.12 <a name="pseudo-element-selectors">擬似要素</a></h2>

<p>擬似要素は、以下と<a
href="generate.html#before-after-content">別の章</a>で説明する例外を除き、CSSにおいて実際の要素のように振る舞う。

<p class="note"><em>以下の節では、すべての場合における":first-line"や':first-letter'の正確なレンダリングを定義しないことに注意する。将来のCSSレベルは、これらをより正確に定義するかもしれない。</em>

<h3>5.12.1 <span class="index-def"
title="pseudo-elements:::first-line|:first-line|first-line"><a
name="first-line-pseudo">:first-line</a></span>疑似要素</h3>

<p>:first-line擬似要素は、段落の1行目に整形されるコンテンツに特別なスタイルを適用する。たとえば：</p>

<pre class="example">
p:first-line { text-transform: uppercase }
</pre>

<p>上記の規則は、"全段落の1行目の文字を大文字に変更する"ことを意味する。しかし、セレクタ"P:first-line"は実在するどのHTML要素ともマッチしない。このセレクタは、<a href="conform.html#conformance">適合ユーザーエージェント</a>が全段落の先頭に挿入する擬似要素とマッチする。</p>

<p>1行目の長さは、ページの幅、フォントサイズなどを含む多数の要因に依存することに注意する。したがって、次のようなよく目にするHTMLの段落は：</p>

<pre class="html-example">
&lt;P&gt;This is a somewhat long HTML 
paragraph that will be broken into several 
lines. The first line will be identified
by a fictional tag sequence. The other lines 
will be treated as ordinary lines in the 
paragraph.&lt;/P&gt;
</pre>

<p>次のように改行されたとすると：

<pre class="html-example">
THIS IS A SOMEWHAT LONG HTML PARAGRAPH THAT
will be broken into several lines. The first
line will be identified by a fictional tag 
sequence. The other lines will be treated as 
ordinary lines in the paragraph.
</pre>

<p>:first-lineの<em><a name="x48"><span
class="index-def" title="fictional tag sequence">仮想タグ</span></a></em>を含むようにユーザーエージェントによって"書き換え"られる。この仮想タグは、プロパティーの継承方法を示すのに役立つ。

<pre>
&lt;P&gt;<b>&lt;P:first-line&gt;</b> This is a somewhat long HTML 
paragraph that <b>&lt;/P:first-line&gt;</b> will be broken into several
lines. The first line will be identified 
by a fictional tag sequence. The other lines 
will be treated as ordinary lines in the 
paragraph.&lt;/P&gt;
</pre>

<p>擬似要素が実在の要素を分断してしまう場合、その要素を一度閉じて再び開くことで期待する効果を得る。したがって、SPAN要素を用いて前述の段落をマークアップする場合:</p>

<pre>
&lt;P&gt;<b>&lt;SPAN class="test"&gt;</b> This is a somewhat long HTML
paragraph that will be broken into several
lines.<b>&lt;/SPAN&gt;</b> The first line will be identified
by a fictional tag sequence. The other lines 
will be treated as ordinary lines in the 
paragraph.&lt;/P&gt;
</pre>

<p>:first-line仮想タグの挿入時に、ユーザーエージェントはSPANの開始タグと終了タグをシミュレーションできる。

<pre>
&lt;P&gt;&lt;P:first-line&gt;<b>&lt;SPAN class="test"&gt;</b> This is a
somewhat long HTML
paragraph that will <b>&lt;/SPAN&gt;</b>&lt;/P:first-line&gt;<b>&lt;SPAN class="test"&gt;</b> be
broken into several
lines.<b>&lt;/SPAN&gt;</b> The first line will be identified
by a fictional tag sequence. The other lines
will be treated as ordinary lines in the 
paragraph.&lt;/P&gt;
</pre>

<p> <a name="x49"><span class="index-inst"
title="pseudo-elements:::first-line">:first-line</span></a>擬似要素は、<a href="visuren.html#block-boxes">ブロックコンテナ要素</a>にのみ付属可能である。

<p><a name="first-formatted-line"></a>要素の"最初に整形される行"は、同じフローでブロックレベルの子孫の内部に出現してもよい（すなわち、配置もフロートもされていない、ブロックレベルの子孫）。たとえば、<code>&lt;DIV&gt;&lt;P&gt;This line...&lt;/P&gt;&lt;/DIV&gt;</code>のDIVの1行目は、Pの1行目である（PとDIVの両方がブロックレベルであると仮定）。

<p>テーブルセルまたはインラインブロックの最初の行は、最初に整形された祖先要素の行にすることはできない。したがって、<code>&lt;DIV&gt;&lt;P STYLE="display: inline-block"&gt;Hello&lt;BR&gt;Goodbye&lt;/P&gt; etcetera&lt;/DIV&gt;</code>において、DIVの最初に整形される行は"Hello"の行ではない。

<p class="note">なお、この断片のPの1行目<code>&lt;p&gt;&lt;br&gt;First...</code>は、いずれの文字も含まないことに注意する（HTML 4におけるBRの既定のスタイルを仮定）。単語"First"は、最初に整形される行ではない。

<p>ユーザーエージェントは、あたかもfirst-line疑似要素の仮想開始タグがちょうど最も内側のブロックレベル要素内にネストされていたかのように振る舞うべきである。（CSS1とCSS2はこのケースを暗に守っていたため、作者はこの動作に依存すべきではない。）次に例を示す。この断片に対する仮想タグは

<pre>
&lt;DIV&gt;
  &lt;P&gt;First paragraph&lt;/P&gt;
  &lt;P&gt;Second paragraph&lt;/P&gt;
&lt;/DIV&gt;
</pre>

<p>このようになる

<pre>
&lt;DIV&gt;
  &lt;P&gt;&lt;DIV:first-line&gt;&lt;P:first-line&gt;First paragraph&lt;/P:first-line&gt;&lt;/DIV:first-line&gt;&lt;/P&gt;
  &lt;P&gt;&lt;P:first-line&gt;Second paragraph&lt;/P:first-line&gt;&lt;/P&gt;
&lt;/DIV&gt;
</pre>


<p><a name="first-line">:first-line</a>擬似要素はインラインレベル要素に類似するが、一定の制限がある。:first-line擬似要素に適用されるプロパティーは次のとおり：<a
href="fonts.html">フォントプロパティー</a>、<a href="colors.html">色のプロパティー</a>、<a href="colors.html#background-properties">背景のプロパティー</a>、<a href="text.html#propdef-word-spacing" class="noxref"><span
class="propinst-word-spacing">'word-spacing'</span></a>、<a href="text.html#propdef-letter-spacing" class="noxref"><span
class="propinst-letter-spacing">'letter-spacing'</span></a>、<a href="text.html#propdef-text-decoration" class="noxref"><span
class="propinst-text-decoration">'text-decoration'</span></a>、<a href="text.html#propdef-text-transform" class="noxref"><span
class="propinst-text-transform">'text-transform'</span></a>、<a href="visudet.html#propdef-line-height" class="noxref"><span
class="propinst-line-height">'line-height'</span></a>。ユーザーエージェントは、他のプロパティーを同様に適用してもよい。</p>


<h3>5.12.2 <a name="first-letter"></a> <a name="x50"><span class="index-def" title="pseudo-elements:::first-letter|:first-letter|first-letter">:first-letter</span></a>疑似要素</h3>

<p>ある行に他のコンテンツ（画像やインラインテーブルなど）が先行しない場合、:first-letter擬似要素は、ブロックの1行目の最初の文字を選択しなければならない。:first-letter擬似要素は、一般的な印刷効果である<a name="x53"><span class="index-inst" title="initial
caps">"イニシャルキャップ"</span></a>および<a name="x54"><span class="index-inst" title="drop
caps">"ドロップキャップ"</span></a>として使用してもよい。<a href="visuren.html#propdef-float" class="noxref"><span class="propinst-float">'float'</span></a>プロパティーが'none'である場合、この種類の先頭文字はインラインレベル要素と、それ以外の場合はフロート要素と類似する。</p>

<p>次に述べるものは、:first-letter擬似要素に適用されるプロパティーである: <a href="fonts.html">フォントのプロパティー</a>、<a href="text.html#propdef-text-decoration" class="noxref"><span class="propinst-text-decoration">'text-decoration'</span></a>、<a href="text.html#propdef-text-transform" class="noxref"><span class="propinst-text-transform">'text-transform'</span></a>、<a href="text.html#propdef-letter-spacing" class="noxref"><span class="propinst-letter-spacing">'letter-spacing'</span></a>、<a href="text.html#propdef-word-spacing" class="noxref"><span class="propinst-word-spacing">'word-spacing'</span></a>（適切な場合）、<a href="visudet.html#propdef-line-height" class="noxref"><span class="propinst-line-height">'line-height'</span></a>、<a href="visuren.html#propdef-float" class="noxref"><span class="propinst-float">'float'</span></a>、<a href="visudet.html#propdef-vertical-align" class="noxref"><span class="propinst-vertical-align">'vertical-align'</span></a>（'float'が'none'の場合のみ）、<a href="box.html#margin-properties">マージンプロパティー</a>、<a href="box.html#padding-properties">パディングプロパティー</a>、<a href="box.html#border-properties">ボーダープロパティー</a>、<a href="colors.html">色のプロパティー</a>、<a href="colors.html#background-properties">背景のプロパティー</a>。ユーザーエージェントは、他のプロパティーと同様に適用されてもよい。活字として正確なイニシャルキャップまたはドロップキャップをレンダリングできるようにするために、ユーザーエージェントは、通常の要素の場合とは異なった行の高さや文字の形状に基づく幅と高さを選択してもよい。CSS3は、先頭文字に適用される特定のプロパティーを持つことが期待される。
</p>

<div class="html-example">
<p>この例では、イニシャルキャップの可能なレンダリングを示している。first-letter擬似要素によって継承される'line-height'は1.1であるが、この例ではユーザーエージェントが異なる先頭文字の高さを計算しているため、最初の2行の間に不要なスペースが発生しないことに注意する。また、先頭文字の仮想開始タグがSPANの内部にあるため、先頭文字のフォントの太さはnormalであり、boldでないことにも注意する。
<pre>
p { line-height: 1.1 }
p:first-letter { font-size: 3em; font-weight: normal }
span { font-weight: bold }
...
&lt;p&gt;&lt;span&gt;Het hemelsche&lt;/span&gt; gerecht heeft zich ten lange lesten&lt;br&gt;
Erbarremt over my en mijn benaeuwde vesten&lt;br&gt;
En arme burgery, en op mijn volcx gebed&lt;br&gt;
En dagelix geschrey de bange stad ontzet.
</pre>
<div class="figure">
<p><img src="http://www.w3.org/TR/CSS2/images/initial-cap.png" alt="first-letter擬似要素の説明画像">
</div>
</div>

<div class="html-example">
<p>The following CSS&nbsp;2.2 will make a drop cap initial letter span about two lines:</p>

<pre>
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;HTML&gt;
 &lt;HEAD&gt;
  &lt;TITLE&gt;Drop cap initial letter&lt;/TITLE&gt;
  &lt;STYLE type="text/css"&gt;
   P              { font-size: 12pt; line-height: 1.2 }
   P:first-letter { font-size: 200%; font-style: italic;
                    font-weight: bold; float: left }
   SPAN           { text-transform: uppercase }
  &lt;/STYLE&gt;
 &lt;/HEAD&gt;
 &lt;BODY&gt;
  &lt;P&gt;&lt;SPAN&gt;The first&lt;/SPAN&gt; few words of an article
    in The Economist.&lt;/P&gt;
 &lt;/BODY&gt;
&lt;/HTML&gt;
</pre>

<p>この例は次のように整形される：</p>

<div class="figure">
<P><img src="http://www.w3.org/TR/CSS2/images/first-letter.png" alt=":first-letterと:first-line疑似要素の組み合わせ効果を説明する画像"><SPAN class="dlink">&nbsp;&nbsp;&nbsp;<A name="img-first-letter" href="http://www.w3.org/TR/CSS2/images/longdesc/first-letter-desc.html" title="ドロップキャップの例について">[D]</A></SPAN></p>
</div>

<p><a name="x55"><span class="index-inst" title="fictional tag sequence">仮想タグ</span></a>は次のとおり：</p>

<pre>
&lt;P&gt;
&lt;SPAN&gt;
&lt;P:first-letter&gt;
T
&lt;/P:first-letter&gt;he first
&lt;/SPAN&gt; 
few words of an article in the Economist.
&lt;/P&gt;
</pre>

<p>:first-line擬似要素の開始タグが右側にあるブロック要素の開始タグの後に挿入されると同時に、:first-letter擬似要素のタグはコンテンツ（すなわち、先頭文字）に隣接することに注意する。</p>
</div>

<P>伝統的なドロップキャップ整形を実現するため、たとえばベースラインを揃えるために、ユーザーエージェントはフォントサイズを近似してもよい。また、整形の際、グリフのアウトラインを考慮してもよい。

<P>句読点（すなわち、Unicode<a href="refs.html#ref-UNICODE" rel="biblioentry" class="noxref"><span class="normref">[UNICODE]</span></a>で定義されている文字、"open"（Ps）、"close"（Pe）、"initial"（Pi）、"final"（Pf）、"other"（Po）の句読点クラス）が先行または先頭文字の後に続く場合、次のように文字が含まれるべきである：</p>

<div class="figure">
<P><img src="http://www.w3.org/TR/CSS2/images/first-letter2.png" alt="最初の文字に先行する引用符を含めべきである。"><SPAN class="dlink">&nbsp;&nbsp;&nbsp;<A name="img-first-letter2" href="http://www.w3.org/TR/CSS2/images/longdesc/first-letter2-desc.html" title="句読点とドロップキャップの例">[D]</A></SPAN></p>
</div>

<p>':first-letter'は先頭文字が数字である場合も適用される。たとえば、"67万ドルのお金がたくさんある。"の"6"など。

<p>:first-letter擬似要素は、<a href="visuren.html#block-boxes">ブロックコンテナ要素</a>に適用される。

<p>:first-letter擬似要素は、テキストを含む、または同じフローでテキストが含まれた子孫を持つすべての要素で使用できる。ユーザーエージェントは、その最初のテキストが子孫に存在する場合でも、first-letter擬似要素の仮想開始タグが要素の最初のテキストの前にいるかのように振る舞うべきである。</p>

<div class=example><P style="display:none">例：</P>
<p>以下に例を示す。このHTMLの断片に対して仮想タグは：
<pre>
&lt;div&gt;
&lt;p&gt;The first text.
</pre>
<p>次のようになる：
<pre>
&lt;div&gt;
&lt;p&gt;&lt;div:first-letter&gt;&lt;p:first-letter&gt;T&lt;/...&gt;&lt;/...&gt;he first text.
</pre>
</div>

<p>テーブルセルまたはインラインブロックの先頭文字は、祖先要素の先頭文字にすることはできない。したがって、<code>&lt;DIV&gt;&lt;P STYLE="display: inline-block"&gt;Hello&lt;BR&gt;Goodbye&lt;/P&gt; etcetera&lt;/DIV&gt;</code>において、DIVの先頭文字は"H"ではない。実際、DIVは先頭文字を持たない。

<p>先頭文字は、<a
href="#first-formatted-line">最初に整形される行</a>で出現しなければならない。たとえば、この断片: <code>&lt;p&gt;&lt;br&gt;First...</code>最初の行はいずれの文字も含まず、":first-letter"はマッチしない（HTML 4でBRの既定のスタイルを仮定）。具体的には、"First"の"F"とはマッチしない。

<p>要素が<a href="generate.html#lists">リスト項目</a>（'display: list-item'）の場合、':first-letter'は、マーカーの後の主ボックスの先頭文字に適用される。ユーザーエージェントは、'list-style-position: inside'を伴うリストの項目上の':first-letter'を無視してもよい。要素が':before'か':after'の内容を持つ場合、':first-letter'はそのコンテンツを<em>含む</em>要素の先頭文字に適用される。

<p class="example">
たとえば、規則'p:before {content: "Note: "}'の後で、セレクタ'p:first-letter'は"Note"の"N"とマッチする。

<p>
一部の言語は、特定の文字の組み合わせを扱う方法について、特定の規則を持つかもしれない。たとえば、オランダ語において、文字結合"ij"が単語の先頭に出現する場合、どちらも:first-letter擬似要素内に含まれるよう考慮されるべきである。

<p><code>&lt;p&gt;'&lt;em&gt;T...</code>における"'T"のように、同じ要素内で先頭文字を形成しないおそれのある場合、ユーザーエージェントは、要素の1つからまたは両方の要素からfirst-letter擬似要素を作成してもよいし、または単に擬似要素を作成しなくてもよい。

<p>同様に、ブロックの先頭文字が行の先頭でない（たとえば双方向の並べ替えに起因する）場合、ユーザーエージェントは擬似要素を作成する必要はない。

<div class="example"><P style="display:none">例：</P><p>
<a name="overlapping-example">次の例</a>は、擬似要素が重なった場合にどのような相互作用をもたらすかを示している。各P要素の先頭文字は、'24pt'のフォントサイズで緑色になる。最初に整形される行の残りは'青'になり、残りの段落は'赤'になる。</p>

<pre>
p { color: red; font-size: 12pt }
p:first-letter { color: green; font-size: 200% }
p:first-line { color: blue }

&lt;P&gt;Some text that ends up on two lines&lt;/P&gt;
</pre>

<p>単語"ends"の前に改行が出現すると仮定すると、この断片に対して<a name="x56"><span class="index-inst" title="fictional tag sequence">仮想タグ</span></a>は次のようになる：</p>

<pre>
&lt;P&gt;
&lt;P:first-line&gt;
&lt;P:first-letter&gt; 
S 
&lt;/P:first-letter&gt;ome text that 
&lt;/P:first-line&gt; 
ends up on two lines 
&lt;/P&gt;
</pre>

<p>:first-letter要素が:first-line要素の内部にあることに注意する。:first-lineに設定されたプロパティーは、:first-letterに継承されるが、同じプロパティーが:first-letterに設定される場合は上書きされる。</p>
</div>

<h3>5.12.3 <a name="before-and-after"></a> <a name="x57"><span class="index-def"
title="pseudo-elements:::before|:before">:before</span></a>および<a name="x59"><span
class="index-def" title="pseudo-elements:::after|:after">:after</span></a>疑似要素</h3>

<p>':before'および':after'擬似要素'は、ある要素のコンテンツの前後に生成コンテンツを挿入可能である。これらは、<a href="generate.html">生成テキスト</a>の節で説明される。

<div class="example"><P style="display:none">例：</P><P>

<pre>
h1:before {content: counter(chapno, upper-roman) ". "}
</pre>
</div>

<p>:first-letterおよび:first-line擬似要素が:beforeおよび:afterを用いて生成されたコンテンツを持つ要素に適用される場合、これらは生成されたコンテンツを含む要素の先頭文字または先頭行に適用される。

<div class="example"><P style="display:none">例：</P><P>

<pre>
p.special:before {content: "Special! "}
p.special:first-letter {color: #ffd800}
</pre>

<p>これは、"Special!"の"S"を金色にレンダリングする。
</div>

<hr class="navbar">

<div class="navbar">
<p><a href="syndata.html">前章</a> &nbsp; <a href="cascade.html">次章</a> &nbsp; <a href="cover.html#minitoc">目次</a> &nbsp; <a href="propidx.html">プロパティー</a> &nbsp; <a href="indexlist.html">索引</a> &nbsp;
</div>
</body>
</html>

