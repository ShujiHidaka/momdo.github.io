<!DOCTYPE html><html lang="ja"><meta charset="utf-8"><title>8 HTML構文 — HTML5 日本語訳</title><script src="link-fixup.js"></script>
<style type="text/css">
body {line-height:1.5;}
     .applies thead th > * { display: block; }
     .applies thead code { display: block; }
     .applies tbody th { white-space: nowrap; }
     .applies td { text-align: center; }
     .applies .yes { background: yellow; }

     .matrix, .matrix td { border: hidden; text-align: right; }
     .matrix { margin-left: 2em; }

     .dice-example { border-collapse: collapse; border-style: hidden solid solid hidden; border-width: thin; margin-left: 3em; }
     .dice-example caption { width: 30em; font-size: smaller; font-style: italic; padding: 0.75em 0; text-align: left; }
     .dice-example td, .dice-example th { border: solid thin; width: 1.35em; height: 1.05em; text-align: center; padding: 0; }

     td.eg { border-width: thin; text-align: center; }

     #table-example-1 { border: solid thin; border-collapse: collapse; margin-left: 3em; }
     #table-example-1 * { font-family: "Essays1743", serif; line-height: 1.01em; }
     #table-example-1 caption { padding-bottom: 0.5em; }
     #table-example-1 thead, #table-example-1 tbody { border: none; }
     #table-example-1 th, #table-example-1 td { border: solid thin; }
     #table-example-1 th { font-weight: normal; }
     #table-example-1 td { border-style: none solid; vertical-align: top; }
     #table-example-1 th { padding: 0.5em; vertical-align: middle; text-align: center; }
     #table-example-1 tbody tr:first-child td { padding-top: 0.5em; }
     #table-example-1 tbody tr:last-child td { padding-bottom: 1.5em; }
     #table-example-1 tbody td:first-child { padding-left: 2.5em; padding-right: 0; width: 9em; }
     #table-example-1 tbody td { padding-left: 2em; padding-right: 2em; }
     #table-example-1 tbody td:first-child + td { width: 10em; }
     #table-example-1 tbody td:first-child + td ~ td { width: 2.5em; }
     #table-example-1 tbody td:first-child + td + td + td ~ td { width: 1.25em; }

     .apple-table-examples { border: none; border-collapse: separate; border-spacing: 1.5em 0em; width: 40em; margin-left: 3em; }
     .apple-table-examples * { font-family: "Times", serif; }
     .apple-table-examples td, .apple-table-examples th { border: none; white-space: nowrap; padding-top: 0; padding-bottom: 0; }
     .apple-table-examples tbody th:first-child { border-left: none; width: 100%; }
     .apple-table-examples thead th:first-child ~ th { font-size: smaller; font-weight: bolder; border-bottom: solid 2px; text-align: center; }
     .apple-table-examples tbody th, .apple-table-examples tfoot th { font: inherit; text-align: left; }
     .apple-table-examples td { text-align: right; vertical-align: top; }
     .apple-table-examples.e1 tbody tr:last-child td { border-bottom: solid 1px; }
     .apple-table-examples.e1 tbody + tbody tr:last-child td { border-bottom: double 3px; }
     .apple-table-examples.e2 th[scope=row] { padding-left: 1em; }
     .apple-table-examples sup { line-height: 0; }

     .details-example img { vertical-align: top; }

     #base64-table {
       white-space: nowrap;
       font-size: 0.6em;
       column-width: 6em;
       column-count: 5;
       column-gap: 1em;
       -moz-column-width: 6em;
       -moz-column-count: 5;
       -moz-column-gap: 1em;
       -webkit-column-width: 6em;
       -webkit-column-count: 5;
       -webkit-column-gap: 1em;
     }
     #base64-table thead { display: none; }
     #base64-table * { border: none; }
     #base64-table tbody td:first-child:after { content: ':'; }
     #base64-table tbody td:last-child { text-align: right; }

     #named-character-references-table {
       white-space: nowrap;
       font-size: 0.6em;
       column-width: 30em;
       column-gap: 1em;
       -moz-column-width: 30em;
       -moz-column-gap: 1em;
       -webkit-column-width: 30em;
       -webkit-column-gap: 1em;
     }
     #named-character-references-table > table > tbody > tr > td:first-child + td,
     #named-character-references-table > table > tbody > tr > td:last-child { text-align: center; }
     #named-character-references-table > table > tbody > tr > td:last-child:hover > span { position: absolute; top: auto; left: auto; margin-left: 0.5em; line-height: 1.2; font-size: 5em; border: outset; padding: 0.25em 0.5em; background: white; width: 1.25em; height: auto; text-align: center; }
     #named-character-references-table > table > tbody > tr#entity-CounterClockwiseContourIntegral > td:first-child { font-size: 0.5em; }

     .glyph.control { color: red; }

     @font-face {
       font-family: 'Essays1743';
       src: url('fonts/Essays1743.ttf');
     }
     @font-face {
       font-family: 'Essays1743';
       font-weight: bold;
       src: url('fonts/Essays1743-Bold.ttf');
     }
     @font-face {
       font-family: 'Essays1743';
       font-style: italic;
       src: url('fonts/Essays1743-Italic.ttf');
     }
     @font-face {
       font-family: 'Essays1743';
       font-style: italic;
       font-weight: bold;
       src: url('fonts/Essays1743-BoldItalic.ttf');
     }

    </style>
<style type="text/css">
       pre { margin-left: 2em; white-space: pre-wrap; }
       h2 { margin: 3em 0 1em 0; }
       h3 { margin: 2.5em 0 1em 0; }
       h4 { margin: 2.5em 0 0.75em 0; }
       h5, h6 { margin: 2.5em 0 1em; }
       h1 + h2, h1 + h2 + h2, h1 + p, h1 + p + h2 { margin: 0.75em 0 0.75em; }
       h2 + h3, h3 + h4, h4 + h5, h5 + h6 { margin-top: 0.5em; }
       p { margin: 1em 0; }
       hr:not(.top) { display: block; background: none; border: none; padding: 0; margin: 2em 0; height: auto; }
       .element dd,  .element dl { margin-top: 0em; margin-bottom: 0.25em;}
       dt { margin-top: 0.75em; margin-bottom: 0.5em; clear: left; }
        .element dt { margin-top: 0.5em; margin-bottom: 0.5em;  }
       dt + dt { margin-top: 0; }
       dd dt { margin-top: 0.25em; margin-bottom: 0; }
       dd p { margin-top: 0; }
       dd dl + p { margin-top: 1em; }
       dd table + p { margin-top: 1em; }
       p + * > li, dd li { margin: 1em 0; }
       dt, dfn { font-weight: bold; font-style: normal; }
       i, em { font-style: italic; }
       dt dfn { font-style: italic; }
       pre, code { font-size: inherit; font-family: monospace; font-variant: normal; }
       pre strong { color: black; font: inherit; font-weight: bold; background: yellow; }
       pre em { font-weight: bolder; font-style: normal; }
       @media screen { code { color: #D93B00; } code :link, code :visited { color: inherit; } }
       var { background-color: #f9f9f9; border: 1px solid #eee; padding: 0 2px; }
       var sub { vertical-align: bottom; font-size: smaller; position: relative; top: 0.1em; }
       table { border-collapse: collapse; border-style: hidden hidden none hidden; }
       table thead, table tbody { border-bottom: solid; }
       table tbody th:first-child { border-left: solid; }
       table tbody th { text-align: left; }
       table td, table th { border-left: solid; border-right: solid; border-bottom: solid thin; vertical-align: top; padding: 0.2em; }
       blockquote { margin: 0 0 0 2em; border: 0; padding: 0; font-style: italic; }

       .bad, .bad *:not(.XXX) { color: #5F6D7A; border-color: gray; background: transparent; }
       .matrix, .matrix td { border: none; text-align: right; }
       .matrix { margin-left: 2em; }
       .dice-example { border-collapse: collapse; border-style: hidden solid solid hidden; border-width: thin; margin-left: 3em; }
       .dice-example caption { width: 30em; font-size: smaller; font-style: italic; padding: 0.75em 0; text-align: left; }
       .dice-example td, .dice-example th { border: solid thin; width: 1.35em; height: 1.05em; text-align: center; padding: 0; }

       .toc dfn, h1 dfn, h2 dfn, h3 dfn, h4 dfn, h5 dfn, h6 dfn { font: inherit; }
       img.extra, p.overview { float: right; }
       pre.idl { border: solid thin #d3d3d3; background: #FCFCFC; color: black; padding: 0.5em 1em; position: relative; }
       pre.idl :link, pre.idl :visited { color: inherit; background: transparent; }
       pre.idl::before { content: "IDL"; font: bold small sans-serif; padding: 0.5em; background: white; position: absolute; top: 0; margin: -1px 0 0 -4em; width: 1.5em; border: thin solid; border-radius: 0 0 0 0.5em }
       pre.css { border: solid thin; background: #FFFFEE; color: black; padding: 0.5em 1em; }
       pre.css:first-line { color: #AAAA50; }
       dl.domintro {padding: 0.5em 1em; border: none; background:#E9FBE9; border: 1px solid lightgray; }
       hr + dl.domintro, div.impl + dl.domintro { margin-top: 2.5em; margin-bottom: 1.5em; }
       dl.domintro dt, dl.domintro dt * { color: black; text-decoration: none; }
       dl.domintro dd { margin: 0.5em 0 1em 2em; padding: 0; }
       dl.domintro dd p { margin: 0.5em 0; }
       dl.domintro:before { display: table; margin: -1em -0.5em -0.5em auto; width: auto; content: 'This definition is non-normative. Implementation requirements are given below this definition.'; color: #606060; border:1px solid lightgray; background: white; padding: 0 0.25em;font-size:.9em;}
       dl.switch { padding-left: 2em; }
       dl.switch > dt { text-indent: -1.5em; }
       dl.switch > dt:before { content: '\21AA'; padding: 0 0.5em 0 0; display: inline-block; width: 1em; text-align: right; line-height: 0.5em; }
       dl.triple { padding: 0 0 0 1em; }
       dl.triple dt, dl.triple dd { margin: 0; display: inline }
       dl.triple dt:after { content: ':'; }
       dl.triple dd:after { content: '\A'; white-space: pre; }
       .diff-old { text-decoration: line-through; color: silver; background: transparent; }
       .diff-chg, .diff-new { text-decoration: underline; color: green; background: transparent; }
       a .diff-new { border-bottom: 1px blue solid; }

       figure.diagrams { border: double black; background: white; padding: 1em; }
       figure.diagrams img { display: block; margin: 1em auto; } 

       h2 { page-break-before: always; }
       h1, h2, h3, h4, h5, h6 { page-break-after: avoid; }
       h1 + h2, hr + h2.no-toc { page-break-before: auto; }

       p  > span:not([title=""]):not([class="XXX"]):not([class="impl"]):not([class="note"]):not([class="t2"]):not([id]):not([lang]),
       li > span:not([title=""]):not([class="XXX"]):not([class="impl"]):not([class="note"]):not([class="t2"]):not([id]):not([lang])
       { border-bottom: solid #9999CC; }

       div.head { margin: 0 0 1em; padding: 1em 0 0 0; }
       div.head p { margin: 0; }
       div.head h1 { margin: 0; }
       div.head .logo { float: right; margin: 0 1em; }
       div.head .logo img { border: none } /* remove border from top image */
       div.head dl { margin: 1em 0; }
       div.head p.copyright, div.head p.alt { font-size: x-small; font-style: oblique; margin: 0; }

       body > .toc > li { margin-top: 1em; margin-bottom: 1em; }
       body > .toc.brief > li { margin-top: 0.35em; margin-bottom: 0.35em; }
       body > .toc > li > * { margin-bottom: 0.5em; }
       body > .toc > li > * > li > * { margin-bottom: 0.25em; }
       .toc, .toc li { list-style: none; }

       .brief { margin-top: 1em; margin-bottom: 1em; line-height: 1.1; }
       .brief li { margin: 0; padding: 0; }
       .brief li p { margin: 0; padding: 0; }

       .category-list { margin-top: -0.75em; margin-bottom: 1em; line-height: 1.5; }
       .category-list::before { content: '\21D2\A0'; font-size: 1.2em; font-weight: 900; }
       .category-list li { display: inline; }
       .category-list li:not(:last-child)::after { content: ', '; }
       .category-list li > span, .category-list li > a { text-transform: lowercase; }
       .category-list li * { text-transform: none; } /* don't affect <code> nested in <a> */

       .XXX { color: #E50000; background: white; border: solid red; padding: 0.5em; margin: 1em 0; }
       .XXX > :first-child { margin-top: 0; }
       p .XXX { line-height: 3em; }
       .annotation { border: solid thin black; background: #0C479D; color: white; position: relative; margin: 8px 0 20px 0; }
       .annotation:before { position: absolute; left: 0; top: 0; width: 100%; height: 100%; margin: 6px -6px -6px 6px; background: #333333; z-index: -1; content: ''; }
       .annotation :link, .annotation :visited { color: inherit; }
       .annotation :link:hover, .annotation :visited:hover { background: transparent; }
       .annotation span { border: none ! important; }
       .note { border-left-style: solid; border-left-width: 0.25em; background: none repeat scroll 0 0 #E9FBE9; border-color: #52E052; }
       .warning { background-color: #F9F0D4; border: medium double #FF0000; margin: 1em; padding: 1em; }
       .note em, .warning em, .note i, .warning i { font-style: normal; }
       p.note, div.note { padding: 0.5em 2em; }
       span.note { padding: 0 2em; }
       .note p:first-child, .warning p:first-child { margin-top: 0; }
       .note p:last-child, .warning p:last-child { margin-bottom: 0; }
       .warning:before { font-style: normal; }
       p.note:before { content: 'Note: '; font-weight: bolder;}
       p.warning:before { content: '\26A0 Warning! '; font-weight:bolder;}
       .critical {margin:1em; border:double red; padding:1em; background-color:#F9F0D4;}

       .bookkeeping:before { display: block; content: 'Bookkeeping details'; font-weight: bolder; font-style: italic; }
       .bookkeeping { font-size: 0.8em; margin: 2em 0; }
       .bookkeeping p { margin: 0.5em 2em; display: list-item; list-style: square; }
       .bookkeeping dt { margin: 0.5em 2em 0; }
       .bookkeeping dd { margin: 0 3em 0.5em; }

       h4 { position: relative; z-index: 3; }
       h4 + .element, h4 + div + .element { margin-top: -2.5em; padding-top: 2em; }
       .element {
         background: #F4F4FA;
         color: black;
         margin: 0 0 1em 0.15em;
         padding: 0 1em 0.25em 0.75em;
         border-left: solid #9999FF 0.25em;
         position: relative;
         z-index: 1;
       }
       .element:before {
         position: absolute;
         z-index: 2;
         top: 0;
         left: -1.15em;
         height: 2em;
         width: 0.9em;
         background: #F4F4FA;
         content: ' ';
         border-style: none none solid solid;
         border-color: #9999FF;
         border-width: 0.25em;
       }

       .example { display: block; color: #222222; background: #FCFCFC; border-left-style: solid;border-color:#c0c0c0; border-left-width: 0.25em; margin-left: 1em; padding-left: 1em;padding-bottom: 0.5em;}
       div.example:before { content: 'Code Example: '; font-weight: bolder;}
       td > .example:only-child { margin: 0 0 0 0.1em; }

       ul.domTree, ul.domTree ul { padding: 0 0 0 1em; margin: 0; }
       ul.domTree li { padding: 0; margin: 0; list-style: none; position: relative; }
       ul.domTree li li { list-style: none; }
       ul.domTree li:first-child::before { position: absolute; top: 0; height: 0.6em; left: -0.75em; width: 0.5em; border-style: none none solid solid; content: ''; border-width: 0.1em; }
       ul.domTree li:not(:last-child)::after { position: absolute; top: 0; bottom: -0.6em; left: -0.75em; width: 0.5em; border-style: none none solid solid; content: ''; border-width: 0.1em; }
       ul.domTree span { font-style: italic; font-family: serif; }
       ul.domTree .t1 code { color: purple; font-weight: bold; }
       ul.domTree .t2 { font-style: normal; font-family: monospace; }
       ul.domTree .t2 .name { color: black; font-weight: bold; }
       ul.domTree .t2 .value { color: blue; font-weight: normal; }
       ul.domTree .t3 code, .domTree .t4 code, .domTree .t5 code { color: gray; }
       ul.domTree .t7 code, .domTree .t8 code { color: green; }
       ul.domTree .t10 code { color: teal; }

       body.dfnEnabled dfn { cursor: pointer; }
       .dfnPanel {
         display: inline;
         position: absolute;
         z-index: 10;
         height: auto;
         width: auto;
         padding: 0.5em 0.75em;
         font: small sans-serif, Droid Sans Fallback;
         background: #DDDDDD;
         color: black;
         border: outset 0.2em;
       }
       .dfnPanel * { margin: 0; padding: 0; font: inherit; text-indent: 0; }
       .dfnPanel :link, .dfnPanel :visited { color: black; }
       .dfnPanel p { font-weight: bolder; }
       .dfnPanel * + p { margin-top: 0.25em; }
       .dfnPanel li { list-style-position: inside; }

       #configUI { position: absolute; z-index: 20; top: 10em; right: 1em; width: 11em; font-size: small; }
       #configUI p { margin: 0.5em 0; padding: 0.3em; background: #EEEEEE; color: black; border: inset thin; }
       #configUI p label { display: block; }
       #configUI #updateUI, #configUI .loginUI { text-align: center; }
       #configUI input[type=button] { display: block; margin: auto; }

       fieldset { margin: 1em; padding: 0.5em 1em; }
       fieldset > legend + * { margin-top: 0; }
       fieldset > :last-child { margin-bottom: 0; }
       fieldset p { margin: 0.5em 0; }
       header p.subline {color:#005A9C; font: 140% sans-serif;margin: 0.75em 0;}
       #authorButton {overflow: visible; padding: 0.1em 0.3em; position: fixed; right: 2em; top: 6em; width: auto;}

       @media print {#authorButton { display:none;}}

   .stability {
     position: fixed;
     bottom: 0;
     left: 0; right: 0;
     margin: 0 auto 0 auto;
     width: 50%;
     background: maroon; color: yellow;
     -webkit-border-radius: 1em 1em 0 0;
     -moz-border-radius: 1em 1em 0 0;
     border-radius: 1em 1em 0 0;
     -moz-box-shadow: 0 0 1em #500;
     -webkit-box-shadow: 0 0 1em #500;
     box-shadow: 0 0 1em red;
     padding: 0.5em 1em;
     text-align: center;
   }
   .stability strong {
     display: block;
   }
   .stability input {
     -moz-appearance: none; -webkit-appearance: none; margin: 0; 
     border: 0; padding: 0.25em 0.5em; background: transparent; color: black;
     position: absolute; top: -0.5em; right: 0; font: 1.25em sans-serif; text-align: center;
   }
   .stability input:hover {
     color: white;
     text-shadow: 0 0 2px black;
   }
   .stability input:active {
     padding: 0.3em 0.45em 0.2em 0.55em;
   }
   .stability :link, .stability :visited,
   .stability :link:hover, .stability :visited:hover {
     background: transparent;
     color: white;
   }

  </style><!-- style switcher script by Stommepoes  --><link href="http://www.w3.org/StyleSheets/TR/W3C-REC" rel="stylesheet" type="text/css"><link href="switcher/author-view.css" id="author-view" rel="alternate stylesheet" title="Author documentation only"><script src="switcher/authorstylesheet.js"></script><link href="editing.html" rel="prev" title="7 User interaction">
  <link href="Overview.html#contents" rel="contents" title="目次">
  <link href="the-xhtml-syntax.html" rel="next" title="9 The XHTML syntax">
  <body class="split chapter" onload="fixBrokenLink();"><div class="head" id="head">
<header><span id="styleSwitch"></span>
   <p><a href="http://www.w3.org/"><img alt="W3C" height="48" src="http://www.w3.org/Icons/w3c_home" width="72"></a></p>

    <h1 id="big-title">HTML5日本語訳</h1>
    <p class="no-num no-toc subline">HTMLとXHTMLのための語彙と関連API</p>
   <h2 class="no-num no-toc" id="w3c-recommendation-28-october-2014">W3C Recommendation 28 October 2014</h2>
   </header></div>
  

  <nav class="prev_next">
   <a href="editing.html">← 7 ユーザーとの対話処理</a> – <a href="Overview.html#contents">目次</a> – <a href="the-xhtml-syntax.html">9 XHTML構文 →</a>
  <ol class="toc"><li><a href="syntax.html#syntax"><span class="secno">8</span> HTML構文</a>
  <ol><li><a href="syntax.html#writing"><span class="secno">8.1</span> HTML文書を記述する</a>
    <ol><li><a href="syntax.html#the-doctype"><span class="secno">8.1.1</span> DOCTYPE</a></li><li><a href="syntax.html#elements-0"><span class="secno">8.1.2</span> 要素</a>
      <ol><li><a href="syntax.html#start-tags"><span class="secno">8.1.2.1</span> 開始タグ</a></li><li><a href="syntax.html#end-tags"><span class="secno">8.1.2.2</span> 終了タグ</a></li><li><a href="syntax.html#attributes-0"><span class="secno">8.1.2.3</span> 属性</a></li><li><a href="syntax.html#optional-tags"><span class="secno">8.1.2.4</span> 任意のタグ</a></li><li><a href="syntax.html#element-restrictions"><span class="secno">8.1.2.5</span> コンテンツモデルの制約</a></li><li><a href="syntax.html#cdata-rcdata-restrictions"><span class="secno">8.1.2.6</span> 生テキストおよびエスケープ可能な生テキスト要素のコンテンツの制約</a></li></ol></li><li><a href="syntax.html#text"><span class="secno">8.1.3</span> テキスト</a>
      <ol><li><a href="syntax.html#newlines"><span class="secno">8.1.3.1</span> 改行</a></li></ol></li><li><a href="syntax.html#character-references"><span class="secno">8.1.4</span> 文字参照</a></li><li><a href="syntax.html#cdata-sections"><span class="secno">8.1.5</span> CDATAセクション</a></li><li><a href="syntax.html#comments"><span class="secno">8.1.6</span> コメント</a></li></ol></li><li><a href="syntax.html#parsing"><span class="secno">8.2 </span>Parsing HTML documents</a>
    <ol><li><a href="syntax.html#overview-of-the-parsing-model"><span class="secno">8.2.1 </span>Overview of the parsing model</a></li><li><a href="syntax.html#the-input-byte-stream"><span class="secno">8.2.2 </span>The input byte stream</a>
      <ol><li><a href="syntax.html#parsing-with-a-known-character-encoding"><span class="secno">8.2.2.1 </span>Parsing with a known character encoding</a></li><li><a href="syntax.html#determining-the-character-encoding"><span class="secno">8.2.2.2 </span>Determining the character encoding</a></li><li><a href="syntax.html#character-encodings"><span class="secno">8.2.2.3 </span>Character encodings</a></li><li><a href="syntax.html#changing-the-encoding-while-parsing"><span class="secno">8.2.2.4 </span>Changing the encoding while parsing</a></li><li><a href="syntax.html#preprocessing-the-input-stream"><span class="secno">8.2.2.5 </span>Preprocessing the input stream</a></li></ol></li><li><a href="syntax.html#parse-state"><span class="secno">8.2.3 </span>Parse state</a>
      <ol><li><a href="syntax.html#the-insertion-mode"><span class="secno">8.2.3.1 </span>The insertion mode</a></li><li><a href="syntax.html#the-stack-of-open-elements"><span class="secno">8.2.3.2 </span>The stack of open elements</a></li><li><a href="syntax.html#the-list-of-active-formatting-elements"><span class="secno">8.2.3.3 </span>The list of active formatting elements</a></li><li><a href="syntax.html#the-element-pointers"><span class="secno">8.2.3.4 </span>The element pointers</a></li><li><a href="syntax.html#other-parsing-state-flags"><span class="secno">8.2.3.5 </span>Other parsing state flags</a></li></ol></li><li><a href="syntax.html#tokenization"><span class="secno">8.2.4 </span>Tokenization</a>
      <ol><li><a href="syntax.html#data-state"><span class="secno">8.2.4.1 </span>Data state</a></li><li><a href="syntax.html#character-reference-in-data-state"><span class="secno">8.2.4.2 </span>Character reference in data state</a></li><li><a href="syntax.html#rcdata-state"><span class="secno">8.2.4.3 </span>RCDATA state</a></li><li><a href="syntax.html#character-reference-in-rcdata-state"><span class="secno">8.2.4.4 </span>Character reference in RCDATA state</a></li><li><a href="syntax.html#rawtext-state"><span class="secno">8.2.4.5 </span>RAWTEXT state</a></li><li><a href="syntax.html#script-data-state"><span class="secno">8.2.4.6 </span>Script data state</a></li><li><a href="syntax.html#plaintext-state"><span class="secno">8.2.4.7 </span>PLAINTEXT state</a></li><li><a href="syntax.html#tag-open-state"><span class="secno">8.2.4.8 </span>Tag open state</a></li><li><a href="syntax.html#end-tag-open-state"><span class="secno">8.2.4.9 </span>End tag open state</a></li><li><a href="syntax.html#tag-name-state"><span class="secno">8.2.4.10 </span>Tag name state</a></li><li><a href="syntax.html#rcdata-less-than-sign-state"><span class="secno">8.2.4.11 </span>RCDATA less-than sign state</a></li><li><a href="syntax.html#rcdata-end-tag-open-state"><span class="secno">8.2.4.12 </span>RCDATA end tag open state</a></li><li><a href="syntax.html#rcdata-end-tag-name-state"><span class="secno">8.2.4.13 </span>RCDATA end tag name state</a></li><li><a href="syntax.html#rawtext-less-than-sign-state"><span class="secno">8.2.4.14 </span>RAWTEXT less-than sign state</a></li><li><a href="syntax.html#rawtext-end-tag-open-state"><span class="secno">8.2.4.15 </span>RAWTEXT end tag open state</a></li><li><a href="syntax.html#rawtext-end-tag-name-state"><span class="secno">8.2.4.16 </span>RAWTEXT end tag name state</a></li><li><a href="syntax.html#script-data-less-than-sign-state"><span class="secno">8.2.4.17 </span>Script data less-than sign state</a></li><li><a href="syntax.html#script-data-end-tag-open-state"><span class="secno">8.2.4.18 </span>Script data end tag open state</a></li><li><a href="syntax.html#script-data-end-tag-name-state"><span class="secno">8.2.4.19 </span>Script data end tag name state</a></li><li><a href="syntax.html#script-data-escape-start-state"><span class="secno">8.2.4.20 </span>Script data escape start state</a></li><li><a href="syntax.html#script-data-escape-start-dash-state"><span class="secno">8.2.4.21 </span>Script data escape start dash state</a></li><li><a href="syntax.html#script-data-escaped-state"><span class="secno">8.2.4.22 </span>Script data escaped state</a></li><li><a href="syntax.html#script-data-escaped-dash-state"><span class="secno">8.2.4.23 </span>Script data escaped dash state</a></li><li><a href="syntax.html#script-data-escaped-dash-dash-state"><span class="secno">8.2.4.24 </span>Script data escaped dash dash state</a></li><li><a href="syntax.html#script-data-escaped-less-than-sign-state"><span class="secno">8.2.4.25 </span>Script data escaped less-than sign state</a></li><li><a href="syntax.html#script-data-escaped-end-tag-open-state"><span class="secno">8.2.4.26 </span>Script data escaped end tag open state</a></li><li><a href="syntax.html#script-data-escaped-end-tag-name-state"><span class="secno">8.2.4.27 </span>Script data escaped end tag name state</a></li><li><a href="syntax.html#script-data-double-escape-start-state"><span class="secno">8.2.4.28 </span>Script data double escape start state</a></li><li><a href="syntax.html#script-data-double-escaped-state"><span class="secno">8.2.4.29 </span>Script data double escaped state</a></li><li><a href="syntax.html#script-data-double-escaped-dash-state"><span class="secno">8.2.4.30 </span>Script data double escaped dash state</a></li><li><a href="syntax.html#script-data-double-escaped-dash-dash-state"><span class="secno">8.2.4.31 </span>Script data double escaped dash dash state</a></li><li><a href="syntax.html#script-data-double-escaped-less-than-sign-state"><span class="secno">8.2.4.32 </span>Script data double escaped less-than sign state</a></li><li><a href="syntax.html#script-data-double-escape-end-state"><span class="secno">8.2.4.33 </span>Script data double escape end state</a></li><li><a href="syntax.html#before-attribute-name-state"><span class="secno">8.2.4.34 </span>Before attribute name state</a></li><li><a href="syntax.html#attribute-name-state"><span class="secno">8.2.4.35 </span>Attribute name state</a></li><li><a href="syntax.html#after-attribute-name-state"><span class="secno">8.2.4.36 </span>After attribute name state</a></li><li><a href="syntax.html#before-attribute-value-state"><span class="secno">8.2.4.37 </span>Before attribute value state</a></li><li><a href="syntax.html#attribute-value-(double-quoted)-state"><span class="secno">8.2.4.38 </span>Attribute value (double-quoted) state</a></li><li><a href="syntax.html#attribute-value-(single-quoted)-state"><span class="secno">8.2.4.39 </span>Attribute value (single-quoted) state</a></li><li><a href="syntax.html#attribute-value-(unquoted)-state"><span class="secno">8.2.4.40 </span>Attribute value (unquoted) state</a></li><li><a href="syntax.html#character-reference-in-attribute-value-state"><span class="secno">8.2.4.41 </span>Character reference in attribute value state</a></li><li><a href="syntax.html#after-attribute-value-(quoted)-state"><span class="secno">8.2.4.42 </span>After attribute value (quoted) state</a></li><li><a href="syntax.html#self-closing-start-tag-state"><span class="secno">8.2.4.43 </span>Self-closing start tag state</a></li><li><a href="syntax.html#bogus-comment-state"><span class="secno">8.2.4.44 </span>Bogus comment state</a></li><li><a href="syntax.html#markup-declaration-open-state"><span class="secno">8.2.4.45 </span>Markup declaration open state</a></li><li><a href="syntax.html#comment-start-state"><span class="secno">8.2.4.46 </span>Comment start state</a></li><li><a href="syntax.html#comment-start-dash-state"><span class="secno">8.2.4.47 </span>Comment start dash state</a></li><li><a href="syntax.html#comment-state"><span class="secno">8.2.4.48 </span>Comment state</a></li><li><a href="syntax.html#comment-end-dash-state"><span class="secno">8.2.4.49 </span>Comment end dash state</a></li><li><a href="syntax.html#comment-end-state"><span class="secno">8.2.4.50 </span>Comment end state</a></li><li><a href="syntax.html#comment-end-bang-state"><span class="secno">8.2.4.51 </span>Comment end bang state</a></li><li><a href="syntax.html#doctype-state"><span class="secno">8.2.4.52 </span>DOCTYPE state</a></li><li><a href="syntax.html#before-doctype-name-state"><span class="secno">8.2.4.53 </span>Before DOCTYPE name state</a></li><li><a href="syntax.html#doctype-name-state"><span class="secno">8.2.4.54 </span>DOCTYPE name state</a></li><li><a href="syntax.html#after-doctype-name-state"><span class="secno">8.2.4.55 </span>After DOCTYPE name state</a></li><li><a href="syntax.html#after-doctype-public-keyword-state"><span class="secno">8.2.4.56 </span>After DOCTYPE public keyword state</a></li><li><a href="syntax.html#before-doctype-public-identifier-state"><span class="secno">8.2.4.57 </span>Before DOCTYPE public identifier state</a></li><li><a href="syntax.html#doctype-public-identifier-(double-quoted)-state"><span class="secno">8.2.4.58 </span>DOCTYPE public identifier (double-quoted) state</a></li><li><a href="syntax.html#doctype-public-identifier-(single-quoted)-state"><span class="secno">8.2.4.59 </span>DOCTYPE public identifier (single-quoted) state</a></li><li><a href="syntax.html#after-doctype-public-identifier-state"><span class="secno">8.2.4.60 </span>After DOCTYPE public identifier state</a></li><li><a href="syntax.html#between-doctype-public-and-system-identifiers-state"><span class="secno">8.2.4.61 </span>Between DOCTYPE public and system identifiers state</a></li><li><a href="syntax.html#after-doctype-system-keyword-state"><span class="secno">8.2.4.62 </span>After DOCTYPE system keyword state</a></li><li><a href="syntax.html#before-doctype-system-identifier-state"><span class="secno">8.2.4.63 </span>Before DOCTYPE system identifier state</a></li><li><a href="syntax.html#doctype-system-identifier-(double-quoted)-state"><span class="secno">8.2.4.64 </span>DOCTYPE system identifier (double-quoted) state</a></li><li><a href="syntax.html#doctype-system-identifier-(single-quoted)-state"><span class="secno">8.2.4.65 </span>DOCTYPE system identifier (single-quoted) state</a></li><li><a href="syntax.html#after-doctype-system-identifier-state"><span class="secno">8.2.4.66 </span>After DOCTYPE system identifier state</a></li><li><a href="syntax.html#bogus-doctype-state"><span class="secno">8.2.4.67 </span>Bogus DOCTYPE state</a></li><li><a href="syntax.html#cdata-section-state"><span class="secno">8.2.4.68 </span>CDATA section state</a></li><li><a href="syntax.html#tokenizing-character-references"><span class="secno">8.2.4.69 </span>Tokenizing character references</a></li></ol></li><li><a href="syntax.html#tree-construction"><span class="secno">8.2.5 </span>Tree construction</a>
      <ol><li><a href="syntax.html#creating-and-inserting-nodes"><span class="secno">8.2.5.1 </span>Creating and inserting nodes</a></li><li><a href="syntax.html#parsing-elements-that-contain-only-text"><span class="secno">8.2.5.2 </span>Parsing elements that contain only text</a></li><li><a href="syntax.html#closing-elements-that-have-implied-end-tags"><span class="secno">8.2.5.3 </span>Closing elements that have implied end tags</a></li><li><a href="syntax.html#parsing-main-inhtml"><span class="secno">8.2.5.4 </span>The rules for parsing tokens in HTML content</a>
        <ol><li><a href="syntax.html#the-initial-insertion-mode"><span class="secno">8.2.5.4.1 </span>The "initial" insertion mode</a></li><li><a href="syntax.html#the-before-html-insertion-mode"><span class="secno">8.2.5.4.2 </span>The "before html" insertion mode</a></li><li><a href="syntax.html#the-before-head-insertion-mode"><span class="secno">8.2.5.4.3 </span>The "before head" insertion mode</a></li><li><a href="syntax.html#parsing-main-inhead"><span class="secno">8.2.5.4.4 </span>The "in head" insertion mode</a></li><li><a href="syntax.html#parsing-main-inheadnoscript"><span class="secno">8.2.5.4.5 </span>The "in head noscript" insertion mode</a></li><li><a href="syntax.html#the-after-head-insertion-mode"><span class="secno">8.2.5.4.6 </span>The "after head" insertion mode</a></li><li><a href="syntax.html#parsing-main-inbody"><span class="secno">8.2.5.4.7 </span>The "in body" insertion mode</a></li><li><a href="syntax.html#parsing-main-incdata"><span class="secno">8.2.5.4.8 </span>The "text" insertion mode</a></li><li><a href="syntax.html#parsing-main-intable"><span class="secno">8.2.5.4.9 </span>The "in table" insertion mode</a></li><li><a href="syntax.html#parsing-main-intabletext"><span class="secno">8.2.5.4.10 </span>The "in table text" insertion mode</a></li><li><a href="syntax.html#parsing-main-incaption"><span class="secno">8.2.5.4.11 </span>The "in caption" insertion mode</a></li><li><a href="syntax.html#parsing-main-incolgroup"><span class="secno">8.2.5.4.12 </span>The "in column group" insertion mode</a></li><li><a href="syntax.html#parsing-main-intbody"><span class="secno">8.2.5.4.13 </span>The "in table body" insertion mode</a></li><li><a href="syntax.html#parsing-main-intr"><span class="secno">8.2.5.4.14 </span>The "in row" insertion mode</a></li><li><a href="syntax.html#parsing-main-intd"><span class="secno">8.2.5.4.15 </span>The "in cell" insertion mode</a></li><li><a href="syntax.html#parsing-main-inselect"><span class="secno">8.2.5.4.16 </span>The "in select" insertion mode</a></li><li><a href="syntax.html#parsing-main-inselectintable"><span class="secno">8.2.5.4.17 </span>The "in select in table" insertion mode</a></li><li><a href="syntax.html#parsing-main-intemplate"><span class="secno">8.2.5.4.18 </span>The "in template" insertion mode</a></li><li><a href="syntax.html#parsing-main-afterbody"><span class="secno">8.2.5.4.19 </span>The "after body" insertion mode</a></li><li><a href="syntax.html#parsing-main-inframeset"><span class="secno">8.2.5.4.20 </span>The "in frameset" insertion mode</a></li><li><a href="syntax.html#parsing-main-afterframeset"><span class="secno">8.2.5.4.21 </span>The "after frameset" insertion mode</a></li><li><a href="syntax.html#the-after-after-body-insertion-mode"><span class="secno">8.2.5.4.22 </span>The "after after body" insertion mode</a></li><li><a href="syntax.html#the-after-after-frameset-insertion-mode"><span class="secno">8.2.5.4.23 </span>The "after after frameset" insertion mode</a></li></ol></li><li><a href="syntax.html#parsing-main-inforeign"><span class="secno">8.2.5.5 </span>The rules for parsing tokens in foreign content</a></li></ol></li><li><a href="syntax.html#the-end"><span class="secno">8.2.6 </span>The end</a></li><li><a href="syntax.html#coercing-an-html-dom-into-an-infoset"><span class="secno">8.2.7 </span>Coercing an HTML DOM into an infoset</a></li><li><a href="syntax.html#an-introduction-to-error-handling-and-strange-cases-in-the-parser"><span class="secno">8.2.8 </span>An introduction to error handling and strange cases in the parser</a>
      <ol><li><a href="syntax.html#misnested-tags:-b-i-/b-/i"><span class="secno">8.2.8.1 </span>Misnested tags: &lt;b&gt;&lt;i&gt;&lt;/b&gt;&lt;/i&gt;</a></li><li><a href="syntax.html#misnested-tags:-b-p-/b-/p"><span class="secno">8.2.8.2 </span>Misnested tags: &lt;b&gt;&lt;p&gt;&lt;/b&gt;&lt;/p&gt;</a></li><li><a href="syntax.html#unexpected-markup-in-tables"><span class="secno">8.2.8.3 </span>Unexpected markup in tables</a></li><li><a href="syntax.html#scripts-that-modify-the-page-as-it-is-being-parsed"><span class="secno">8.2.8.4 </span>Scripts that modify the page as it is being parsed</a></li><li><a href="syntax.html#the-execution-of-scripts-that-are-moving-across-multiple-documents"><span class="secno">8.2.8.5 </span>The execution of scripts that are moving across multiple documents</a></li><li><a href="syntax.html#unclosed-formatting-elements"><span class="secno">8.2.8.6 </span>Unclosed formatting elements</a></li></ol></li></ol></li><li><a href="syntax.html#serializing-html-fragments"><span class="secno">8.3 </span>Serializing HTML fragments</a></li><li><a href="syntax.html#parsing-html-fragments"><span class="secno">8.4 </span>Parsing HTML fragments</a></li><li><a href="syntax.html#named-character-references"><span class="secno">8.5 </span>Named character references</a></li></ol></li></ol></nav>

  <h2 id="syntax"><span class="secno">8</span> <dfn>HTML構文</dfn></h2>

  <p class="note">このセクションは、<a href="infrastructure.html#html-mime-type">HTML MIMEタイプ</a>で標識されたリソースのための規則のみを説明する。XMLリソースのための規則は、"<a href="the-xhtml-syntax.html#the-xhtml-syntax">XHTML構文</a>"と題する以降のセクションで説明する。</p>


  <h3 id="writing"><span class="secno">8.1</span> HTML文書を記述する</h3>

  <div class="impl">

  <p><i>This section only applies to documents, authoring tools, and markup generators. In
  particular, it does not apply to conformance checkers; conformance checkers must use the
  requirements given in the next section ("parsing HTML documents").</i></p>

  </div>

  <p>指定された順序で、文書は以下のパーツから構成されなければならない。</p>

  <ol><li>任意で、単一の"BOM"（U+FEFF）文字。</li>

   <li>任意の数の<a data-anolis-xref="syntax-comments" href="#syntax-comments">コメント</a>および<a data-anolis-xref="space
   character" href="infrastructure.html#space-character">空白文字</a>。</li>

   <li><a data-anolis-xref="syntax-doctype" href="#syntax-doctype">DOCTYPE</a>。

   </li><li>任意の数の<a data-anolis-xref="syntax-comments" href="#syntax-comments">コメント</a>および<a data-anolis-xref="space
   character" href="infrastructure.html#space-character">空白文字</a>。</li>

   <li><code><a href="semantics.html#the-html-element">html</a></code><a data-anolis-xref="syntax-elements" href="#syntax-elements">要素</a>の形式で、ルート要素。</li>

   <li>任意の数の<a data-anolis-xref="syntax-comments" href="#syntax-comments">コメント</a>および<a data-anolis-xref="space
   character" href="infrastructure.html#space-character">空白文字</a>。</li>

  </ol><p>上記のさまざまな種類のコンテンツは、以下の数セクションで説明される。</p>

  <p>また、そのトピックのセクションで説明したように、<a data-anolis-xref="character encoding
  declaration" href="document-metadata.html#character-encoding-declaration">文字エンコーディング宣言</a>がシリアライズされる方法にはいくつかの制限がある。</p>

  <div class="note">

   <p>文書が解析される際に、ルート<code><a href="semantics.html#the-html-element">html</a></code>要素の前の空白文字、<code><a href="semantics.html#the-html-element">html</a></code>要素の冒頭の空白文字、および<code><a href="document-metadata.html#the-head-element">head</a></code>要素の前の空白文字は、落とされる。あたかも空白文字が<code><a href="sections.html#the-body-element">body</a></code>要素の最後であるかのように、ルート<code><a href="semantics.html#the-html-element">html</a></code>要素の<em>後</em>の空白文字は解析される。したがって、ルート要素の周りの空白文字は、往復しない。</p>

   <p>これは、改行がDOCTYPEの後、ルート要素の前にある任意のコメントの後、（<a data-anolis-xref="syntax-tag-omission" href="#syntax-tag-omission">省略</a>されていない場合）<code><a href="semantics.html#the-html-element">html</a></code>要素の開始タグの後、および<code><a href="document-metadata.html#the-head-element">head</a></code>要素の前を除く<code><a href="semantics.html#the-html-element">html</a></code>要素の内部にある任意のコメントの後に挿入されることが示唆される。</p>

  </div>

  <p>HTML構文において、多くの文字列（たとえば要素名とその属性名など）は大文字・小文字不区別であるが、<a href="infrastructure.html#uppercase-ascii-letters">大文字ASCII文字</a>と<a href="infrastructure.html#lowercase-ascii-letters">小文字ASCII文字</a>に対してのみである。便宜上、このセクションにおいて、これは単に"大文字・小文字不区別"とも呼ばれる。</p>


  <h4 id="the-doctype"><span class="secno">8.1.1</span> DOCTYPE</h4>

  <p><dfn data-anolis-xref="syntax-doctype" id="syntax-doctype">DOCTYPE</dfn>は必須のプリアンブルである。</p>

  <p class="note">DOCTYPEは時代に合わなくなった理由のために必要である。省略した場合、ブラウザは一部の仕様と互換性のない異なるレンダリングモードを使用する傾向がある。文書内でDOCTYPEを含めることは、ブラウザが以下の関連仕様でベストエフォートな試みをすることを保証する。</p>

  <p>次の順序で、DOCTYPEは以下のコンポーネントで構成されなければならない：</p>

  <ol class="brief"><li>"<code data-anolis-xref="">&lt;!DOCTYPE</code>"に一致する<a href="infrastructure.html#ascii-case-insensitive">ASCII大文字・小文字不区別</a>の文字列。</li>
   <li>1つ以上の<a data-anolis-xref="space character" href="infrastructure.html#space-character">空白文字</a>。</li>
   <li>"<code data-anolis-xref="">html</code>"に一致する<a href="infrastructure.html#ascii-case-insensitive">ASCII大文字・小文字不区別</a>の文字列。</li>
   <li>任意で、<a href="#doctype-legacy-string">DOCTYPEレガシー文字列</a>または<a href="#obsolete-permitted-doctype-string">旧式の許可されたDOCTYPE文字列</a>（以下に定義）。</li>
   <li>0個以上の<a data-anolis-xref="space character" href="infrastructure.html#space-character">空白文字</a>。</li>
   <li>"&gt;"（U+003E）文字。</li>
  </ol><p class="note">言い換えると、大文字・小文字不区別で<code>&lt;!DOCTYPE html&gt;</code>。</p>

  <hr><p>短いDOCTYPE"<code data-anolis-xref="">&lt;!DOCTYPE html&gt;</code>"でHTMLマークアップを出力できないHTMLの出力器の目的に対して、<dfn id="doctype-legacy-string">DOCTYPEレガシー文字列</dfn>は（上記で定義された位置で）DOCTYPEに挿入してもよい。この文字列は以下で構成されなければならない：</p>

  <ol class="brief"><li>1つ以上の<a data-anolis-xref="space character" href="infrastructure.html#space-character">空白文字</a>。</li>
   <li>"<code data-anolis-xref="">SYSTEM</code>"に一致する<a href="infrastructure.html#ascii-case-insensitive">ASCII大文字・小文字不区別</a>の文字列。</li>
   <li>1つ以上の<a data-anolis-xref="space character" href="infrastructure.html#space-character">空白文字</a>。</li>
   <li>U+0022 QUOTATION MARKまたはU+0027 APOSTROPHE文字（<i>引用符</i>）。</li>
   <li>リテラルに文字列"<code><a href="infrastructure.html#about:legacy-compat">about:legacy-compat</a></code>"。</li>
   <li>U+0022 QUOTATION MARKまたはU+0027 APOSTROPHEに一致する文字（すなわち、前のステップで<i>引用符</i>とラベル付けされたものと同じ文字）。</li>
  </ol><p class="note">言い換えると、単一または二重引用符の部分を除いて大文字・小文字不区別で、<code>&lt;!DOCTYPE html SYSTEM "about:legacy-compat"&gt;</code>または<code>&lt;!DOCTYPE html SYSTEM 'about:legacy-compat'&gt;</code>。</p>

  <p>文書が短い文字列を出力できないシステムから生成されない限り、<a href="#doctype-legacy-string">DOCTYPEレガシー文字列</a>は使用すべきではない。</p>

  <hr><!-- see the parser section before changing this bit --><p>HTML4やXHTML1から著者の移行を支援するために、<dfn id="obsolete-permitted-doctype-string">旧式の許可されたDOCTYPE文字列</dfn>は、（上で定義した位置で）DOCTYPEに挿入できる。この文字列は以下で構成されなければならない：</p>

  <ol class="brief"><li>1つ以上の<a data-anolis-xref="space character" href="infrastructure.html#space-character">空白文字</a>。</li>
   <li>"<code data-anolis-xref="">PUBLIC</code>"に一致する<a href="infrastructure.html#ascii-case-insensitive">ASCII大文字・小文字不区別</a>の文字列。</li>
   <li>1つ以上の<a data-anolis-xref="space character" href="infrastructure.html#space-character">空白文字</a>。</li>
   <li>A U+0022 QUOTATION MARKまたはU+0027 APOSTROPHE文字（<i>1つ目の引用符</i>）。</li>
   <li>下記表の最初の列でセルのいずれかの文字列。このセルが属する行が<i>選択された行</i>である。</li>
   <li>U+0022 QUOTATION MARKまたはU+0027 APOSTROPHEに一致する文字（すなわち、前のステップで<i>1つ目の引用符</i>とラベル付けされたものと同じ文字）。</li>
      <li>システム識別子が使用される場合、 
      <ol><li>1つ以上の<a data-anolis-xref="space character" href="infrastructure.html#space-character">空白文字</a>。</li>
        <li>A U+0022 QUOTATION MARKまたはU+0027 APOSTROPHE文字（<i>3つ目の引用符</i>）。</li>
        <li><i>選択された行</i>の2列目でセルからの文字列。</li>
        <li>U+0022 QUOTATION MARKまたはU+0027 APOSTROPHEに一致する文字（すなわち、前のステップで<i>3つ目の引用符</i>とラベル付けされたものと同じ文字）。</li>
      </ol></li>
      </ol><table><caption>
    <a href="#obsolete-permitted-doctype-string">旧式の許可されたDOCTYPE文字列</a>で公開識別子およびシステム識別子に対する許容値。
   </caption>
   <thead><tr><th> 公開識別子
     </th><th> システム識別子 
     </th><th> システム識別子が任意か？
   <tbody></th></tr><tr><td> <code data-anolis-xref="">-//W3C//DTD&nbsp;HTML&nbsp;4.0//EN</code>
     </td><td> <code data-anolis-xref="">http://www.w3.org/TR/REC-html40/strict.dtd</code>
     </td><td>  Yes
    
    </td></tr><tr><td> <code data-anolis-xref="">-//W3C//DTD&nbsp;HTML&nbsp;4.01//EN</code>
     </td><td> <code data-anolis-xref="">http://www.w3.org/TR/html4/strict.dtd</code>
     </td><td>  Yes
    
    </td></tr><tr><td> <code data-anolis-xref="">-//W3C//DTD&nbsp;XHTML&nbsp;1.0&nbsp;Strict//EN</code>
     </td><td> <code data-anolis-xref="">http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd</code>
     </td><td>  No
    
    </td></tr><tr><td> <code data-anolis-xref="">-//W3C//DTD&nbsp;XHTML&nbsp;1.1//EN</code>
     </td><td> <code data-anolis-xref="">http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd</code>
     </td><td>  No
  
  </td></tr></table><p class="auth"><a href="#obsolete-permitted-doctype-string">旧式の許可されたDOCTYPE文字列</a>を含む<a data-anolis-xref="syntax-doctype" href="#syntax-doctype">DOCTYPE</a>は<dfn id="obsolete-permitted-doctype">旧式の許可されたDOCTYPE</dfn>である。不必要に長くなるので、著者は<a data-anolis-xref="obsolete permitted DOCTYPE" href="#obsolete-permitted-doctype">旧式の許可されたDOCTYPE</a>を使うべきでない。</p>



  <h4 id="elements-0"><span class="secno">8.1.2</span> 要素</h4>

  <p>5つの異なる種類の<dfn data-anolis-xref="syntax-elements" id="syntax-elements">要素</dfn>が存在する。<a href="#void-elements">空要素</a>、<a href="#raw-text-elements">生テキスト要素</a>、<a href="#escapable-raw-text-elements">エスケープ可能な生テキスト要素</a>、<a href="#foreign-elements">外来要素</a>、<a href="#normal-elements">通常要素</a>。</p>

  <dl><dt><dfn id="void-elements">空要素</dfn></dt>

   <dd><code><a href="embedded-content-0.html#the-area-element">area</a></code>、<code><a href="document-metadata.html#the-base-element">base</a></code>、<code><a href="text-level-semantics.html#the-br-element">br</a></code>、<code><a href="tabular-data.html#the-col-element">col</a></code>、<code><a href="embedded-content-0.html#the-embed-element">embed</a></code>、<code><a href="grouping-content.html#the-hr-element">hr</a></code>、<code><a href="embedded-content-0.html#the-img-element">img</a></code>、<code><a href="forms.html#the-input-element">input</a></code>、<code><a href="forms.html#the-keygen-element">keygen</a></code>、<code><a href="document-metadata.html#the-link-element">link</a></code>、<code><a href="document-metadata.html#the-meta-element">meta</a></code>、<code><a href="embedded-content-0.html#the-param-element">param</a></code>、<code><a href="embedded-content-0.html#the-source-element">source</a></code>、<code><a href="embedded-content-0.html#the-track-element">track</a></code>、<code><a href="text-level-semantics.html#the-wbr-element">wbr</a></code></dd><!-- see also other places that say VOIDLIST -->
   

   <dt><dfn id="raw-text-elements">生テキスト要素</dfn></dt>

   <dd><code><a href="scripting-1.html#the-script-element">script</a></code>、<code><a href="document-metadata.html#the-style-element">style</a></code></dd><!-- iframe and noscript don't count as raw text
   for syntax purposes --> 

   <dt><dfn id="escapable-raw-text-elements">エスケープ可能な生テキスト要素</dfn></dt>

   <dd><code><a href="forms.html#the-textarea-element">textarea</a></code>、<code><a href="document-metadata.html#the-title-element">title</a></code></dd>

   <dt><dfn id="foreign-elements">外来要素</dfn></dt>

   <dd><a href="infrastructure.html#mathml-namespace">MathML名前空間</a>および<a href="infrastructure.html#svg-namespace">SVG名前空間</a>由来の要素。</dd>

   <dt><dfn id="normal-elements">通常要素</dfn></dt>

   <dd>他の許容されるすべての<a href="infrastructure.html#html-elements">HTML要素</a>が通常要素である。</dd>

  </dl><p><dfn data-anolis-xref="syntax-tags" id="syntax-tags">タグ</dfn>は、マークアップで要素の開始と終了を区切るために使用される。<a data-anolis-xref="raw text elements" href="#raw-text-elements">生テキスト</a>、<a data-anolis-xref="escapable raw text
  elements" href="#escapable-raw-text-elements">エスケープ可能な生テキスト</a>、および<a data-anolis-xref="normal elements" href="#normal-elements">通常</a>要素は、開始する場所を示すための<a data-anolis-xref="syntax-start-tag" href="#syntax-start-tag">開始タグ</a>を持ち、終了する場所を示すための<a data-anolis-xref="syntax-end-tag" href="#syntax-end-tag">終了タグ</a>を持つ。<a data-anolis-xref="syntax-tag-omission" href="#syntax-tag-omission">任意タグ</a>のセクションで後述するように、特定の<a href="#normal-elements">通常要素</a>の開始タグおよび終了タグは<a data-anolis-xref="syntax-tag-omission" href="#syntax-tag-omission">省略</a>できる。省略できないものは省略してはならない。<a href="#void-elements">空要素</a>は開始タグのみを持つ。<a href="#void-elements">空要素</a>に対して終了タグは指定してはならない。<a href="#foreign-elements">外来要素</a>は、開始タグと終了タグを持つ、または終了タグを持ってはならない場合、自己終了としてマークされる開始タグのいずれかを持たなければならない。</p>

  <p>要素の<a data-anolis-xref="concept-html-contents" href="dom.html#concept-html-contents">コンテンツ</a>は、開始タグ（<a data-anolis-xref="syntax-tag-omission" href="#syntax-tag-omission">特定の場合に暗示されるかもしれない</a>）のちょうど後、終了タグ（再び、<a data-anolis-xref="syntax-tag-omission" href="#syntax-tag-omission">特定の場合に暗示されるかもしれない</a>）のちょうど前の間に配置されなければならない。この仕様で以前に説明したように、個々の要素の正確な許可されるコンテンツは、その要素の<a data-anolis-xref="content models" href="dom.html#content-models">コンテンツモデル</a>によって異なる。要素は、そのコンテンツモデルが禁止するコンテンツを含めてはならない。また一方、これらコンテンツモデルによってコンテンツに設定される制限に加えて、要素に5種類の追加の<em>構文</em>要件がある。</p>

  <p><a href="#void-elements">空要素</a>は、任意のコンテンツを持つことができない（終了タグが存在しないので、コンテンツは開始タグと終了タグの間に置くことができない）。</p>

  <p>後述の<a href="#cdata-rcdata-restrictions">制限</a>があるが、<a href="#raw-text-elements">生テキスト要素</a>は、<a data-anolis-xref="syntax-text" href="#syntax-text">テキスト</a>を持つことができる。</p>

  <p><a href="#escapable-raw-text-elements">エスケープ可能な要素</a>は、<a data-anolis-xref="syntax-text" href="#syntax-text">テキスト</a>および<a data-anolis-xref="syntax-charref" href="#syntax-charref">文字参照</a>を持つことができるが、テキストは<a data-anolis-xref="syntax-ambiguous-ampersand" href="#syntax-ambiguous-ampersand">曖昧なアンパサンド</a>を含めてはならない。後述の<a href="#cdata-rcdata-restrictions">さらなる制限</a>もある。</p>

  <p>開始タグが自己終了としてマークされる<a href="#foreign-elements">外来要素</a>は、任意のコンテンツを持つことはできない（終了タグが存在しないので、コンテンツは開始タグと終了タグの間に置くことができない）。開始タグが自己終了としてマークされ<em>ない</em><a href="#foreign-elements">外来要素</a>は、<a data-anolis-xref="syntax-text" href="#syntax-text">テキスト</a>、<a data-anolis-xref="syntax-charref" href="#syntax-charref">文字参照</a>、<a data-anolis-xref="syntax-cdata" href="#syntax-cdata">CDATAセクション</a>、他の<a data-anolis-xref="syntax-elements" href="#syntax-elements">要素</a>、および<a data-anolis-xref="syntax-comments" href="#syntax-comments">コメント</a>を持つことができるが、テキストは、文字"&lt;"（U+003C）または<a data-anolis-xref="syntax-ambiguous-ampersand" href="#syntax-ambiguous-ampersand">曖昧なアンパサンド</a>を含めてはならない。</p>

  <div class="note">

   <p><a href="#foreign-elements">外来要素</a>であっても、HTML構文は、名前空間宣言をサポートしない。</p>

   <p>たとえば、次のHTMLコードを考えてみる：</p>

   <pre>&lt;p&gt;
 &lt;svg&gt;
  &lt;metadata&gt;
   &lt;!-- this is invalid --&gt;
   &lt;cdr:license xmlns:cdr="http://www.example.com/cdr/metadata" name="MIT"/&gt;
  &lt;/metadata&gt;
 &lt;/svg&gt;
&lt;/p&gt;</pre>

   <p>"<code data-anolis-xref="">xmlns:cdr</code>"属性は効果を持たない（XMLと異なる）ため、内側の要素<code data-anolis-xref="">cdr:license</code>は、実際にはSVG名前空間である。むしろ、上記断片のコメントにあるように、この断片は実際には不適合である。これは、SVG仕様が、SVG名前空間で"<code data-anolis-xref="">cdr:license</code>"と呼ばれる任意の要素を定義しないためである。</p>

  </div>

  <p><a href="#normal-elements">通常要素</a>は、<a data-anolis-xref="syntax-text" href="#syntax-text">テキスト</a>、<a data-anolis-xref="syntax-charref" href="#syntax-charref">文字参照</a>、他の<a data-anolis-xref="syntax-elements" href="#syntax-elements">要素</a>、および<a data-anolis-xref="syntax-comments" href="#syntax-comments">コメント</a>を持つことができるが、テキストは、文字"&lt;"（U+003C）または<a data-anolis-xref="syntax-ambiguous-ampersand" href="#syntax-ambiguous-ampersand">曖昧なアンパサンド</a>を含めてはならない。一部の<a href="#normal-elements">通常要素</a>はまた、コンテンツモデルとこの段落で説明されるものによって課される制限を超えて、保持するために許可されるコンテンツで<a href="#element-restrictions">まだ多くの制限</a>を持つ。これらの制限事項は以下のとおり。</p>

  <p>タグは、要素の名前を与える<dfn data-anolis-xref="syntax-tag-name" id="syntax-tag-name">タグ名</dfn>を含む。HTML要素はすべて、<a href="infrastructure.html#alphanumeric-ascii-characters">英数字ASCII文字</a>を使用する名前のみを持つ。HTML構文において、<a href="#foreign-elements">外来要素</a>に対するものでさえ、タグ名は、すべて小文字に変換する場合に、要素のタグ名に一致する小文字と大文字の任意の組み合わせで書かれてもよい。タグ名は、大文字・小文字不区別である。</p>


  <h5 id="start-tags"><span class="secno">8.1.2.1</span> 開始タグ</h5>

  <p><dfn data-anolis-xref="syntax-start-tag" id="syntax-start-tag">開始タグ</dfn>は、次の形式を持たなければならない：</p>

  <ol><li>開始タグの最初の文字は、"&lt;"文字（U+003C）でなければならない。</li>

   <li>開始タグの次の数文字は、要素の<a data-anolis-xref="syntax-tag-name" href="#syntax-tag-name">タグ名</a>でなければならない。</li>

   <li>次のステップで、任意の属性が存在する場合、最初に1つ以上の<a data-anolis-xref="space character" href="infrastructure.html#space-character">空白文字</a>が存在しなければならない。</li>

   <li>次に、開始タグは、以下で説明される<a data-anolis-xref="syntax-attributes" href="#syntax-attributes">構文</a>を属性の数だけ持ってもよい。属性は、1つ以上の<a data-anolis-xref="space character" href="infrastructure.html#space-character">空白文字</a>で区切らなければならない。</li>

   <li>属性の後に、または属性が存在しない場合<a data-anolis-xref="syntax-tag-name" href="#syntax-tag-name">タグ名</a>の後に、1つ以上の<a data-anolis-xref="space character" href="infrastructure.html#space-character">空白文字</a>があってもよい。（一部の属性は、スペースが続くことが要求される。下記の<a data-anolis-xref="syntax-attributes" href="#syntax-attributes">属性セクション</a>を参照のこと。）</li>

   <li>次に、要素が<a href="#void-elements">空要素</a>のいずれかである、または要素が<a data-anolis-xref="foreign elements" href="#foreign-elements">外来要素</a>である場合、単一の"/"（U+002F）文字があってもよい。この文字は、<a href="#void-elements">空要素</a>に影響しないが、<a href="#foreign-elements">外来要素</a>で自己終了として開始タグをマークする。</li>

   <li>最後に、開始タグは"&gt;"文字（U+003E）で閉じなければならない。</li>

  </ol><h5 id="end-tags"><span class="secno">8.1.2.2</span> 終了タグ</h5>

  <p><dfn data-anolis-xref="syntax-end-tag" id="syntax-end-tag">終了タグ</dfn>は、次の形式を持たなければならない：</p>

  <ol><li>終了タグの最初の文字は、"&lt;"文字（U+003C）でなければならない。</li>

   <li>終了タグの2番目の文字は、"/"（U+002F）文字でなければならない。</li>

   <li>終了タグの次の数文字は、要素の<a data-anolis-xref="syntax-tag-name" href="#syntax-tag-name">タグ名</a>でなければならない。</li>

   <li>タグ名の後に、1つ以上の<a data-anolis-xref="space character" href="infrastructure.html#space-character">空白文字</a>があってもよい。</li>

   <li>最後に、終了タグは"&gt;"文字（U+003E）で閉じなければならない。</li>

  </ol><h5 id="attributes-0"><span class="secno">8.1.2.3</span> 属性</h5>

  <p>要素の<dfn data-anolis-xref="syntax-attributes" id="syntax-attributes">属性</dfn>は要素の開始タグの中で表現される。</p>

  <p>属性は名前および値を持つ。<dfn data-anolis-xref="syntax-attribute-name" id="syntax-attribute-name">属性名</dfn>は、<a data-anolis-xref="space character" href="infrastructure.html#space-character">空白文字</a>、U+0000 NULL、U+0022 QUOTATION MARK（"）、U+0027 APOSTROPHE（'）、"&gt;"（U+003E）、"/"（U+002F）、"="（U+003D）文字、<a href="infrastructure.html#control-characters">制御文字</a>、およびUnicodeで定義されない任意の文字以外で1つ以上の文字で構成されなければならない。HTML構文において、<a href="#foreign-elements">外来要素</a>に対するものでさえ、属性名は、属性名に<a href="infrastructure.html#ascii-case-insensitive">ASCII大文字・小文字不区別</a>でマッチする小文字と大文字の任意の組み合わせで書かれてもよい。</p>

  <p><dfn data-anolis-xref="syntax-attribute-value" id="syntax-attribute-value">属性値</dfn>は、テキストが<a data-anolis-xref="syntax-ambiguous-ampersand" href="#syntax-ambiguous-ampersand">曖昧なアンパサンド</a>を含めることができない追加の制限をもつ場合を除き、<a data-anolis-xref="syntax-text" href="#syntax-text">テキスト</a>および<a data-anolis-xref="syntax-charref" href="#syntax-charref">文字参照</a>の混合物である。</p>

  <p>属性は、4つの異なる方法で指定できる：</p>

  <dl><dt>空属性構文</dt>

   <dd>

    <p>単に<a data-anolis-xref="syntax-attribute-name" href="#syntax-attribute-name">属性名</a>。値は、暗黙的に空文字列である。</p>

    <div class="example">

     <p>次の例において、<code data-anolis-xref="attr-fe-disabled"><a href="forms.html#attr-fe-disabled">disabled</a></code>属性は、空属性構文で与えられる：</p>

     <pre>&lt;input <em>disabled</em>&gt;</pre>

    </div>

    <p>空属性構文を使用する属性が別の属性が続ける場合、2つを分離する<a href="infrastructure.html#space-character">空白文字</a>が存在しなければならない。</p>

   </dd>

   <dt id="unquoted">引用符で囲まれない属性値構文</dt>

   <dd>

    <p>0個以上の<a data-anolis-xref="space character" href="infrastructure.html#space-character">空白文字</a>が続き、1つのU+003D EQUALS SIGN文字が続き、0個以上の<a data-anolis-xref="space character" href="infrastructure.html#space-character">空白文字</a>が続き、属性値に対する上記の要件に加えて<a data-anolis-xref="syntax-attribute-value" href="#syntax-attribute-value">属性値</a>が続く、<a data-anolis-xref="syntax-attribute-name" href="#syntax-attribute-name">属性名</a>は、任意のリテラルに<a data-anolis-xref="space character" href="infrastructure.html#space-character">空白文字</a>、U+0022 QUOTATION MARK文字（"）、 U+0027 APOSTROPHE文字（'）、"="（U+003D）文字、"&lt;"（U+003C）文字、"&gt;"（U+003E）文字、またはU+0060 GRAVE ACCENT（`）文字を含んではならず、かつ空文字列であってはならない。</p><!-- The ` character is in this list on a temporary basis, waiting for IE to fix its parsing bug
         whereby it treats ` as an attribute value delimiter. Otherwise, escaping software that
         tries to be clever and not use quotes when it doesn't need to could be tricked by an
         attacker.

         Posit a site that allows the user to input text that is used verbatim in two attributes,
         such that the user can set the first attribute's value to:

            `

         ...and the second to:

            ` onload='...payload...' end=x

         ...with the assumption that the site is going to not quote the first one, and quote the
         second one with double quotes:

            <body data-x=` class="` onload='...payload...' end=x">

         In IE, this is treated as:

            <body data-x=' class="'
                  onload='...payload...'
                  end='x"'>

    -->

    


    <div class="example">

     <p>次の例において、<code data-anolis-xref="attr-input-value"><a href="forms.html#attr-input-value">value</a></code>属性は、引用符で囲まれない属性値構文で与えられる：</p>

     <pre>&lt;input <em>value=yes</em>&gt;</pre>

    </div>

    <p>引用符で囲まれない属性構文を使用する属性が別の属性に続く、または上記の<a data-anolis-xref="syntax-start-tag" href="#syntax-start-tag">開始タグ</a>構文のステップ6で許可される任意の"/"（U+002F）文字が続く場合、2つを分離する<a href="infrastructure.html#space-character">空白文字</a>が存在しなければならない。</p>

   </dd>

   <dt>単一引用符で囲まれた属性値構文</dt>

   <dd>

    <p>0個以上の<a data-anolis-xref="space character" href="infrastructure.html#space-character">空白文字</a>が続き、1つのU+003D EQUALS SIGN文字が続き、0個以上の<a data-anolis-xref="space character" href="infrastructure.html#space-character">空白文字</a>が続き、1つの"'"（U+0027）文字が続き、<a data-anolis-xref="syntax-attribute-value" href="#syntax-attribute-value">属性値</a>が続く<a data-anolis-xref="syntax-attribute-name" href="#syntax-attribute-name">属性名</a>は、属性値に対する上記の要件に加えて、任意のリテラルに"'"（U+0027）文字を含んではならず、そして最後に2つ目の1つの"'"（U+0027）文字が続く。</p>

    <div class="example">

     <p>次の例において、<code data-anolis-xref="attr-input-type"><a href="forms.html#attr-input-type">type</a></code>属性は、単一引用符で囲まれた属性値構文で与えられる：</p>

     <pre>&lt;input <em>type='checkbox'</em>&gt;</pre>

    </div>

    <p>単一引用符で囲まれた属性値構文を使用する属性が別の属性が続ける場合、2つを分離する<a href="infrastructure.html#space-character">空白文字</a>が存在しなければならない。</p>

   </dd>

   <dt>二重引用符で囲まれた属性値の構文</dt>

   <dd>

    <p>0個以上の<a data-anolis-xref="space character" href="infrastructure.html#space-character">空白文字</a>が続き、1つのU+003D EQUALS SIGN文字が続き、0個以上の<a data-anolis-xref="space character" href="infrastructure.html#space-character">空白文字</a>が続き、1つの"""（U+0022）文字が続き、<a data-anolis-xref="syntax-attribute-value" href="#syntax-attribute-value">属性値</a>が続く<a data-anolis-xref="syntax-attribute-name" href="#syntax-attribute-name">属性名</a>は、属性値に対する上記の要件に加えて、任意のリテラルに"""（U+0022）文字を含んではならず、そして最後に2つ目の1つの"""（U+0022）文字が続く。</p>

    <div class="example">

     <p>次の例において、<code data-anolis-xref="attr-fe-name"><a href="forms.html#attr-fe-name">name</a></code>属性は、二重引用符で囲まれた属性値構文で与えられる：</p>

     <pre>&lt;input <em>name="be evil"</em>&gt;</pre>

    </div>

    <p>二重引用符で囲まれた属性値構文を使用する属性が別の属性が続ける場合、2つを分離する<a href="infrastructure.html#space-character">空白文字</a>が存在しなければならない。</p>

   </dd>

  </dl><p>名前が互いに<a href="infrastructure.html#ascii-case-insensitive">ASCII大文字・小文字不区別</a>でマッチする同じ開始タグで2つ以上の属性があってはならない。</p>

  <hr><p><a data-anolis-xref="foreign elements" href="#foreign-elements">外来要素</a>が以下の表から行の1番目のローカル名および2番目のセルの名前空間によって与えられた名前空間属性のいずれかが含まれる場合、同じ行から3番目のセルで指定した名前を使用して書かれなければならない。</p>

  <table><thead><tr><th> ローカル名 </th><th> 名前空間 </th><th> 属性名
   <tbody></th></tr><tr><td> <code data-anolis-xref="">actuate</code> </td><td> <a href="infrastructure.html#xlink-namespace">XLink名前空間</a> </td><td> <code data-anolis-xref="">xlink:actuate</code>
    </td></tr><tr><td> <code data-anolis-xref="">arcrole</code> </td><td> <a href="infrastructure.html#xlink-namespace">XLink名前空間</a> </td><td> <code data-anolis-xref="">xlink:arcrole</code>
    </td></tr><tr><td> <code data-anolis-xref="">href</code> </td><td> <a href="infrastructure.html#xlink-namespace">XLink名前空間</a> </td><td> <code data-anolis-xref="">xlink:href</code>
    </td></tr><tr><td> <code data-anolis-xref="">role</code> </td><td> <a href="infrastructure.html#xlink-namespace">XLink名前空間</a> </td><td> <code data-anolis-xref="">xlink:role</code>
    </td></tr><tr><td> <code data-anolis-xref="">show</code> </td><td> <a href="infrastructure.html#xlink-namespace">XLink名前空間</a> </td><td> <code data-anolis-xref="">xlink:show</code>
    </td></tr><tr><td> <code data-anolis-xref="">title</code> </td><td> <a href="infrastructure.html#xlink-namespace">XLink名前空間</a> </td><td> <code data-anolis-xref="">xlink:title</code>
    </td></tr><tr><td> <code data-anolis-xref="">type</code> </td><td> <a href="infrastructure.html#xlink-namespace">XLink名前空間</a> </td><td> <code data-anolis-xref="">xlink:type</code>
    </td></tr><tr><td> <code data-anolis-xref="">base</code> </td><td> <a href="infrastructure.html#xml-namespace">XML名前空間</a> <!-- attr-xml-base --> </td><td> <code data-anolis-xref="">xml:base</code>
    </td></tr><tr><td> <code data-anolis-xref="">lang</code> </td><td> <a href="infrastructure.html#xml-namespace">XML名前空間</a> </td><td> <code data-anolis-xref="">xml:lang</code>
    </td></tr><tr><td> <code data-anolis-xref="">space</code> </td><td> <a href="infrastructure.html#xml-namespace">XML名前空間</a> </td><td> <code data-anolis-xref="">xml:space</code>
    </td></tr><tr><td> <code data-anolis-xref="">xmlns</code> </td><td> <a href="infrastructure.html#xmlns-namespace">XMLNS名前空間</a> </td><td> <code data-anolis-xref="">xmlns</code>
    </td></tr><tr><td> <code data-anolis-xref="">xlink</code> </td><td> <a href="infrastructure.html#xmlns-namespace">XMLNS名前空間</a> </td><td> <code data-anolis-xref="">xmlns:xlink</code>
  </td></tr></table><p>それ以外の名前空間つき属性は、<a href="#syntax">HTML構文</a>で表現できない。</p>

  <p class="note">上記の表の属性が適合しているかは、他の仕様（たとえばSVGやMathML仕様など）によって定義される。属性がHTML構文を使用してシリアライズされる場合、このセクションは、構文規則についてのみ説明する。</p>


  <h5 id="optional-tags"><span class="secno">8.1.2.4</span> 任意のタグ</h5>

  <p>一部のタグは<dfn data-anolis-xref="syntax-tag-omission" id="syntax-tag-omission">省略</dfn>できる。</p>

  <p class="note">以下で説明される状況で要素の<a data-anolis-xref="syntax-start-tag" href="#syntax-start-tag">開始タグ</a>を省略することは、要素が存在しないことを意味するものではない。そのように暗示するが、要素は依然としてそこに存在する。たとえば、たとえマークアップのどこにも文字列<code data-anolis-xref="">&lt;html&gt;</code>が出現しない場合でも、HTML文書は常にルート<code><a href="semantics.html#the-html-element">html</a></code>要素を持つ。</p><!-- <html> -->

  
  <p><code><a href="semantics.html#the-html-element">html</a></code>要素内の最初の文が<a data-anolis-xref="syntax-comments" href="#syntax-comments">コメント</a>でない場合、<code><a href="semantics.html#the-html-element">html</a></code>要素の<a data-anolis-xref="syntax-start-tag" href="#syntax-start-tag">開始タグ</a>は省略してもよい。</p><!-- </html> -->

  
  <p><code><a href="semantics.html#the-html-element">html</a></code>要素の直前が<a data-anolis-xref="syntax-comments" href="#syntax-comments">コメント</a>でない場合、<code><a href="semantics.html#the-html-element">html</a></code>要素の<a data-anolis-xref="syntax-end-tag" href="#syntax-end-tag">終了タグ</a>は省略してもよい。</p><!-- <head> -->

  
  <p>要素が空である場合、または<code><a href="document-metadata.html#the-head-element">head</a></code>要素内の最初の文が要素である場合、<code><a href="document-metadata.html#the-head-element">head</a></code>要素の<a data-anolis-xref="syntax-start-tag" href="#syntax-start-tag">開始タグ</a>は省略してもよい。</p><!-- </head> -->

  
  <p><code><a href="document-metadata.html#the-head-element">head</a></code>要素の直前が<a href="infrastructure.html#space-character">空白文字</a>または<a data-anolis-xref="syntax-comments" href="#syntax-comments">コメント</a>でない場合、<code><a href="document-metadata.html#the-head-element">head</a></code>要素の<a data-anolis-xref="syntax-end-tag" href="#syntax-end-tag">終了タグ</a>は省略してもよい。</p><!--CLEANUP--><!-- <body> -->


  
  <p>要素が空である場合、または<code><a href="sections.html#the-body-element">body</a></code>要素内の最初のものが<a href="infrastructure.html#space-character">空白文字</a>または<a data-anolis-xref="syntax-comments" href="#syntax-comments">コメント</a>でない場合、<code><a href="sections.html#the-body-element">body</a></code>要素の<a data-anolis-xref="syntax-start-tag" href="#syntax-start-tag">開始タグ</a>は省略してもよい。ただし、<code><a href="sections.html#the-body-element">body</a></code>要素内の最初のものが<code><a href="document-metadata.html#the-meta-element">meta</a></code>、<code><a href="document-metadata.html#the-link-element">link</a></code>、<code><a href="scripting-1.html#the-script-element">script</a></code>、<code><a href="document-metadata.html#the-style-element">style</a></code>、または<code><a href="scripting-1.html#the-template-element">template</a></code>である場合を除く。 <!-- Note that even if the </head> end tag is present, the parser makes <style> and
  <script> elements between </head> and <body> end up in the <head> instead of implying the <body>
  --></p><!-- </body> -->

  
  <p><code><a href="sections.html#the-body-element">body</a></code>要素の直前が<a data-anolis-xref="syntax-comments" href="#syntax-comments">コメント</a>でない場合、<code><a href="sections.html#the-body-element">body</a></code>要素の<a data-anolis-xref="syntax-end-tag" href="#syntax-end-tag">終了タグ</a>は省略してもよい。</p><!-- </li> -->

  
  <p><code><a href="grouping-content.html#the-li-element">li</a></code>要素が別の<code><a href="grouping-content.html#the-li-element">li</a></code>要素の直前に存在する場合、または親要素に追加のコンテンツが存在しない場合、<code><a href="grouping-content.html#the-li-element">li</a></code>要素の<a data-anolis-xref="syntax-end-tag" href="#syntax-end-tag">終了タグ</a>は省略してもよい。</p><!-- </dt> -->

  
  <p><code><a href="grouping-content.html#the-dt-element">dt</a></code>要素が別の<code><a href="grouping-content.html#the-dt-element">dt</a></code>要素または<code><a href="grouping-content.html#the-dd-element">dd</a></code>要素の直前に存在する場合、<code><a href="grouping-content.html#the-dt-element">dt</a></code>要素の<a data-anolis-xref="syntax-end-tag" href="#syntax-end-tag">終了タグ</a>は省略してもよい。</p><!-- </dd> -->

  
  <p><code><a href="grouping-content.html#the-dd-element">dd</a></code>要素が別の<code><a href="grouping-content.html#the-dd-element">dd</a></code>要素または<code><a href="grouping-content.html#the-dt-element">dt</a></code>要素の直前に存在する場合、または親要素に追加のコンテンツが存在しない場合、<code><a href="grouping-content.html#the-dd-element">dd</a></code>要素の<a data-anolis-xref="syntax-end-tag" href="#syntax-end-tag">終了タグ</a>は省略してもよい。</p><!--CLEANUP--><!-- </p> -->


  
  <p><code><a href="grouping-content.html#the-p-element">p</a></code>要素が<code><a href="sections.html#the-address-element">address</a></code>、<code><a href="sections.html#the-article-element">article</a></code>、<code><a href="sections.html#the-aside-element">aside</a></code>、<code><a href="grouping-content.html#the-blockquote-element">blockquote</a></code>、<code><a href="grouping-content.html#the-div-element">div</a></code>、<code><a href="grouping-content.html#the-dl-element">dl</a></code>、<code><a href="forms.html#the-fieldset-element">fieldset</a></code>、<code><a href="sections.html#the-footer-element">footer</a></code>、<code><a href="forms.html#the-form-element">form</a></code>、<code><a href="sections.html#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements">h1</a></code>、<code><a href="sections.html#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements">h2</a></code>、<code><a href="sections.html#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements">h3</a></code>、<code><a href="sections.html#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements">h4</a></code>、<code><a href="sections.html#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements">h5</a></code>、<code><a href="sections.html#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements">h6</a></code>、<code><a href="sections.html#the-header-element">header</a></code>、<code><a href="obsolete.html#hgroup">hgroup</a></code>、<code><a href="grouping-content.html#the-hr-element">hr</a></code>、<code><a href="grouping-content.html#the-main-element">main</a></code>、<code><a href="sections.html#the-nav-element">nav</a></code>、<code><a href="grouping-content.html#the-ol-element">ol</a></code>、<code><a href="grouping-content.html#the-p-element">p</a></code>、<code><a href="grouping-content.html#the-pre-element">pre</a></code>、<code><a href="sections.html#the-section-element">section</a></code>、<code><a href="tabular-data.html#the-table-element">table</a></code>、または<code><a href="grouping-content.html#the-ul-element">ul</a></code>要素の直前に存在する場合、または親要素で追加のコンテンツが存在せずかつ親要素が<code><a href="text-level-semantics.html#the-a-element">a</a></code>要素でない場合、<code><a href="grouping-content.html#the-p-element">p</a></code>要素の<a data-anolis-xref="syntax-end-tag" href="#syntax-end-tag">終了タグ</a>は省略してもよい。</p><!-- </rb> -->

  
  <p><code><a href="text-level-semantics.html#the-rb-element">rb</a></code>要素が別の<code><a href="text-level-semantics.html#the-rb-element">rb</a></code>、<code><a href="text-level-semantics.html#the-rt-element">rt</a></code>、<code><a href="text-level-semantics.html#the-rtc-element">rtc</a></code>または<code><a href="text-level-semantics.html#the-rp-element">rp</a></code>要素の直前に存在する場合、または親要素に追加のコンテンツが存在しない場合、<code><a href="text-level-semantics.html#the-rb-element">rt</a></code>要素の<a data-anolis-xref="syntax-end-tag" href="#syntax-end-tag">終了タグ</a>は省略してもよい。</p><!-- </rt> -->

  
  <p><code><a href="text-level-semantics.html#the-rt-element">rt</a></code>要素が<code><a href="text-level-semantics.html#the-rb-element">rb</a></code>、<code><a href="text-level-semantics.html#the-rt-element">rt</a></code>、<code><a href="text-level-semantics.html#the-rtc-element">rtc</a></code>または<code><a href="text-level-semantics.html#the-rp-element">rp</a></code>要素の直前に存在する場合、または親要素に追加のコンテンツが存在しない場合、<code><a href="text-level-semantics.html#the-rt-element">rt</a></code>要素の<a data-anolis-xref="syntax-end-tag" href="#syntax-end-tag">終了タグ</a>は省略してもよい。</p><!-- </rtc> -->

  
  <p><code><a href="text-level-semantics.html#the-rtc-element">rtc</a></code>要素が<code><a href="text-level-semantics.html#the-rb-element">rb</a></code>、<code><a href="text-level-semantics.html#the-rtc-element">rtc</a></code>または<code><a href="text-level-semantics.html#the-rp-element">rp</a></code>要素の直前に存在する場合、または親要素に追加のコンテンツが存在しない場合、<code><a href="text-level-semantics.html#the-rtc-element">rtc</a></code>要素の<a data-anolis-xref="syntax-end-tag" href="#syntax-end-tag">終了タグ</a>は省略してもよい。</p><!-- </rp> -->

  
  <p><code><a href="text-level-semantics.html#the-rp-element">rp</a></code>要素が別の<code><a href="text-level-semantics.html#the-rb-element">rb</a></code>、<code><a href="text-level-semantics.html#the-rt-element">rt</a></code>、<code><a href="text-level-semantics.html#the-rtc-element">rtc</a></code>または<code><a href="text-level-semantics.html#the-rp-element">rp</a></code>要素の直前に存在する場合、または親要素に追加のコンテンツが存在しない場合、<code><a href="text-level-semantics.html#the-rp-element">rt</a></code>要素の<a data-anolis-xref="syntax-end-tag" href="#syntax-end-tag">終了タグ</a>は省略してもよい。</p><!-- </optgroup> (the text assumes <optgroup> can only be inside a <select>; commented out text
  below can handle the non-<select> case if we ever allow it) -->

  
  <p><code><a href="forms.html#the-optgroup-element">optgroup</a></code>要素が別の<code><a href="forms.html#the-optgroup-element">optgroup</a></code>要素の直前に存在する場合、または親要素に追加のコンテンツが存在しない場合、<code><a href="forms.html#the-optgroup-element">optgroup</a></code>要素の<a data-anolis-xref="syntax-end-tag" href="#syntax-end-tag">終了タグ</a>は省略してもよい。</p><!-- so e.g. the max number of </optgroup>s are omitted here:
   <select><optgroup></select>
   <p id=x><optgroup></optgroup>x</p>
   <p id=x><optgroup><optgroup></optgroup></optgroup>x</p>
   <p><optgroup id=x><optgroup></optgroup>x</p>
   <p><optgroup><optgroup id=x>x</p>
  --><!-- </option> -->
  

  
  <p><code><a href="forms.html#the-option-element">option</a></code>要素が別の<code><a href="forms.html#the-option-element">option</a></code>要素または<code><a href="forms.html#the-optgroup-element">optgroup</a></code>要素の直前に存在する場合、または親要素に追加のコンテンツが存在しない場合、<code><a href="forms.html#the-option-element">option</a></code>要素の<a data-anolis-xref="syntax-end-tag" href="#syntax-end-tag">終了タグ</a>は省略してもよい。</p><!-- <colgroup> -->

  
  <p><code><a href="tabular-data.html#the-colgroup-element">colgroup</a></code>要素内の最初の文が<code><a href="tabular-data.html#the-col-element">col</a></code>要素である場合、かつ<a data-anolis-xref="syntax-end-tag" href="#syntax-end-tag">終了タグ</a>が省略されている別の<code><a href="tabular-data.html#the-colgroup-element">colgroup</a></code>要素の直前に存在しない場合、<code><a href="tabular-data.html#the-colgroup-element">colgroup</a></code>要素の<a data-anolis-xref="syntax-start-tag" href="#syntax-start-tag">開始タグ</a>は省略してもよい。（要素が空である場合、省略できない。）</p><!-- </colgroup> -->

  
  <p><code><a href="tabular-data.html#the-colgroup-element">colgroup</a></code>要素の直前が<a href="infrastructure.html#space-character">空白文字</a>または<a data-anolis-xref="syntax-comments" href="#syntax-comments">コメント</a>でない場合、<code><a href="tabular-data.html#the-colgroup-element">colgroup</a></code>要素の<a data-anolis-xref="syntax-end-tag" href="#syntax-end-tag">終了タグ</a>は省略してもよい。</p><!-- </thead> -->

  
  <p><code><a href="tabular-data.html#the-thead-element">thead</a></code>要素が<code><a href="tabular-data.html#the-tbody-element">tbody</a></code>または<code><a href="tabular-data.html#the-tfoot-element">tfoot</a></code>要素の直前に存在する場合、<code><a href="tabular-data.html#the-thead-element">thead</a></code>要素の<a data-anolis-xref="syntax-end-tag" href="#syntax-end-tag">終了タグ</a>は省略してもよい。</p><!-- <tbody> -->

  
  <p><code><a href="tabular-data.html#the-tbody-element">tbody</a></code>要素内の最初の文が<code><a href="tabular-data.html#the-tr-element">tr</a></code>要素である場合、かつこの要素が<a data-anolis-xref="syntax-end-tag" href="#syntax-end-tag">終了タグ</a>が省略されている<code><a href="tabular-data.html#the-tbody-element">tbody</a></code>、<code><a href="tabular-data.html#the-thead-element">thead</a></code>、または<code><a href="tabular-data.html#the-tfoot-element">tfoot</a></code>要素の直前に存在しない場合、<code><a href="tabular-data.html#the-tbody-element">tbody</a></code>要素の<a data-anolis-xref="syntax-start-tag" href="#syntax-start-tag">開始タグ</a>は省略してもよい。（要素が空である場合、省略できない。）</p><!-- </tbody> -->

  
  <p><code><a href="tabular-data.html#the-tbody-element">tbody</a></code>要素が別の<code><a href="tabular-data.html#the-tbody-element">tbody</a></code>または<code><a href="tabular-data.html#the-tfoot-element">tfoot</a></code>要素の直前に存在する場合、または親要素に追加のコンテンツが存在しない場合、<code><a href="tabular-data.html#the-tbody-element">tbody</a></code>要素の<a data-anolis-xref="syntax-end-tag" href="#syntax-end-tag">終了タグ</a>は省略してもよい。</p><!-- </tfoot> -->

  
  <p><code><a href="tabular-data.html#the-tfoot-element">tfoot</a></code>要素が別の<code><a href="tabular-data.html#the-tbody-element">tbody</a></code>要素の直前に存在する場合、または親要素に追加のコンテンツが存在しない場合、<code><a href="tabular-data.html#the-tfoot-element">tfoot</a></code>要素の<a data-anolis-xref="syntax-end-tag" href="#syntax-end-tag">終了タグ</a>は省略してもよい。</p><!-- </tr> -->

  
  <p><code><a href="tabular-data.html#the-tr-element">tr</a></code>要素が別の<code><a href="tabular-data.html#the-tr-element">tr</a></code>要素の直前に存在する場合、または親要素に追加のコンテンツが存在しない場合、<code><a href="tabular-data.html#the-tr-element">tr</a></code>要素の<a data-anolis-xref="syntax-end-tag" href="#syntax-end-tag">終了タグ</a>は省略してもよい。</p><!-- </td> -->

  
  <p><code><a href="tabular-data.html#the-td-element">td</a></code>要素が別の<code><a href="tabular-data.html#the-td-element">td</a></code>または<code><a href="tabular-data.html#the-th-element">th</a></code>要素の直前に存在する場合、または親要素に追加のコンテンツが存在しない場合、<code><a href="tabular-data.html#the-td-element">td</a></code>要素の<a data-anolis-xref="syntax-end-tag" href="#syntax-end-tag">終了タグ</a>は省略してもよい。</p><!-- </th> -->

  
  <p><code><a href="tabular-data.html#the-th-element">th</a></code>要素が別の<code><a href="tabular-data.html#the-td-element">td</a></code>または<code><a href="tabular-data.html#the-th-element">th</a></code>要素の直前に存在する場合、または親要素に追加のコンテンツが存在しない場合、<code><a href="tabular-data.html#the-th-element">th</a></code>要素の<a data-anolis-xref="syntax-end-tag" href="#syntax-end-tag">終了タグ</a>は省略してもよい。</p>

  <p><strong>ただし</strong>、任意の属性を持つ場合、<a data-anolis-xref="syntax-start-tag" href="#syntax-start-tag">開始タグ</a>は省略してはならない。</p>


  <h5 id="element-restrictions"><span class="secno">8.1.2.5</span> コンテンツモデルの制約</h5>

  <p>歴史的な理由により、特定の要素は、その内容モデルによって与えられても、制限を超えて追加の制限がある。</p>

  <p><code><a href="tabular-data.html#the-table-element">table</a></code>要素は、これらの要素がこの仕様で説明された内容モデルに従って<code><a href="tabular-data.html#the-table-element">table</a></code>要素内で技術的に許可されているにもかかわらず、<code><a href="tabular-data.html#the-tr-element">tr</a></code>要素を含めてはならない。（<code><a href="tabular-data.html#the-tr-element">tr</a></code>要素がマークアップ内の<code><a href="tabular-data.html#the-table-element">table</a></code>の内側に配置される場合、実際にはその前の<code><a href="tabular-data.html#the-tbody-element">tbody</a></code>開始タグを暗示するだろう。）</p>

  <p>単一の<a data-anolis-xref="syntax-newlines" href="#syntax-newlines">改行</a>は、<code><a href="grouping-content.html#the-pre-element">pre</a></code>と<code><a href="forms.html#the-textarea-element">textarea</a></code>要素の<a data-anolis-xref="syntax-start-tag" href="#syntax-start-tag">開始タグ</a>の直後に置かれてもよい。要素のコンテンツが<a data-anolis-xref="syntax-newlines" href="#syntax-newlines">改行</a>で開始するように意図される場合、2つの連続する改行は、著者によって含まれる必要がある。</p>
  

  <div class="example">
   <p>以下の2つの<code><a href="grouping-content.html#the-pre-element">pre</a></code>ブロックは等価である：</p>
   <pre>&lt;pre&gt;Hello&lt;/pre&gt;</pre>
   <pre>&lt;pre&gt;<br>Hello&lt;/pre&gt;</pre>
  </div>


  <h5 id="cdata-rcdata-restrictions"><span class="secno">8.1.2.6</span> 生テキストおよびエスケープ可能な生テキスト要素のコンテンツの制約</h5>

  <p><a data-anolis-xref="raw text elements" href="#raw-text-elements">生テキスト</a>および<a href="#escapable-raw-text-elements">エスケープ可能な要素</a>でのテキストは、文字列"<code data-anolis-xref="">&lt;/</code>"（U+003C LESS-THAN SIGN、U+002F SOLIDUS）の後に要素のタグ名に大文字・小文字不区別で一致する文字の後に"tab"（U+0009）、"LF"（U+000A）、"FF"（U+000C）、"CR"（U+000D）、U+0020 SPACE、"&gt;"（U+003E）または"/"（U+002F）のいずれか1つの出現を含んではならない。</p>


  <h4 id="text"><span class="secno">8.1.3</span> テキスト</h4>

  <p><dfn data-anolis-xref="syntax-text" id="syntax-text">テキスト</dfn>は要素、属性値、およびコメントの内側で許可される。追加の制約は、他のセクションで説明するように、テキストが配置される場所に基づいて、テキストで何が許可され何が許可されないのか判別される。</p>


  <h5 id="newlines"><span class="secno">8.1.3.1</span> 改行</h5>

  <p>HTMLで<dfn data-anolis-xref="syntax-newlines" id="syntax-newlines">改行</dfn>は、"CR"（U+000D）文字、"LF"（U+000A）文字、または"CR"（U+000D）、"LF"（U+000A）文字の順でペアのいずれかとして表されてもよい。</p>

  <p><a data-anolis-xref="syntax-charref" href="#syntax-charref">文字参照</a>が許可される場所で、"LF"（U+000A）文字（ただし"CR"（U+000D）文字ではない）の文字参照はまた<a data-anolis-xref="syntax-newlines" href="#syntax-newlines">改行</a>を表す。</p>


  <h4 id="character-references"><span class="secno">8.1.4</span> 文字参照</h4>

  <p>他のセクションで説明するような特定の例において、<a data-anolis-xref="syntax-text" href="#syntax-text">テキスト</a>は<dfn data-anolis-xref="syntax-charref" id="syntax-charref">文字参照</dfn>と混合してもよい。これは、他の方法で合法的に<a data-anolis-xref="syntax-text" href="#syntax-text">テキスト</a>に含めることができない文字をエスケープするために使用できる。</p>

  <p>文字参照は、U+0026 AMPERSAND文字（&amp;）で始まらなければならない。これに続いて、文字参照の3つの可能な種類がある：</p>

  <dl><dt>名前文字参照</dt>

   <dd>アンパサンドは、同じ文字を使用して、<a href="#named-character-references">名前文字参照</a>のセクションに記載のいずれかの名前が続かなければならない。 <span class="impl">The name must be one that is
   terminated by a ";" (U+003B) character.</span></dd>


   <dt>10進数の数値文字参照</dt>

   <dd>アンパサンドは、"#"（U+0023）文字が続き、その後に以下の定義に従って許可されるUnicodeコードポイントに対応する10進数の整数を表す、1つ以上の<a href="infrastructure.html#ascii-digits">ASCII数字</a>が続かなければならない。数字は、その後に";"（U+003B）文字が続かなければならない。</dd>


   <dt>16進数の数値文字参照</dt>

   <dd>アンパサンドは、"#"（U+0023）文字が続き、その後に"x"（U+0078）文字または"X"（U+0058）文字のどちらかが続き、その後に下記の定義に従って許可されるUnicodeコードポイントに対応する16進数の整数を表す、1つ以上の<a href="infrastructure.html#ascii-hex-digits">ASCII16進数字</a>が続かなければならない。数字は、その後に";"（U+003B）文字が続かなければならない。</dd>

  </dl><p>上で説明したものを形成する数値文字参照は、U+0000、U+000D、永久に未定義のUnicode文字（noncharacters）、サロゲート（U+D800–U+DFFF）、および<a data-anolis-xref="space character" href="infrastructure.html#space-character">空白文字</a>以外の<a href="infrastructure.html#control-characters">制御文字</a>以外で任意のUnicodeコードポイントを参照するために許可される。</p>

  <p><dfn data-anolis-xref="syntax-ambiguous-ampersand" id="syntax-ambiguous-ampersand">曖昧なアンパサンド</dfn>は、U+0026 AMPERSAND文字（&amp;）に1つ以上の<a href="infrastructure.html#alphanumeric-ascii-characters">英数字ASCII文字</a>が続き、その後にU+003B SEMICOLON文字（;）が続くものである。ここで、これらの文字は<a href="#named-character-references">名前文字参照</a>のセクションで与えられた任意の名前に一致しない文字である。</p>


  <h4 id="cdata-sections"><span class="secno">8.1.5</span> CDATAセクション</h4>

  <p><dfn data-anolis-xref="syntax-cdata" id="syntax-cdata">CDATAセクション</dfn>は、次の順に以下のコンポーネントで構成されなければならない：</p>

  <ol><li>文字列"<code data-anolis-xref="">&lt;![CDATA[</code>"。</li>

   <li>テキストが文字列"<code data-anolis-xref="">]]&gt;</code>"を含んではならないという追加の制約ととともに、任意の<a data-anolis-xref="syntax-text" href="#syntax-text">テキスト</a>。</li>

   <li>文字列"<code data-anolis-xref="">]]&gt;</code>"。</li>

  </ol><div class="example">

   <p>CDATAセクションは外来コンテンツ（MathMLまたはSVG）でのみ使用できる。この例において、CDATAセクションは<code>ms</code>要素のコンテンツをエスケープするために使用される：</p>

   <pre>&lt;p&gt;You can add a string to a number, but this stringifies the number:&lt;/p&gt;
&lt;math&gt;
 &lt;ms&gt;&lt;![CDATA[x&lt;y]]&gt;&lt;/ms&gt;
 &lt;mo&gt;+&lt;/mo&gt;
 &lt;mn&gt;3&lt;/mn&gt;
 &lt;mo&gt;=&lt;/mo&gt;
 &lt;ms&gt;&lt;![CDATA[x&lt;y3]]&gt;&lt;/ms&gt;
&lt;/math&gt;</pre>

  </div>


  <h4 id="comments"><span class="secno">8.1.6</span> コメント</h4>

  <p><dfn data-anolis-xref="syntax-comments" id="syntax-comments">コメント</dfn>は、4文字シーケンスU+003C LESS-THAN SIGN、U+0021 EXCLAMATION MARK、U+002D HYPHEN-MINUS、U+002D HYPHEN-MINUS（<code data-anolis-xref="">&lt;!--</code>）で開始しなければならない。このシーケンスに続いて、テキストは1つの"&gt;"（U+003E）文字で開始してはならず、U+002D HYPHEN-MINUS文字（-）に続く"&gt;"（U+003E）文字で開始してはならず、2つの連続したU+002D HYPHEN-MINUS文字（<code data-anolis-xref="">--</code>）を含んではならず、"-"（U+002D）文字で終了してはならないという追加の制限とともに、コメントは<a data-anolis-xref="syntax-text" href="#syntax-text">テキスト</a>を持ってもよい。最後に、コメントは3文字シーケンスU+002D HYPHEN-MINUS、U+002D HYPHEN-MINUS、U+003E GREATER-THAN SIGN（<code data-anolis-xref="">--&gt;</code>）で終了しなければならない。</p><!--HTMLPARSER-->




  <div class="impl">

  <h3 id="parsing"><span class="secno">8.2 </span>Parsing HTML documents</h3>

  <p><i>This section only applies to user agents, data mining tools, and conformance
  checkers.</i></p>

  <p class="note">The rules for parsing XML documents into DOM trees are covered by the next
  section, entitled "<a href="the-xhtml-syntax.html#the-xhtml-syntax">The XHTML syntax</a>".</p>

  <p>User agents must use the parsing rules described in this section to generate the DOM trees from
  <code><a href="iana.html#text/html">text/html</a></code> resources. Together, these rules define what is referred to as the
  <dfn id="html-parser">HTML parser</dfn>.</p>

  <div class="note">

   <p>While the HTML syntax described in this specification bears a close resemblance to SGML and
   XML, it is a separate language with its own parsing rules.</p>

   <p>Some earlier versions of HTML (in particular from HTML2 to HTML4) were based on SGML and used
   SGML parsing rules. However, few (if any) web browsers ever implemented true SGML parsing for
   HTML documents; the only user agents to strictly handle HTML as an SGML application have
   historically been validators. The resulting confusion — with validators claiming documents
   to have one representation while widely deployed Web browsers interoperably implemented a
   different representation — has wasted decades of productivity. This version of HTML thus
   returns to a non-SGML basis.</p>

   <p>Authors interested in using SGML tools in their authoring pipeline are encouraged to use XML
   tools and the XML serialization of HTML.</p>

  </div>

  <p>This specification defines the parsing rules for HTML documents, whether they are syntactically
  correct or not. Certain points in the parsing algorithm are said to be <dfn data-anolis-xref="parse
  error" id="parse-error">parse errors</dfn>. The error handling for parse errors is well-defined (that's the
  processing rules described throughout this specification), but user agents, while parsing an HTML
  document, may <a data-anolis-xref="abort a parser" href="#abort-a-parser">abort the parser</a> at the first <a href="#parse-error">parse
  error</a> that they encounter for which they do not wish to apply the rules described in this
  specification.</p>

  <p>Conformance checkers must report at least one parse error condition to the user if one or more
  parse error conditions exist in the document and must not report parse error conditions if none
  exist in the document. Conformance checkers may report more than one parse error condition if more
  than one parse error condition exists in the document.</p>

  <p class="note">Parse errors are only errors with the <em>syntax</em> of HTML. In addition to
  checking for parse errors, conformance checkers will also verify that the document obeys all the
  other conformance requirements described in this specification.</p>

  <p>For the purposes of conformance checkers, if a resource is determined to be in <a href="#syntax">the HTML
  syntax</a>, then it is an <a data-anolis-xref="HTML documents" href="infrastructure.html#html-documents">HTML document</a>.</p>

  <p class="note">As stated <a class="no-backref" data-anolis-xref="HTML elements" href="infrastructure.html#html-elements">in the terminology
  section</a>, references to <a data-anolis-xref="element type" href="infrastructure.html#element-type">element types</a> that do not
  explicitly specify a namespace always refer to elements in the <a href="infrastructure.html#html-namespace-0">HTML namespace</a>. For
  example, if the spec talks about "a <code><a href="grouping-content.html#the-div-element">div</a></code> element", then that is an element with
  the local name "<code data-anolis-xref="">div</code>", the namespace "<code data-anolis-xref="">http://www.w3.org/1999/xhtml</code>", and the interface <code><a href="grouping-content.html#htmldivelement">HTMLDivElement</a></code>.
  Where possible, references to such elements are hyperlinked to their definition.</p>

  </div>


  <div class="impl">

  <h4 id="overview-of-the-parsing-model"><span class="secno">8.2.1 </span>Overview of the parsing model</h4>

  <p class="overview"><object data="images/parsing-model-overview.svg" height="535" width="345"><img alt="" height="450" src="images/parsing-model-overview.png" width="345"></object></p>

  <p>The input to the HTML parsing process consists of a stream of <a data-anolis-xref="Unicode code
  point" href="infrastructure.html#unicode-code-point">Unicode code points</a>, which is passed through a <a href="#tokenization">tokenization</a> stage
  followed by a <a href="#tree-construction">tree construction</a> stage. The output is a <code><a href="dom.html#document">Document</a></code>
  object.</p>

  <p class="note">Implementations that <a href="infrastructure.html#non-scripted">do not support scripting</a> do not
  have to actually create a DOM <code><a href="dom.html#document">Document</a></code> object, but the DOM tree in such cases is
  still used as the model for the rest of the specification.</p>

  <p>In the common case, the data handled by the tokenization stage comes from the network, but
  <a data-anolis-xref="dynamic markup insertion" href="webappapis.html#dynamic-markup-insertion">it can also come from script</a> running in the user
  agent, e.g. using the <code data-anolis-xref="dom-document-write"><a href="webappapis.html#dom-document-write">document.write()</a></code> API.</p>

  <p id="nestedParsing">There is only one set of states for the tokenizer stage and the tree
  construction stage, but the tree construction stage is reentrant, meaning that while the tree
  construction stage is handling one token, the tokenizer might be resumed, causing further tokens
  to be emitted and processed before the first token's processing is complete.</p>

  <div class="example">

   <p>In the following example, the tree construction stage will be called upon to handle a "p"
   start tag token while handling the "script" end tag token:</p>

   <pre>...
&lt;script&gt;
 document.write('&lt;p&gt;');
&lt;/script&gt;
...</pre>

  </div>

  <p>To handle these cases, parsers have a <dfn id="script-nesting-level">script nesting level</dfn>, which must be initially
  set to zero, and a <dfn id="parser-pause-flag">parser pause flag</dfn>, which must be initially set to false.</p>

  </div>



  <div class="impl">

  <h4 id="the-input-byte-stream"><span class="secno">8.2.2 </span>The <dfn>input byte stream</dfn></h4>

  <p>The stream of Unicode code points that comprises the input to the tokenization stage will be
  initially seen by the user agent as a stream of bytes (typically coming over the network or from
  the local file system). The bytes encode the actual characters according to a particular
  <i>character encoding</i>, which the user agent uses to decode the bytes into characters.</p>

  <p class="note">For XML documents, the algorithm user agents must use to determine the character
  encoding is given by the XML specification. This section does not apply to XML documents. <a href="references.html#refsXML">[XML]</a></p>

  <p>Usually, the <a href="#encoding-sniffing-algorithm">encoding sniffing algorithm</a> defined below is used to determine the
  character encoding.</p>

  <p>Given a character encoding, the bytes in the <a href="#the-input-byte-stream">input byte stream</a> must be converted
  to Unicode code points for the tokenizer's <a href="#input-stream">input stream</a>, as described by the rules
  for that encoding's <a href="infrastructure.html#decoder">decoder</a>.</p>

  <p class="note">Bytes or sequences of bytes in the original byte stream that did not conform to
  the encoding specification (e.g. invalid UTF-8 byte sequences in a UTF-8 input byte stream) are
  errors that conformance checkers are expected to report.</p>

  <p class="note">Leading Byte Order Marks (BOMs) are not stripped by the decoder algorithms, they
  are stripped by the algorithm below.</p>

  <p class="warning">The decoder algorithms describe how to handle invalid input; for security
  reasons, it is imperative that those rules be followed precisely. Differences in how invalid byte
  sequences are handled can result in, amongst other problems, script injection vulnerabilities
  ("XSS").</p>

  <p>When the HTML parser is decoding an input byte stream, it uses a character encoding and a <dfn data-anolis-xref="concept-encoding-confidence" id="concept-encoding-confidence">confidence</dfn>. The confidence is either <i>tentative</i>,
  <i>certain</i>, or <i>irrelevant</i>. The encoding used, and whether the confidence in that
  encoding is <i>tentative</i> or <i>certain</i>, is <a href="#meta-charset-during-parse">used
  during the parsing</a> to determine whether to <a href="#change-the-encoding">change the encoding</a>. If no encoding is
  necessary, e.g. because the parser is operating on a Unicode stream and doesn't have to use a
  character encoding at all, then the <a data-anolis-xref="concept-encoding-confidence" href="#concept-encoding-confidence">confidence</a> is
  <i>irrelevant</i>.</p>

  <p class="note">Some algorithms feed the parser by directly adding characters to the <a href="#input-stream">input
  stream</a> rather than adding bytes to the <a href="#the-input-byte-stream">input byte stream</a>.</p>


  <h5 id="parsing-with-a-known-character-encoding"><span class="secno">8.2.2.1 </span>Parsing with a known character encoding</h5>

  <p>When the HTML parser is to operate on an input byte stream that has <dfn id="a-known-definite-encoding">a known definite
  encoding</dfn>, then the character encoding is that encoding and the <a data-anolis-xref="concept-encoding-confidence" href="#concept-encoding-confidence">confidence</a> is <i>certain</i>.</p>


  <h5 id="determining-the-character-encoding"><span class="secno">8.2.2.2 </span>Determining the character encoding</h5>

  <p>In some cases, it might be impractical to unambiguously determine the encoding before parsing
  the document. Because of this, this specification provides for a two-pass mechanism with an
  optional pre-scan. Implementations are allowed, as described below, to apply a simplified parsing
  algorithm to whatever bytes they have available before beginning to parse the document. Then, the
  real parser is started, using a tentative encoding derived from this pre-parse and other
  out-of-band metadata. If, while the document is being loaded, the user agent discovers a character
  encoding declaration that conflicts with this information, then the parser can get reinvoked to
  perform a parse of the document with the real encoding.</p>

  <p id="documentEncoding">User agents must use the following algorithm, called the <dfn id="encoding-sniffing-algorithm">encoding
  sniffing algorithm</dfn>, to determine the character encoding to use when decoding a document in
  the first pass. This algorithm takes as input any out-of-band metadata available to the user agent
  (e.g. the <a data-anolis-xref="Content-Type" href="infrastructure.html#content-type">Content-Type metadata</a> of the document) and all the
  bytes available so far, and returns a character encoding and a <a data-anolis-xref="concept-encoding-confidence" href="#concept-encoding-confidence">confidence</a> that is either <i>tentative</i> or
  <i>certain</i>.</p>

  <ol><li>

    <p>If the user has explicitly instructed the user agent to override the document's character
    encoding with a specific encoding, optionally return that encoding with the <a data-anolis-xref="concept-encoding-confidence" href="#concept-encoding-confidence">confidence</a> <i>certain</i> and abort these steps.</p>

    <p class="note">Typically, user agents remember such user requests across sessions, and in some
    cases apply them to documents in <code><a href="embedded-content-0.html#the-iframe-element">iframe</a></code>s as well.</p>

   </li>

   <li>

    <p>The user agent may wait for more bytes of the resource to be available, either in this step
    or at any later step in this algorithm. For instance, a user agent might wait 500ms or 1024
    bytes, whichever came first. In general preparsing the source to find the encoding improves
    performance, as it reduces the need to throw away the data structures used when parsing upon
    finding the encoding information. However, if the user agent delays too long to obtain data to
    determine the encoding, then the cost of the delay could outweigh any performance improvements
    from the preparse.</p>

    <p class="note">The authoring conformance requirements for character encoding declarations limit
    them to only appearing <a href="document-metadata.html#charset1024">in the first 1024 bytes</a>. User agents are
    therefore encouraged to use the prescan algorithm below (as invoked by these steps) on the first
    1024 bytes, but not to stall beyond that.</p>

   </li>

   <li>

    <!-- Doing this step before honouring HTTP is important for supporting
            http://kb.dsqq.cn/html/2012-09/16/node_193.htm
         which is encoded as UTF-8 but is incorrectly labeled as
            Content-Type: text/html; charset=GB2312
    -->

    <p>For each of the rows in the following table, starting with the first one and going down, if
    there are as many or more bytes available than the number of bytes in the first column, and the
    first bytes of the file match the bytes given in the first column, then return the encoding
    given in the cell in the second column of that row, with the <a data-anolis-xref="concept-encoding-confidence" href="#concept-encoding-confidence">confidence</a> <i>certain</i>, and abort these steps:</p>

    <!-- this table is present in several forms in this file; keep them in sync -->
    <table><thead><tr><th>Bytes in Hexadecimal
       </th><th>Encoding
     <tbody><!-- nobody uses this
      <tr>
       <td>00 00 FE FF
       <td>UTF-32BE
      <tr>
       <td>FF FE 00 00
       <td>UTF-32LE
--></th></tr><tr><td>FE FF
       </td><td>Big-endian UTF-16
      </td></tr><tr><td>FF FE
       </td><td>Little-endian UTF-16
      </td></tr><tr><td>EF BB BF
       </td><td>UTF-8
<!-- nobody uses this
      <tr>
       <td>DD 73 66 73
       <td>UTF-EBCDIC
-->
    </td></tr></table><p class="note">This step looks for Unicode Byte Order Marks (BOMs).</p>

    <p class="note">That this step happens before the next one honoring the HTTP
    <code><a href="infrastructure.html#content-type">Content-Type</a></code> header is a <a href="introduction.html#willful-violation">willful violation</a> of the HTTP specification,
    motivated by a desire to be maximally compatible with legacy content. <a href="references.html#refsHTTP">[HTTP]</a></p>

   </li>

   <li><p>If the transport layer specifies a character encoding, and it is supported, return that
   encoding with the <a data-anolis-xref="concept-encoding-confidence" href="#concept-encoding-confidence">confidence</a> <i>certain</i>, and
   abort these steps.</li>

   <li>

    <p>Optionally <a data-anolis-xref="prescan a byte stream to determine its encoding" href="#prescan-a-byte-stream-to-determine-its-encoding">prescan the byte
    stream to determine its encoding</a>. The <var data-anolis-xref="">end condition</var> is that the user
    agent decides that scanning further bytes would not be efficient. User agents are encouraged to
    only prescan the first 1024 bytes. User agents may decide that scanning <em>any</em> bytes is
    not efficient, in which case these substeps are entirely skipped.</p>

    <p>The aforementioned algorithm either aborts unsuccessfully or returns a character encoding. If
    it returns a character encoding, then this algorithm must be aborted, returning the same
    encoding, with <a data-anolis-xref="concept-encoding-confidence" href="#concept-encoding-confidence">confidence</a> <i>tentative</i>.</p>

   </li>

   <li>

    <p>If the <a href="#html-parser">HTML parser</a> for which this algorithm is being run is associated with a
    <code><a href="dom.html#document">Document</a></code> that is itself in a <a href="browsers.html#nested-browsing-context">nested browsing context</a>, run these
    substeps:</p>

    <ol><li><p>Let <var data-anolis-xref="">new document</var> be the <code><a href="dom.html#document">Document</a></code> with which the
     <a href="#html-parser">HTML parser</a> is associated.</li>

     <li><p>Let <var data-anolis-xref="">parent document</var> be the <code><a href="dom.html#document">Document</a></code> <a data-anolis-xref="browsing context nested through" href="browsers.html#browsing-context-nested-through">through which <var data-anolis-xref="">new document</var> is
     nested</a> (the <a href="browsers.html#active-document">active document</a> of the <a href="browsers.html#parent-browsing-context">parent browsing context</a> of
     <var data-anolis-xref="">new document</var>).</li>

     <li><p>If <var data-anolis-xref="">parent document</var>'s <a href="browsers.html#origin-0">origin</a> is not the <a href="browsers.html#same-origin">same
     origin</a> as <var data-anolis-xref="">new document</var>'s <a href="browsers.html#origin-0">origin</a>, then abort these
     substeps.</li>

     <li><p>If <var data-anolis-xref="">parent document</var>'s <a data-anolis-xref="document's character
     encoding" href="infrastructure.html#document's-character-encoding">character encoding</a> is not an <a href="infrastructure.html#ascii-compatible-character-encoding">ASCII-compatible character encoding</a>,
     then abort these substeps.</li>

     <li><p>Return <var data-anolis-xref="">parent document</var>'s <a data-anolis-xref="document's character
     encoding" href="infrastructure.html#document's-character-encoding">character encoding</a>, with the <a data-anolis-xref="concept-encoding-confidence" href="#concept-encoding-confidence">confidence</a> <i>tentative</i>, and abort the
     <a href="#encoding-sniffing-algorithm">encoding sniffing algorithm</a>'s steps.</li>

    </ol></li>

   <li><p>Otherwise, if the user agent has information on the likely encoding for this page, e.g.
   based on the encoding of the page when it was last visited, then return that encoding, with the
   <a data-anolis-xref="concept-encoding-confidence" href="#concept-encoding-confidence">confidence</a> <i>tentative</i>, and abort these
   steps.</li>

   <li>

    <p>The user agent may attempt to autodetect the character encoding from applying frequency
    analysis or other algorithms to the data stream. Such algorithms may use information about the
    resource other than the resource's contents, including the address of the resource. If
    autodetection succeeds in determining a character encoding, and that encoding is a supported
    encoding, then return that encoding, with the <a data-anolis-xref="concept-encoding-confidence" href="#concept-encoding-confidence">confidence</a> <i>tentative</i>, and abort these steps.
    <a href="references.html#refsUNIVCHARDET">[UNIVCHARDET]</a></p>

    <p class="note">The UTF-8 encoding has a highly detectable bit pattern. Documents that contain
    bytes with values greater than 0x7F which match the UTF-8 pattern are very likely to be UTF-8,
    while documents with byte sequences that do not match it are very likely not. User-agents are
    therefore encouraged to search for this common encoding. <a href="references.html#refsPPUTF8">[PPUTF8]</a> <a href="references.html#refsUTF8DET">[UTF8DET]</a></p>

   </li>

   <li>

    <p>Otherwise, return an implementation-defined or user-specified default character encoding,
    with the <a data-anolis-xref="concept-encoding-confidence" href="#concept-encoding-confidence">confidence</a> <i>tentative</i>.</p>

    <p>In controlled environments or in environments where the encoding of documents can be
    prescribed (for example, for user agents intended for dedicated use in new networks), the
    comprehensive <code data-anolis-xref="">UTF-8</code> encoding is suggested.</p>

    <p>In other environments, the default encoding is typically dependent on the user's locale (an
    approximation of the languages, and thus often encodings, of the pages that the user is likely
    to frequent). The following table gives suggested defaults based on the user's locale, for
    compatibility with legacy content. Locales are identified by BCP 47 language tags. <a href="references.html#refsBCP47">[BCP47]</a> <a href="references.html#refsENCODING">[ENCODING]</a></p>

    <!-- based on three sources:
          1. mozilla 1.9.1 localizations: http://mxr.mozilla.org/l10n-mozilla1.9.1/find?string=global%2Fintl.properties&tree=l10n-mozilla1.9.1&hint= 
          2. windows vista encodings: http://msdn.microsoft.com/en-us/goglobal/bb896001
          3. chrome encodings: https://code.google.com/p/chromium/codesearch#search/&q=IDS_DEFAULT_ENCODING
         several assumptions were made in this process; amongst them:
          - ISO-8859-1 and Windows-1252 are the same (supported by encoding.spec.whatwg.org)
          - ISO-8859-9 and Windows-1254 are the same (supported by encoding.spec.whatwg.org)
          - Windows-31J and Shift_JIS are the same (supported by encoding.spec.whatwg.org)
          - Windows-932 is close enough to Shift_JIS to be treated as equivalent (supported by wikipedia)
          - Windows-936 is a basically a subset of GBK which is basically a subset of GB18030 (supported by wikipedia)
          - Windows-950 is basically the same as Big5 (supported by wikipedia)
          - Firefox's UTF-8 defaults are all bogus
    -->

    <table><thead><tr><th colspan="2">Locale language
       </th><th>Suggested default encoding
     <tbody><!-- af, Afrikaans, uses windows-1252: Windows Vista and Firefox agreed --><!-- am, Amharic, uses windows-1252: Firefox and Chrome agreed --></th></tr><tr><td>ar
       </td><td>Arabic
       </td><td>windows-1256 <!-- Windows Vista and Chrome agreed -->

      <!-- arn-CL, Mapudungun (Chile), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- az, Azeri, is not listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted windows-1254 -->

      <!-- az-Cyrl-AZ, Azeri (Cyrillic, Azerbaijan), is not listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted windows-1251 -->

      <!-- ba-RU, Bashkir (Russia), is not listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted windows-1251 -->
      <!-- ba wasn't listed at all because none of the sources knew about it. However, further feedback has changed this: -->
      </td></tr><tr><td>ba
       </td><td>Bashkir
       </td><td>windows-1251 <!-- per https://www.w3.org/Bugs/Public/show_bug.cgi?id=23089 -->

      <!-- be, Belarusian, was not initially listed here because Windows Vista wanted windows-1251, Chrome wanted <none>, and Firefox wanted ISO-8859-5 -->
      <!-- further feedback has changed this: -->
      </td></tr><tr><td>be
       </td><td>Belarusian
       </td><td>windows-1251 <!-- per https://www.w3.org/Bugs/Public/show_bug.cgi?id=23089 -->

      <!-- be-BY, Belarusian (Belarus), is not listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted windows-1251 -->

      </td></tr><tr><td>bg
       </td><td>Bulgarian
       </td><td>windows-1251 <!-- Windows Vista, Chrome, and Firefox agreed -->

      <!-- bn, Bengali, uses windows-1252: Firefox and Chrome agreed -->

      <!-- br-FR, Breton (France), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- bs-Cyrl-BA, Bosnian (Cyrillic, Bosnia and Herzegovina), is not listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted windows-1251 -->

      <!-- bs-Latn-BA, Bosnian (Latin, Bosnia and Herzegovina), is not listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted windows-1250 -->

      <!-- ca, Catalan, uses windows-1252: Windows Vista, Chrome, and Firefox agreed -->

      <!-- co-FR, Corsican (France), uses windows-1252: Windows Vista and Firefox agreed -->

      </td></tr><tr><td>cs
       </td><td>Czech
       </td><td>windows-1250 <!-- Windows Vista and Chrome agreed (but disagreed with Firefox, which thought the encoding should be ISO-8859-2) -->

      <!-- cy-GB, Welsh (United Kingdom), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- da, Danish, uses windows-1252: Windows Vista, Chrome, and Firefox agreed -->

      <!-- de, German, uses windows-1252: Windows Vista, Chrome, and Firefox agreed -->

      <!-- el, Greek, was not initially listed here because Windows Vista wanted windows-1253, Chrome wanted ISO-8859-7, and Firefox wanted windows-1252 -->
      <!-- el-GR, Greek (Greece), is not listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted windows-1253 -->
      <!-- further feedback has changed this: -->
      </td></tr><tr><td>el
       </td><td>Greek
       </td><td>ISO-8859-7 <!-- per https://www.w3.org/Bugs/Public/show_bug.cgi?id=23090 -->

      <!-- en, English, uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- es, Spanish, uses windows-1252: Windows Vista, Chrome, and Firefox agreed -->

      </td></tr><tr><td>et
       </td><td>Estonian
       </td><td>windows-1257 <!-- Windows Vista and Chrome agreed -->

      <!-- eu, Basque, uses windows-1252: Windows Vista and Firefox agreed -->

      </td></tr><tr><td>fa
       </td><td>Persian
       </td><td>windows-1256 <!-- Windows Vista and Chrome agreed -->

      <!-- fi, Finnish, uses windows-1252: Windows Vista, Chrome, and Firefox agreed -->

      <!-- fil, Filipino, uses windows-1252: Firefox and Chrome agreed -->

      <!-- fo, Faroese, uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- fr, French, uses windows-1252: Windows Vista, Chrome, and Firefox agreed -->

      <!-- fy-NL, Frisian (Netherlands), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- ga-IE, Irish (Ireland), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- gl, Galician, uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- gsw-FR, Alsatian (France), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- gu, Gujarati, uses windows-1252: Firefox and Chrome agreed -->

      <!-- ha-Latn-NG, Hausa (Latin, Nigeria), uses windows-1252: Windows Vista and Firefox agreed -->

      </td></tr><tr><td>he
       </td><td>Hebrew
       </td><td>windows-1255 <!-- Windows Vista, Chrome, and Firefox agreed -->

      <!-- hi, Hindi, uses windows-1252: Firefox and Chrome agreed -->

      </td></tr><tr><td>hr
       </td><td>Croatian
       </td><td>windows-1250 <!-- Windows Vista and Chrome agreed -->

      </td></tr><tr><td>hu
       </td><td>Hungarian
       </td><td>ISO-8859-2 <!-- Chrome and Firefox agreed (but disagreed with Windows Vista, which thought the encoding should be windows-1250) -->

      <!-- hu-HU, Hungarian (Hungary), is not listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted windows-1250 -->

      <!-- id, Indonesian, uses windows-1252: Windows Vista, Chrome, and Firefox agreed -->

      <!-- ig-NG, Igbo (Nigeria), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- is, Icelandic, uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- it, Italian, uses windows-1252: Windows Vista, Chrome, and Firefox agreed -->

      <!-- iu-Latn-CA, Inuktitut (Latin, Canada), uses windows-1252: Windows Vista and Firefox agreed -->

      </td></tr><tr><td>ja
       </td><td>Japanese
       </td><td>Shift_JIS <!-- Windows Vista, Chrome, and Firefox agreed -->

      <!-- kk, Kazakh, was not initially listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted windows-1251 -->
      <!-- further feedback has changed this: -->
      </td></tr><tr><td>kk
       </td><td>Kazakh
       </td><td>windows-1251 <!-- per https://www.w3.org/Bugs/Public/show_bug.cgi?id=23089 -->

      <!-- kl-GL, Greenlandic (Greenland), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- kn, Kannada, uses windows-1252: Firefox and Chrome agreed -->

      </td></tr><tr><td>ko
       </td><td>Korean
       </td><td>euc-kr <!-- Windows Vista, Chrome, and Firefox agreed -->

      </td></tr><tr><td>ku
       </td><td>Kurdish
       </td><td>windows-1254 <!-- Best guess -->

      <!-- ky, Kyrgyz, was not initially listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted windows-1251 -->
      <!-- further feedback has changed this: -->
      </td></tr><tr><td>ky
       </td><td>Kyrgyz
       </td><td>windows-1251 <!-- per https://www.w3.org/Bugs/Public/show_bug.cgi?id=23089 -->

      <!-- lb-LU, Luxembourgish (Luxembourg), uses windows-1252: Windows Vista and Firefox agreed -->

      </td></tr><tr><td>lt
       </td><td>Lithuanian
       </td><td>windows-1257 <!-- Windows Vista, Chrome, and Firefox agreed -->

      </td></tr><tr><td>lv
       </td><td>Latvian
       </td><td>windows-1257 <!-- Windows Vista and Chrome agreed (but disagreed with Firefox, which thought the encoding should be ISO-8859-13) -->

      <!-- mk, Macedonian, was not initially listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted windows-1251 -->
      <!-- further feedback has changed this: -->
      </td></tr><tr><td>mk
       </td><td>Macedonian
       </td><td>windows-1251 <!-- per https://www.w3.org/Bugs/Public/show_bug.cgi?id=23089 -->

      <!-- ml, Malayalam, uses windows-1252: Firefox and Chrome agreed -->

      <!-- mn, Mongolian, is not listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted windows-1251 -->

      <!-- moh-CA, Mohawk (Mohawk), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- mr, Marathi, uses windows-1252: Firefox and Chrome agreed -->

      <!-- ms, Malay, uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- nb, Norwegian Bokm&aring;l, uses windows-1252: Firefox and Chrome agreed -->

      <!-- nl, Dutch, uses windows-1252: Windows Vista, Chrome, and Firefox agreed -->

      <!-- nn-NO, Norwegian, Nynorsk (Norway), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- no, Norwegian, uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- nso-ZA, Sesotho sa Leboa (South Africa), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- oc-FR, Occitan (France), uses windows-1252: Windows Vista and Firefox agreed -->

      </td></tr><tr><td>pl
       </td><td>Polish
       </td><td>ISO-8859-2 <!-- Chrome and Firefox agreed (but disagreed with Windows Vista, which thought the encoding should be windows-1250) -->

      <!-- pl-PL, Polish (Poland), is not listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted windows-1250 -->

      <!-- prs-AF, Dari (Afghanistan), is not listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted windows-1256 -->

      <!-- pt, Portuguese, uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- qut-GT, K'iche (Guatemala), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- quz-BO, Quechua (Bolivia), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- quz-EC, Quechua (Ecuador), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- quz-PE, Quechua (Peru), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- rm-CH, Romansh (Switzerland), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- ro, Romanian, is not listed here because Windows Vista wanted windows-1250, Chrome wanted ISO-8859-2, and Firefox wanted <none> -->

      <!-- ro-RO, Romanian (Romania), is not listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted windows-1250 -->

      </td></tr><tr><td>ru
       </td><td>Russian
       </td><td>windows-1251 <!-- Windows Vista, Chrome, and Firefox agreed -->

      <!-- rw-RW, Kinyarwanda (Rwanda), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- sah-RU, Yakut (Russia), is not listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted windows-1251 -->
      <!-- sah wasn't listed at all because none of the sources knew about it. However, further feedback has changed this: -->
      </td></tr><tr><td>sah
       </td><td>Yakut
       </td><td>windows-1251 <!-- per https://www.w3.org/Bugs/Public/show_bug.cgi?id=23089 -->

      <!-- se-FI, Sami, Northern (Finland), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- se-NO, Sami, Northern (Norway), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- se-SE, Sami, Northern (Sweden), uses windows-1252: Windows Vista and Firefox agreed -->

      </td></tr><tr><td>sk
       </td><td>Slovak
       </td><td>windows-1250 <!-- Windows Vista, Chrome, and Firefox agreed -->

      </td></tr><tr><td>sl
       </td><td>Slovenian
       </td><td>ISO-8859-2 <!-- Chrome and Firefox agreed (but disagreed with Windows Vista, which thought the encoding should be windows-1250) -->

      <!-- sl-SI, Slovenian (Slovenia), is not listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted windows-1250 -->

      <!-- sma-NO, Sami, Southern (Norway), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- sma-SE, Sami, Southern (Sweden), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- smj-NO, Sami, Lule (Norway), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- smj-SE, Sami, Lule (Sweden), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- smn-FI, Sami, Inari (Finland), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- sms-FI, Sami, Skolt (Finland), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- sq, Albanian, is not listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted windows-1250 -->

      </td></tr><tr><td>sr
       </td><td>Serbian
       </td><td>windows-1251 <!-- Windows Vista and Chrome agreed -->

      <!-- sr-Latn-BA, Serbian (Latin, Bosnia and Herzegovina), is not listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted windows-1250 -->

      <!-- sr-Latn-SP, Serbian (Latin, Serbia), is not listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted windows-1250 -->

      <!-- sv, Swedish, uses windows-1252: Windows Vista, Chrome, and Firefox agreed -->

      <!-- sw, Kiswahili, uses windows-1252: Windows Vista, Chrome, and Firefox agreed -->

      <!-- ta, Tamil, uses windows-1252: Firefox and Chrome agreed -->

      <!-- te, Telugu, uses windows-1252: Firefox and Chrome agreed -->

      <!-- tg-Cyrl-TJ, Tajik (Cyrillic, Tajikistan), is not listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted windows-1251 -->
      <!-- tg wasn't listed at all because none of the sources knew about it. However, further feedback has changed this: -->
      </td></tr><tr><td>tg
       </td><td>Tajik
       </td><td>windows-1251 <!-- per https://www.w3.org/Bugs/Public/show_bug.cgi?id=23089 -->

      </td></tr><tr><td>th
       </td><td>Thai
       </td><td>windows-874 <!-- Windows Vista, Chrome, and Firefox agreed -->

      <!-- tk-TM, Turkmen (Turkmenistan), is not listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted windows-1250 -->

      <!-- tn-ZA, Setswana (South Africa), uses windows-1252: Windows Vista and Firefox agreed -->

      </td></tr><tr><td>tr
       </td><td>Turkish
       </td><td>windows-1254 <!-- Windows Vista, Chrome, and Firefox agreed -->

      <!-- tt, Tatar, was not initially listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted windows-1251 -->
      <!-- further feedback has changed this: -->
      </td></tr><tr><td>tt
       </td><td>Tatar
       </td><td>windows-1251 <!-- per https://www.w3.org/Bugs/Public/show_bug.cgi?id=23089 -->

      <!-- tzm-Latn-DZ, Tamazight (Latin, Algeria), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- ug-CN, Uighur (PRC), is not listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted windows-1256 -->

      </td></tr><tr><td>uk
       </td><td>Ukrainian
       </td><td>windows-1251 <!-- Windows Vista, Chrome, and Firefox agreed -->

      <!-- ur, Urdu, is not listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted windows-1256 -->

      <!-- uz, Uzbek, is not listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted windows-1254 -->

      <!-- uz-Cyrl-UZ, Uzbek (Cyrillic, Uzbekistan), is not listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted windows-1251 -->

      </td></tr><tr><td>vi
       </td><td>Vietnamese
       </td><td>windows-1258 <!-- Windows Vista and Chrome agreed -->

      <!-- wee-DE, Lower Sorbian (Germany), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- wen-DE, Upper Sorbian (Germany), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- wo-SN, Wolof (Senegal), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- xh-ZA, isiXhosa (South Africa), uses windows-1252: Windows Vista and Firefox agreed -->

      <!-- yo-NG, Yoruba (Nigeria), uses windows-1252: Windows Vista and Firefox agreed -->

      </td></tr><tr><td>zh-CN
       </td><td>Chinese (People's Republic of China)
       </td><td>GB18030 <!-- Windows Vista, Chrome, and Firefox agreed -->

      <!-- zh-HK, Chinese (Hong Kong S.A.R.), is not listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted Big5 -->

      <!-- zh-Hans, Chinese (Simplified), is not listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted GB18030 -->

      <!-- zh-Hant, Chinese (Traditional), is not listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted Big5 -->

      <!-- zh-MO, Chinese (Macao S.A.R.), is not listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted Big5 -->

      <!-- zh-SG, Chinese (Singapore), is not listed here because neither Chrome nor Firefox knew about it. For what it's worth, Windows Vista wanted GB18030 -->

      </td></tr><tr><td>zh-TW
       </td><td>Chinese (Taiwan)
       </td><td>Big5 <!-- Windows Vista, Chrome, and Firefox agreed -->

      <!-- zu-ZA, isiZulu (South Africa), uses windows-1252: Windows Vista and Firefox agreed -->

      </td></tr><tr><td colspan="2">All other locales
       </td><td>windows-1252

    </td></tr></table><p class="tablenote"><small>The contents of this table are derived from the intersection of
    Windows, Chrome, and Firefox defaults.</small></p>

   </li>

  </ol><p>The <a href="infrastructure.html#document's-character-encoding">document's character encoding</a> must immediately be set to the value returned
  from this algorithm, at the same time as the user agent uses the returned value to select the
  decoder to use for the input byte stream.</p>

  <hr><p>When an algorithm requires a user agent to <dfn id="prescan-a-byte-stream-to-determine-its-encoding">prescan a byte stream to determine its
  encoding</dfn>, given some defined <var data-anolis-xref="">end condition</var>, then it must run the
  following steps. These steps either abort unsuccessfully or return a character encoding. If at any
  point during these steps (including during instances of the <a data-anolis-xref="concept-get-attributes-when-sniffing" href="#concept-get-attributes-when-sniffing">get an attribute</a> algorithm invoked by this
  one) the user agent either runs out of bytes (meaning the <var data-anolis-xref="">position</var> pointer
  created in the first step below goes beyond the end of the byte stream obtained so far) or reaches
  its <var data-anolis-xref="">end condition</var>, then abort the <a href="#prescan-a-byte-stream-to-determine-its-encoding">prescan a byte stream to determine its
  encoding</a> algorithm unsuccessfully.</p>

  <ol><li>

    <p>Let <var data-anolis-xref="">position</var> be a pointer to a byte in the input byte stream, initially
    pointing at the first byte.</p>

   </li>

   <li>

    <p><i>Loop</i>: If <var data-anolis-xref="">position</var> points to:</p>

    <dl class="switch"><dt>A sequence of bytes starting with: 0x3C 0x21 0x2D 0x2D (ASCII '&lt;!--')</dt>
     <dd>

      <p>Advance the <var data-anolis-xref="">position</var> pointer so that it points at the first 0x3E byte
      which is preceded by two 0x2D bytes (i.e. at the end of an ASCII '--&gt;' sequence) and comes
      after the 0x3C byte that was found. (The two 0x2D bytes can be the same as the those in the
      '&lt;!--' sequence.)</p>

     </dd>

     <dt>A sequence of bytes starting with: 0x3C, 0x4D or 0x6D, 0x45 or 0x65, 0x54 or 0x74, 0x41 or 0x61, and one of 0x09, 0x0A, 0x0C, 0x0D, 0x20, 0x2F (case-insensitive ASCII '&lt;meta' followed by a space or slash)</dt>
     <dd>

      <ol><li><p>Advance the <var data-anolis-xref="">position</var> pointer so that it points at the next 0x09,
       0x0A, 0x0C, 0x0D, 0x20, or 0x2F byte (the one in sequence of characters matched
       above).</li>

       <li><p>Let <var data-anolis-xref="">attribute list</var> be an empty list of strings.</li> <!-- so
       long as we only care about http-equiv, content, and charset, this can be a 3-bit bitfield -->

       <li><p>Let <var data-anolis-xref="">got pragma</var> be false.</li>

       <li><p>Let <var data-anolis-xref="">need pragma</var> be null.</li>

       <li><p>Let <var data-anolis-xref="">charset</var> be the null value (which, for the purposes of this
       algorithm, is distinct from an unrecognised encoding or the empty string).</li>

       <li><p><i>Attributes</i>: <a data-anolis-xref="concept-get-attributes-when-sniffing" href="#concept-get-attributes-when-sniffing">Get an
       attribute</a> and its value. If no attribute was sniffed, then jump to the
       <i>processing</i> step below.</li>

       <li><p>If the attribute's name is already in <var data-anolis-xref="">attribute list</var>, then return
       to the step labeled <i>attributes</i>.</p>

       </li><li><p>Add the attribute's name to <var data-anolis-xref="">attribute list</var>.</p>

       </li><li>

        <p>Run the appropriate step from the following list, if one applies:</p>

        <dl class="switch"><dt>If the attribute's name is "<code data-anolis-xref="">http-equiv</code>"</dt>

         <dd><p>If the attribute's value is "<code data-anolis-xref="">content-type</code>", then set <var data-anolis-xref="">got pragma</var> to true.</dd>

         <dt>If the attribute's name is "<code data-anolis-xref="">content</code>"</dt>

         <dd><p>Apply the <a href="infrastructure.html#algorithm-for-extracting-a-character-encoding-from-a-meta-element">algorithm for extracting a character encoding from a
         <code>meta</code> element</a>, giving the attribute's value as the string to parse. If a
         character encoding is returned, and if <var data-anolis-xref="">charset</var> is still set to null,
         let <var data-anolis-xref="">charset</var> be the encoding returned, and set <var data-anolis-xref="">need
         pragma</var> to true.</dd>

         <dt>If the attribute's name is "<code data-anolis-xref="">charset</code>"</dt>

         <dd><p>Let <var data-anolis-xref="">charset</var> be the result of <a href="infrastructure.html#getting-an-encoding">getting an encoding</a>
         from the attribute's value, and set <var data-anolis-xref="">need pragma</var> to false.</dd>

        </dl></li>

       <li><p>Return to the step labeled <i>attributes</i>.</li>

       <li><p><i>Processing</i>: If <var data-anolis-xref="">need pragma</var> is null, then jump to the step
       below labeled <i>next byte</i>.</li>

       <li><p>If <var data-anolis-xref="">need pragma</var> is true but <var data-anolis-xref="">got pragma</var> is
       false, then jump to the step below labeled <i>next byte</i>.</li>

       <li><p>If <var data-anolis-xref="">charset</var> is <a href="infrastructure.html#a-utf-16-encoding">a UTF-16 encoding</a>, change the value of
       <var data-anolis-xref="">charset</var> to UTF-8.</li>

       <li><p>If <var data-anolis-xref="">charset</var> is not a supported character encoding, then jump to the
       step below labeled <i>next byte</i>.</li>

       <li><p>Abort the <a href="#prescan-a-byte-stream-to-determine-its-encoding">prescan a byte stream to determine its encoding</a> algorithm,
       returning the encoding given by <var data-anolis-xref="">charset</var>.</li>

      </ol></dd>

     <dt>A sequence of bytes starting with a 0x3C byte (ASCII &lt;), optionally a 0x2F byte (ASCII /), and finally a byte in the range 0x41-0x5A or 0x61-0x7A (an ASCII letter)</dt>
     <dd>

      <ol><li><p>Advance the <var data-anolis-xref="">position</var> pointer so that it points at the next 0x09
       (ASCII TAB), 0x0A (ASCII LF), 0x0C (ASCII FF), 0x0D (ASCII CR), 0x20 (ASCII space), or 0x3E
       (ASCII &gt;) byte.</li>

       <li><p>Repeatedly <a data-anolis-xref="concept-get-attributes-when-sniffing" href="#concept-get-attributes-when-sniffing">get an attribute</a>
       until no further attributes can be found, then jump to the step below labeled <i>next
       byte</i>.</li>

      </ol></dd>

     <dt>A sequence of bytes starting with: 0x3C 0x21 (ASCII '&lt;!')</dt>
     <dt>A sequence of bytes starting with: 0x3C 0x2F (ASCII '&lt;/')</dt>
     <dt>A sequence of bytes starting with: 0x3C 0x3F (ASCII '&lt;?')</dt>
     <dd>

      <p>Advance the <var data-anolis-xref="">position</var> pointer so that it points at the first 0x3E byte
      (ASCII &gt;) that comes after the 0x3C byte that was found.</p>

     </dd>

     <dt>Any other byte</dt>
     <dd>

      <p>Do nothing with that byte.</p>

     </dd>

    </dl></li>

   <li><i>Next byte</i>: Move <var data-anolis-xref="">position</var> so it points at the next byte in the
   input byte stream, and return to the step above labeled <i>loop</i>.</li>

  </ol><p>When the <a href="#prescan-a-byte-stream-to-determine-its-encoding">prescan a byte stream to determine its encoding</a> algorithm says to <dfn data-anolis-xref="concept-get-attributes-when-sniffing" id="concept-get-attributes-when-sniffing">get an attribute</dfn>, it means doing this:</p>

  <ol><li><p>If the byte at <var data-anolis-xref="">position</var> is one of 0x09 (ASCII TAB), 0x0A (ASCII LF),
   0x0C (ASCII FF), 0x0D (ASCII CR), 0x20 (ASCII space), or 0x2F (ASCII /) then advance <var data-anolis-xref="">position</var> to the next byte and redo this step.</li>

   <li><p>If the byte at <var data-anolis-xref="">position</var> is 0x3E (ASCII &gt;), then abort the <a data-anolis-xref="concept-get-attributes-when-sniffing" href="#concept-get-attributes-when-sniffing">get an attribute</a> algorithm. There isn't
   one.</li>

   <li><p>Otherwise, the byte at <var data-anolis-xref="">position</var> is the start of the attribute name.
   Let <var data-anolis-xref="">attribute name</var> and <var data-anolis-xref="">attribute value</var> be the empty
   string.</li>

   <li><p>Process the byte at <var data-anolis-xref="">position</var> as follows:</p>

    <dl class="switch"><dt>If it is 0x3D (ASCII =), and the <var data-anolis-xref="">attribute name</var> is longer than the
     empty string</dt>

     <dd>Advance <var data-anolis-xref="">position</var> to the next byte and jump to the step below labeled
     <i>value</i>.</dd>

     <dt>If it is 0x09 (ASCII TAB), 0x0A (ASCII LF), 0x0C (ASCII FF), 0x0D (ASCII CR), or 0x20
     (ASCII space)</dt>

     <dd>Jump to the step below labeled <i>spaces</i>.</dd>

     <dt>If it is 0x2F (ASCII /) or 0x3E (ASCII &gt;)</dt>

     <dd>Abort the <a data-anolis-xref="concept-get-attributes-when-sniffing" href="#concept-get-attributes-when-sniffing">get an attribute</a>
     algorithm. The attribute's name is the value of <var data-anolis-xref="">attribute name</var>, its value
     is the empty string.</dd>

     <dt>If it is in the range 0x41 (ASCII A) to 0x5A (ASCII Z)</dt>

     <dd>Append the Unicode character with code point <span data-anolis-xref=""><var data-anolis-xref="">b</var>+0x20</span> to <var data-anolis-xref="">attribute name</var> (where <var data-anolis-xref="">b</var>
     is the value of the byte at <var data-anolis-xref="">position</var>). (This converts the input to
     lowercase.)</dd>

     <dt>Anything else</dt>

     <dd>Append the Unicode character with the same code point as the value of the byte at <var data-anolis-xref="">position</var> to <var data-anolis-xref="">attribute name</var>. (It doesn't actually matter how
     bytes outside the ASCII range are handled here, since only ASCII characters can contribute to
     the detection of a character encoding.)</dd>

    </dl></li>

   <li><p>Advance <var data-anolis-xref="">position</var> to the next byte and return to the previous
   step.</li>

   <li><p><i>Spaces</i>: If the byte at <var data-anolis-xref="">position</var> is one of 0x09 (ASCII TAB),
   0x0A (ASCII LF), 0x0C (ASCII FF), 0x0D (ASCII CR), or 0x20 (ASCII space) then advance <var data-anolis-xref="">position</var> to the next byte, then, repeat this step.</li>

   <li><p>If the byte at <var data-anolis-xref="">position</var> is <em>not</em> 0x3D (ASCII =), abort the
   <a data-anolis-xref="concept-get-attributes-when-sniffing" href="#concept-get-attributes-when-sniffing">get an attribute</a> algorithm. The
   attribute's name is the value of <var data-anolis-xref="">attribute name</var>, its value is the empty
   string.</li>

   <li><p>Advance <var data-anolis-xref="">position</var> past the 0x3D (ASCII =) byte.</li>

   <li><p><i>Value</i>: If the byte at <var data-anolis-xref="">position</var> is one of 0x09 (ASCII TAB), 0x0A
   (ASCII LF), 0x0C (ASCII FF), 0x0D (ASCII CR), or 0x20 (ASCII space) then advance <var data-anolis-xref="">position</var> to the next byte, then, repeat this step.</li>

   <li><p>Process the byte at <var data-anolis-xref="">position</var> as follows:</p>

    <dl class="switch"><dt>If it is 0x22 (ASCII ") or 0x27 (ASCII ')</dt>

     <dd>

      <ol><li>Let <var data-anolis-xref="">b</var> be the value of the byte at <var data-anolis-xref="">position</var>.</li>

       <li><i>Quote loop</i>: Advance <var data-anolis-xref="">position</var> to the next byte.</li>

       <li>If the value of the byte at <var data-anolis-xref="">position</var> is the value of <var data-anolis-xref="">b</var>, then advance <var data-anolis-xref="">position</var> to the next byte and abort the
       "get an attribute" algorithm. The attribute's name is the value of <var data-anolis-xref="">attribute
       name</var>, and its value is the value of <var data-anolis-xref="">attribute value</var>.</li>

       <li>Otherwise, if the value of the byte at <var data-anolis-xref="">position</var> is in the range 0x41
       (ASCII A) to 0x5A (ASCII Z), then append a Unicode character to <var data-anolis-xref="">attribute
       value</var> whose code point is 0x20 more than the value of the byte at <var data-anolis-xref="">position</var>.</li>

       <li>Otherwise, append a Unicode character to <var data-anolis-xref="">attribute value</var> whose code
       point is the same as the value of the byte at <var data-anolis-xref="">position</var>.</li>

       <li>Return to the step above labeled <i>quote loop</i>.</li>

      </ol></dd>

     <dt>If it is 0x3E (ASCII &gt;)</dt>

     <dd>Abort the <a data-anolis-xref="concept-get-attributes-when-sniffing" href="#concept-get-attributes-when-sniffing">get an attribute</a>
     algorithm. The attribute's name is the value of <var data-anolis-xref="">attribute name</var>, its value
     is the empty string.</dd>


     <dt>If it is in the range 0x41 (ASCII A) to 0x5A (ASCII Z)</dt>

     <dd>Append the Unicode character with code point <span data-anolis-xref=""><var data-anolis-xref="">b</var>+0x20</span> to <var data-anolis-xref="">attribute value</var> (where <var data-anolis-xref="">b</var> is the value of the byte at <var data-anolis-xref="">position</var>). Advance <var data-anolis-xref="">position</var> to the next byte.</dd>

     <dt>Anything else</dt>

     <dd>Append the Unicode character with the same code point as the value of the byte at <var data-anolis-xref="">position</var> to <var data-anolis-xref="">attribute value</var>. Advance <var data-anolis-xref="">position</var> to the next byte.</dd>

    </dl></li>

   <li><p>Process the byte at <var data-anolis-xref="">position</var> as
   follows:</p>

    <dl class="switch"><dt>If it is 0x09 (ASCII TAB), 0x0A (ASCII LF), 0x0C (ASCII FF), 0x0D (ASCII CR), 0x20 (ASCII
     space), or 0x3E (ASCII &gt;)</dt>

     <dd>Abort the <a data-anolis-xref="concept-get-attributes-when-sniffing" href="#concept-get-attributes-when-sniffing">get an attribute</a>
     algorithm. The attribute's name is the value of <var data-anolis-xref="">attribute name</var> and its
     value is the value of <var data-anolis-xref="">attribute value</var>.</dd>

     <dt>If it is in the range 0x41 (ASCII A) to 0x5A (ASCII Z)</dt>

     <dd>Append the Unicode character with code point <span data-anolis-xref=""><var data-anolis-xref="">b</var>+0x20</span> to <var data-anolis-xref="">attribute value</var> (where <var data-anolis-xref="">b</var> is the value of the byte at <var data-anolis-xref="">position</var>).</dd>

     <dt>Anything else</dt>

     <dd>Append the Unicode character with the same code point as the value of the byte at <var data-anolis-xref="">position</var> to <var data-anolis-xref="">attribute value</var>.</dd>

    </dl></li>

   <li><p>Advance <var data-anolis-xref="">position</var> to the next byte and return to the previous
   step.</li>

  </ol><p>For the sake of interoperability, user agents should not use a pre-scan algorithm that returns
  different results than the one described above. (But, if you do, please at least let us know, so
  that we can improve this algorithm and benefit everyone...)</p>

<!--(removed this since the specs are being changed)
  <p class="note">These algorithms are a <span>willful violation</span> of the HTTP specification,
  which requires that the encoding be assumed to be ISO-8859-1 in the absence of a <span>character
  encoding declaration</span> to the contrary, and of RFC 2046, which requires that the encoding be
  assumed to be US-ASCII in the absence of a <span>character encoding declaration</span> to the
  contrary. This specification's third approach is motivated by a desire to be maximally compatible
  with legacy content. <a href="#refsHTTP">[HTTP]</a> <a href="#refsRFC2046">[RFC2046]</a></p>
-->



  <h5 id="character-encodings"><span class="secno">8.2.2.3 </span>Character encodings</h5>

  <p>User agents must support the encodings defined in the Encoding standard. User agents
  should not support other encodings.</p>

  <p>User agents must not support the CESU-8, UTF-7, BOCU-1 and SCSU encodings. <a href="references.html#refsCESU8">[CESU8]</a> <a href="references.html#refsUTF7">[UTF7]</a> <a href="references.html#refsBOCU1">[BOCU1]</a> <a href="references.html#refsSCSU">[SCSU]</a></p>

  <p>Support for encodings based on EBCDIC is especially discouraged. This encoding is rarely used
  for publicly-facing Web content. Support for UTF-32 is also especially discouraged. This encoding
  is rarely used, and frequently implemented incorrectly.</p>

  <p class="note">This specification does not make any attempt to support EBCDIC-based encodings and
  UTF-32 in its algorithms; support and use of these encodings can thus lead to unexpected behavior
  in implementations of this specification.</p>


  <h5 id="changing-the-encoding-while-parsing"><span class="secno">8.2.2.4 </span>Changing the encoding while parsing</h5>

  <p>When the parser requires the user agent to <dfn id="change-the-encoding">change the encoding</dfn>, it must run the
  following steps. This might happen if the <a href="#encoding-sniffing-algorithm">encoding sniffing algorithm</a> described above
  failed to find a character encoding, or if it found a character encoding that was not the actual
  encoding of the file.</p>

  <ol><li>If the encoding that is already being used to interpret the input stream is <a href="infrastructure.html#a-utf-16-encoding">a UTF-16
   encoding</a>, then set the <a data-anolis-xref="concept-encoding-confidence" href="#concept-encoding-confidence">confidence</a> to
   <i>certain</i> and abort these steps. The new encoding is ignored; if it was anything but the
   same encoding, then it would be clearly incorrect.</li>

   <li>If the new encoding is <a href="infrastructure.html#a-utf-16-encoding">a UTF-16 encoding</a>, change it to UTF-8.</li>

   <li>If the new encoding is identical or equivalent to the encoding that is already being used to
   interpret the input stream, then set the <a data-anolis-xref="concept-encoding-confidence" href="#concept-encoding-confidence">confidence</a> to <i>certain</i> and abort these steps.
   This happens when the encoding information found in the file matches what the <a href="#encoding-sniffing-algorithm">encoding
   sniffing algorithm</a> determined to be the encoding, and in the second pass through the
   parser if the first pass found that the encoding sniffing algorithm described in the earlier
   section failed to find the right encoding.</li>

   <li>If all the bytes up to the last byte converted by the current decoder have the same Unicode
   interpretations in both the current encoding and the new encoding, and if the user agent supports
   changing the converter on the fly, then the user agent may change to the new converter for the
   encoding on the fly. Set the <a href="infrastructure.html#document's-character-encoding">document's character encoding</a> and the encoding used to
   convert the input stream to the new encoding, set the <a data-anolis-xref="concept-encoding-confidence" href="#concept-encoding-confidence">confidence</a> to <i>certain</i>, and abort these
   steps.</li>

   <li>Otherwise, <a href="browsers.html#navigate">navigate</a><!--DONAV reparse--> to the document again, with
   <a href="browsers.html#replacement-enabled">replacement enabled</a>, and using the same <a href="browsers.html#source-browsing-context">source browsing context</a>, but
   this time skip the <a href="#encoding-sniffing-algorithm">encoding sniffing algorithm</a> and instead just set the encoding to
   the new encoding and the <a data-anolis-xref="concept-encoding-confidence" href="#concept-encoding-confidence">confidence</a> to
   <i>certain</i>. Whenever possible, this should be done without actually contacting the network
   layer (the bytes should be re-parsed from memory), even if, e.g., the document is marked as not
   being cacheable. If this is not possible and contacting the network layer would involve repeating
   a request that uses a method other than HTTP GET (<a data-anolis-xref="concept-http-equivalent-get" href="infrastructure.html#concept-http-equivalent-get">or
   equivalent</a> for non-HTTP URLs), then instead set the <a data-anolis-xref="concept-encoding-confidence" href="#concept-encoding-confidence">confidence</a> to <i>certain</i> and ignore the new
   encoding. The resource will be misinterpreted. User agents may notify the user of the situation,
   to aid in application development.</li>

  </ol><h5 id="preprocessing-the-input-stream"><span class="secno">8.2.2.5 </span>Preprocessing the input stream</h5>

  <p>The <dfn id="input-stream">input stream</dfn> consists of the characters pushed into it as the <a href="#the-input-byte-stream">input byte
  stream</a> is decoded or from the various APIs that directly manipulate the input stream.</p>

  <p>One leading U+FEFF BYTE ORDER MARK character must be ignored if any are present in the
  <a href="#input-stream">input stream</a>.</p>

  <p class="note">The requirement to strip a U+FEFF BYTE ORDER MARK character regardless of whether
  that character was used to determine the byte order is a <a href="introduction.html#willful-violation">willful violation</a> of
  Unicode, motivated by a desire to increase the resilience of user agents in the face of naïve
  transcoders.</p>

  <p>Any occurrences of any characters in the ranges U+0001 to U+0008, <!-- HT, LF allowed --> <!--
  U+000B is in the next list --> <!-- FF, CR allowed --> U+000E to U+001F, <!-- ASCII allowed -->
  U+007F <!--to U+0084, (U+0085 NEL not allowed), U+0086--> to U+009F, U+FDD0 to U+FDEF, and
  characters U+000B, U+FFFE, U+FFFF, U+1FFFE, U+1FFFF, U+2FFFE, U+2FFFF, U+3FFFE, U+3FFFF, U+4FFFE,
  U+4FFFF, U+5FFFE, U+5FFFF, U+6FFFE, U+6FFFF, U+7FFFE, U+7FFFF, U+8FFFE, U+8FFFF, U+9FFFE, U+9FFFF,
  U+AFFFE, U+AFFFF, U+BFFFE, U+BFFFF, U+CFFFE, U+CFFFF, U+DFFFE, U+DFFFF, U+EFFFE, U+EFFFF, U+FFFFE,
  U+FFFFF, U+10FFFE, and U+10FFFF are <a data-anolis-xref="parse error" href="#parse-error">parse errors</a>. These are all
  <a href="infrastructure.html#control-characters">control characters</a> or permanently undefined Unicode characters (noncharacters).</p>

  <p>Any <a href="infrastructure.html#character">character</a> that is a not a <a href="infrastructure.html#unicode-character">Unicode character</a>, i.e. any isolated
  surrogate, is a <a href="#parse-error">parse error</a>. (These can only find their way into the input stream via
  script APIs such as <code data-anolis-xref="dom-document-write"><a href="webappapis.html#dom-document-write">document.write()</a></code>.)</p>

  <p>"CR" (U+000D) characters and "LF" (U+000A) characters are treated
  specially. All CR characters must be converted to LF characters, and any LF characters that
  immediately follow a CR character must be ignored. Thus, newlines in HTML DOMs are represented by
  LF characters, and there are never any CR characters in the input to the <a href="#tokenization">tokenization</a>
  stage.</p>

  <p>The <dfn id="next-input-character">next input character</dfn> is the first character in the <a href="#input-stream">input stream</a>
  that has not yet been <dfn id="consumed">consumed</dfn> or explicitly ignored by the requirements in this
  section. Initially, the <i><a href="#next-input-character">next input character</a></i> is the first character in the input. The
  <dfn id="current-input-character">current input character</dfn> is the last character to have been <i><a href="#consumed">consumed</a></i>.</p>

  <p>The <dfn id="insertion-point">insertion point</dfn> is the position (just before a character or just before the end
  of the input stream) where content inserted using <code data-anolis-xref="dom-document-write"><a href="webappapis.html#dom-document-write">document.write()</a></code> is actually inserted. The insertion point is
  relative to the position of the character immediately after it, it is not an absolute offset into
  the input stream. Initially, the insertion point is undefined.</p>

  <p>The "EOF" character in the tables below is a conceptual character representing the end of the
  <a href="#input-stream">input stream</a>. If the parser is a <a href="webappapis.html#script-created-parser">script-created parser</a>, then the end of
  the <a href="#input-stream">input stream</a> is reached when an <dfn id="explicit-eof-character">explicit "EOF" character</dfn> (inserted by
  the <code data-anolis-xref="dom-document-close"><a href="webappapis.html#dom-document-close">document.close()</a></code> method) is consumed. Otherwise, the
  "EOF" character is not a real character in the stream, but rather the lack of any further
  characters.</p>

  <p class="note">The handling of U+0000 NULL characters varies based on where the characters are
  found. In general, they are ignored except where doing so could plausibly introduce an attack
  vector. This handling is, by necessity, spread across both the tokenization stage and the tree
  construction stage.</p>

  </div>


  <div class="impl">

  <h4 id="parse-state"><span class="secno">8.2.3 </span>Parse state</h4>

  <h5 id="the-insertion-mode"><span class="secno">8.2.3.1 </span>The insertion mode</h5>

  <p>The <dfn id="insertion-mode">insertion mode</dfn> is a state variable that controls the primary operation of the
  tree construction stage.</p>

  <p>Initially, the <a href="#insertion-mode">insertion mode</a> is "<a data-anolis-xref="insertion mode:
  initial" href="#the-initial-insertion-mode">initial</a>". It can change to "<a data-anolis-xref="insertion mode: before html" href="#the-before-html-insertion-mode">before
  html</a>", "<a data-anolis-xref="insertion mode: before head" href="#the-before-head-insertion-mode">before head</a>", "<a data-anolis-xref="insertion mode: in head" href="#parsing-main-inhead">in head</a>", "<a data-anolis-xref="insertion mode: in head
  noscript" href="#parsing-main-inheadnoscript">in head noscript</a>", "<a data-anolis-xref="insertion mode: after head" href="#the-after-head-insertion-mode">after head</a>",
  "<a data-anolis-xref="insertion mode: in body" href="#parsing-main-inbody">in body</a>", "<a data-anolis-xref="insertion mode:
  text" href="#parsing-main-incdata">text</a>", "<a data-anolis-xref="insertion mode: in table" href="#parsing-main-intable">in table</a>", "<a data-anolis-xref="insertion mode: in table text" href="#parsing-main-intabletext">in table text</a>", "<a data-anolis-xref="insertion mode: in
  caption" href="#parsing-main-incaption">in caption</a>", "<a data-anolis-xref="insertion mode: in column group" href="#parsing-main-incolgroup">in column
  group</a>", "<a data-anolis-xref="insertion mode: in table body" href="#parsing-main-intbody">in table body</a>", "<a data-anolis-xref="insertion mode: in row" href="#parsing-main-intr">in row</a>", "<a data-anolis-xref="insertion mode: in cell" href="#parsing-main-intd">in
  cell</a>", "<a data-anolis-xref="insertion mode: in select" href="#parsing-main-inselect">in select</a>", "<a data-anolis-xref="insertion
  mode: in select in table" href="#parsing-main-inselectintable">in select in table</a>", "<a data-anolis-xref="insertion mode: in
  template" href="#parsing-main-intemplate">in template</a>", "<a data-anolis-xref="insertion mode: after body" href="#parsing-main-afterbody">after body</a>",
  "<a data-anolis-xref="insertion mode: in frameset" href="#parsing-main-inframeset">in frameset</a>", "<a data-anolis-xref="insertion mode:
  after frameset" href="#parsing-main-afterframeset">after frameset</a>", "<a data-anolis-xref="insertion mode: after after body" href="#the-after-after-body-insertion-mode">after
  after body</a>", and "<a data-anolis-xref="insertion mode: after after frameset" href="#the-after-after-frameset-insertion-mode">after after
  frameset</a>" during the course of the parsing, as described in the <a href="#tree-construction">tree
  construction</a> stage. The insertion mode affects how tokens are processed and whether CDATA
  sections are supported.</p>

  <p>Several of these modes, namely "<a data-anolis-xref="insertion mode: in head" href="#parsing-main-inhead">in head</a>", "<a data-anolis-xref="insertion mode: in body" href="#parsing-main-inbody">in body</a>", "<a data-anolis-xref="insertion mode: in table" href="#parsing-main-intable">in
  table</a>", and "<a data-anolis-xref="insertion mode: in select" href="#parsing-main-inselect">in select</a>", are special, in
  that the other modes defer to them at various times. When the algorithm below says that the user
  agent is to do something "<dfn id="using-the-rules-for">using the rules for</dfn> the <var data-anolis-xref="">m</var> insertion
  mode", where <var data-anolis-xref="">m</var> is one of these modes, the user agent must use the rules
  described under the <var data-anolis-xref="">m</var> <a href="#insertion-mode">insertion mode</a>'s section, but must leave
  the <a href="#insertion-mode">insertion mode</a> unchanged unless the rules in <var data-anolis-xref="">m</var> themselves
  switch the <a href="#insertion-mode">insertion mode</a> to a new value.</p>

  <p>When the insertion mode is switched to "<a data-anolis-xref="insertion mode: text" href="#parsing-main-incdata">text</a>" or
  "<a data-anolis-xref="insertion mode: in table text" href="#parsing-main-intabletext">in table text</a>", the <dfn id="original-insertion-mode">original insertion
  mode</dfn> is also set. This is the insertion mode to which the tree construction stage will
  return.</p>

  <p>Similarly, to parse nested <code><a href="scripting-1.html#the-template-element">template</a></code> elements, a <dfn id="stack-of-template-insertion-modes">stack of template insertion
  modes</dfn> is used. It is initially empty. The <dfn id="current-template-insertion-mode">current template insertion mode</dfn> is the
  insertion mode that was most recently added to the <a href="#stack-of-template-insertion-modes">stack of template insertion modes</a>.
  The algorithms in the sections below will <i>push</i> insertion modes onto this stack, meaning
  that the specified insertion mode is to be added to the stack, and <i>pop</i> insertion modes from
  the stack, which means that the most recently added insertion mode must be removed from the
  stack.</p>

  <hr><p>When the steps below require the UA to <dfn id="reset-the-insertion-mode-appropriately">reset the insertion mode appropriately</dfn>, it
  means the UA must follow these steps:</p>

  <ol><li><p>Let <var data-anolis-xref="">last</var> be false.</li>

   <li><p>Let <var data-anolis-xref="">node</var> be the last node in the <a href="#stack-of-open-elements">stack of open
   elements</a>.</li>

<!--CLEANUP-->
   <li><p><i>Loop</i>: If <var data-anolis-xref="">node</var> is the first node in the stack of open elements,
   then set <var data-anolis-xref="">last</var> to true, and, if the parser was originally created as part of
   the <a href="#html-fragment-parsing-algorithm">HTML fragment parsing algorithm</a> (<a href="#fragment-case">fragment case</a>) set <var data-anolis-xref="">node</var> to the <var data-anolis-xref="concept-frag-parse-context"><a href="#concept-frag-parse-context">context</a></var> element.</li>

   <li>

    <p>If <var data-anolis-xref="">node</var> is a <code><a href="forms.html#the-select-element">select</a></code> element, run these substeps:</p>

    <ol><li><p>If <var data-anolis-xref="">last</var> is true, jump to the step below labeled
     <i>done</i>.</li>

     <li><p>Let <var data-anolis-xref="">ancestor</var> be <var data-anolis-xref="">node</var>.</li>

     <li><p><i>Loop</i>: If <var data-anolis-xref="">ancestor</var> is the first node in the <a href="#stack-of-open-elements">stack of
     open elements</a>, jump to the step below labeled <i>done</i>.</li>

     <li><p>Let <var data-anolis-xref="">ancestor</var> be the node before <var data-anolis-xref="">ancestor</var> in the
     <a href="#stack-of-open-elements">stack of open elements</a>.</li>

     <li><p>If <var data-anolis-xref="">ancestor</var> is a <code><a href="scripting-1.html#the-template-element">template</a></code> node, jump to the step below
     labeled <i>done</i>.</li>

     <li><p>If <var data-anolis-xref="">ancestor</var> is a <code><a href="tabular-data.html#the-table-element">table</a></code> node, switch the <a href="#insertion-mode">insertion
     mode</a> to "<a data-anolis-xref="insertion mode: in select in table" href="#parsing-main-inselectintable">in select in table</a>" and
     abort these steps.</li> <!-- consider
     <table><tr><td><select><template></template><caption></table>
     http://software.hixie.ch/utilities/js/live-dom-viewer/saved/2374 -->

     <li><p>Jump back to the step labeled <i>loop</i>.</li>

     <li><p><i>Done</i>: Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in
     select" href="#parsing-main-inselect">in select</a>" and abort these steps.</li>

    </ol></li>

   <li><p>If <var data-anolis-xref="">node</var> is a <code><a href="tabular-data.html#the-td-element">td</a></code> or <code><a href="tabular-data.html#the-th-element">th</a></code> element and <var data-anolis-xref="">last</var> is false, then switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in cell" href="#parsing-main-intd">in cell</a>" and abort these steps.</li>

   <li><p>If <var data-anolis-xref="">node</var> is a <code><a href="tabular-data.html#the-tr-element">tr</a></code> element, then switch the <a href="#insertion-mode">insertion
   mode</a> to "<a data-anolis-xref="insertion mode: in row" href="#parsing-main-intr">in row</a>" and abort these
   steps.</li>

   <li><p>If <var data-anolis-xref="">node</var> is a <code><a href="tabular-data.html#the-tbody-element">tbody</a></code>, <code><a href="tabular-data.html#the-thead-element">thead</a></code>, or
   <code><a href="tabular-data.html#the-tfoot-element">tfoot</a></code> element, then switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in table body" href="#parsing-main-intbody">in table body</a>" and abort these steps.</li>

   <li><p>If <var data-anolis-xref="">node</var> is a <code><a href="tabular-data.html#the-caption-element">caption</a></code> element, then switch the
   <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in caption" href="#parsing-main-incaption">in caption</a>" and
   abort these steps.</li>

   <li><p>If <var data-anolis-xref="">node</var> is a <code><a href="tabular-data.html#the-colgroup-element">colgroup</a></code> element, then switch the
   <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in column group" href="#parsing-main-incolgroup">in column
   group</a>" and abort these steps.</li>

   <li><p>If <var data-anolis-xref="">node</var> is a <code><a href="tabular-data.html#the-table-element">table</a></code> element, then switch the
   <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in table" href="#parsing-main-intable">in table</a>" and abort
   these steps.</li>

   <li><p>If <var data-anolis-xref="">node</var> is a <code><a href="scripting-1.html#the-template-element">template</a></code> element, then switch the
   <a href="#insertion-mode">insertion mode</a> to the <a href="#current-template-insertion-mode">current template insertion mode</a> and abort these
   steps.</li>

<!--FORK: this is commented out in WHATWG spec-->
   <li>If <var data-anolis-xref="">node</var> is a <code><a href="document-metadata.html#the-head-element">head</a></code> element
   and <var data-anolis-xref="">last</var> is true,
   then switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in body" href="#parsing-main-inbody">in body</a>" ("<a data-anolis-xref="insertion mode: in body" href="#parsing-main-inbody">in body</a>"! <em> not "<a data-anolis-xref="insertion mode: in head" href="#parsing-main-inhead">in head</a>"</em>!) and abort
   these steps. (<a href="#fragment-case">fragment case</a>)</li>
<!-- The above is only here in case people think that the spec accidentally omitted it and try to
        "fix" it. Note that noscript-in-head is also handled this way. This is all intentional. The
        only thing it doesn't handle is the scripting-disabled fragment parsing case for a <head>
        element containing a <noscript> which itself contains something other than a <link> or a
        <style> element; you'd expect that to break out of the <noscript> but it doesn't. This is an
        edge case that doesn't affect the spec, since the algorithm for fragment parsing is only
        used for innerHTML/outerHTML/insertAdjacentHTML(), where we know scripting is enabled. -->

   <li><p>If <var data-anolis-xref="">node</var> is a <code><a href="document-metadata.html#the-head-element">head</a></code> element and <var data-anolis-xref="">last</var> is
   false, then switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in head" href="#parsing-main-inhead">in
   head</a>" and abort these steps.</li> <!-- for the case of <head><template></template>...
   -->

   <li><p>If <var data-anolis-xref="">node</var> is a <code><a href="sections.html#the-body-element">body</a></code> element, then switch the
   <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in body" href="#parsing-main-inbody">in body</a>" and abort
   these steps.</li>

   <li><p>If <var data-anolis-xref="">node</var> is a <code><a href="obsolete.html#frameset">frameset</a></code> element, then switch the
   <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in frameset" href="#parsing-main-inframeset">in frameset</a>" and
   abort these steps. (<a href="#fragment-case">fragment case</a>)</li>

   <li>

    <p>If <var data-anolis-xref="">node</var> is an <code><a href="semantics.html#the-html-element">html</a></code> element, run these substeps:</p>
   
    <ol><li><p>If the <a href="#head-element-pointer"><code>head</code> element pointer</a> is null, switch the
     <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: before head" href="#the-before-head-insertion-mode">before head</a>"
     and abort these steps. (<a href="#fragment-case">fragment case</a>)</li>

     <li><p>Otherwise, the <a href="#head-element-pointer"><code>head</code> element pointer</a> is not null, switch the
     <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: after head" href="#the-after-head-insertion-mode">after head</a>" and
     abort these steps.</li> <!-- consider <html><head></head><template></template> -->

    </ol></li>

   <li><p>If <var data-anolis-xref="">last</var> is true, then switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in body" href="#parsing-main-inbody">in body</a>" and abort these steps. (<a href="#fragment-case">fragment
   case</a>)</li>

   <li><p>Let <var data-anolis-xref="">node</var> now be the node before <var data-anolis-xref="">node</var> in the
   <a href="#stack-of-open-elements">stack of open elements</a>.</li>

   <li><p>Return to the step labeled <i>loop</i>.</li>

  </ol><h5 id="the-stack-of-open-elements"><span class="secno">8.2.3.2 </span>The stack of open elements</h5>

  <p>Initially, the <dfn id="stack-of-open-elements">stack of open elements</dfn> is empty. The stack grows downwards; the
  topmost node on the stack is the first one added to the stack, and the bottommost node of the
  stack is the most recently added node in the stack (notwithstanding when the stack is manipulated
  in a random access fashion as part of <a href="#adoptionAgency">the handling for misnested
  tags</a>).</p>

  <p class="note">The "<a data-anolis-xref="insertion mode: before html" href="#the-before-html-insertion-mode">before html</a>" <a href="#insertion-mode">insertion
  mode</a> creates the <code><a href="semantics.html#the-html-element">html</a></code> root element node, which is then added to the stack.</p>

  <p class="note">In the <a href="#fragment-case">fragment case</a>, the <a href="#stack-of-open-elements">stack of open elements</a> is
  initialized to contain an <code><a href="semantics.html#the-html-element">html</a></code> element that is created as part of <a data-anolis-xref="html
  fragment parsing algorithm" href="#html-fragment-parsing-algorithm">that algorithm</a>. (The <a href="#fragment-case">fragment case</a> skips the
  "<a data-anolis-xref="insertion mode: before html" href="#the-before-html-insertion-mode">before html</a>" <a href="#insertion-mode">insertion mode</a>.)</p>

  <p>The <code><a href="semantics.html#the-html-element">html</a></code> node, however it is created, is the topmost node of the stack. It only
  gets popped off the stack when the parser <a data-anolis-xref="stop parsing" href="#stop-parsing">finishes</a>.</p>

  <p>The <dfn id="current-node">current node</dfn> is the bottommost node in this <a href="#stack-of-open-elements">stack of open
  elements</a>.</p>

  <p>The <dfn id="adjusted-current-node">adjusted current node</dfn> is the <i data-anolis-xref="concept-frag-parse-context"><a href="#concept-frag-parse-context">context</a></i>
  element if the <a href="#stack-of-open-elements">stack of open elements</a> has only one element in it and the parser was
  created by the <a href="#html-fragment-parsing-algorithm">HTML fragment parsing algorithm</a>; otherwise, the <a href="#adjusted-current-node">adjusted current
  node</a> is the <a href="#current-node">current node</a>.</p>

  <p>Elements in the <a href="#stack-of-open-elements">stack of open elements</a> fall into the following categories:</p>

  <dl><dt><dfn id="special">Special</dfn></dt>

   <dd><p>The following elements have varying levels of special parsing rules: HTML's
   <code><a href="sections.html#the-address-element">address</a></code>, <code><a href="obsolete.html#the-applet-element">applet</a></code>, <code><a href="embedded-content-0.html#the-area-element">area</a></code>, <code><a href="sections.html#the-article-element">article</a></code>,
   <code><a href="sections.html#the-aside-element">aside</a></code>, <code><a href="document-metadata.html#the-base-element">base</a></code>, <code><a href="obsolete.html#basefont">basefont</a></code>, <code><a href="obsolete.html#bgsound">bgsound</a></code>,
   <code><a href="grouping-content.html#the-blockquote-element">blockquote</a></code>, <code><a href="sections.html#the-body-element">body</a></code>, <code><a href="text-level-semantics.html#the-br-element">br</a></code>, <code><a href="forms.html#the-button-element">button</a></code>,
   <code><a href="tabular-data.html#the-caption-element">caption</a></code>, <code><a href="obsolete.html#center">center</a></code>, <code><a href="tabular-data.html#the-col-element">col</a></code>, <code><a href="tabular-data.html#the-colgroup-element">colgroup</a></code>,
   <code><a href="grouping-content.html#the-dd-element">dd</a></code>, <code>details</code>, <code><a href="obsolete.html#dir">dir</a></code>, <code><a href="grouping-content.html#the-div-element">div</a></code>, <code><a href="grouping-content.html#the-dl-element">dl</a></code>,
   <code><a href="grouping-content.html#the-dt-element">dt</a></code>, <code><a href="embedded-content-0.html#the-embed-element">embed</a></code>, <code><a href="forms.html#the-fieldset-element">fieldset</a></code>, <code><a href="grouping-content.html#the-figcaption-element">figcaption</a></code>,
   <code><a href="grouping-content.html#the-figure-element">figure</a></code>, <code><a href="sections.html#the-footer-element">footer</a></code>, <code><a href="forms.html#the-form-element">form</a></code>, <code><a href="obsolete.html#frame">frame</a></code>,
   <code><a href="obsolete.html#frameset">frameset</a></code>, <code><a href="sections.html#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements">h1</a></code>, <code><a href="sections.html#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements">h2</a></code>, <code><a href="sections.html#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements">h3</a></code>, <code><a href="sections.html#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements">h4</a></code>,
   <code><a href="sections.html#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements">h5</a></code>, <code><a href="sections.html#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements">h6</a></code>, <code><a href="document-metadata.html#the-head-element">head</a></code>, <code><a href="sections.html#the-header-element">header</a></code>, <code><a href="obsolete.html#hgroup">hgroup</a></code>,
   <code><a href="grouping-content.html#the-hr-element">hr</a></code>, <code><a href="semantics.html#the-html-element">html</a></code>, <code><a href="embedded-content-0.html#the-iframe-element">iframe</a></code>, <!-- <code>image</code>, (commented out
   because this isn't an element that can end up on the stack, so it doesn't matter) -->
   <code><a href="embedded-content-0.html#the-img-element">img</a></code>, <code><a href="forms.html#the-input-element">input</a></code>, <code><a href="obsolete.html#isindex-0">isindex</a></code>, <code><a href="grouping-content.html#the-li-element">li</a></code>, <code><a href="document-metadata.html#the-link-element">link</a></code>,
   <code><a href="obsolete.html#listing">listing</a></code>, <code><a href="grouping-content.html#the-main-element">main</a></code>, <code><a href="obsolete.html#the-marquee-element-0">marquee</a></code>,
   <code><a href="document-metadata.html#the-meta-element">meta</a></code>, <code><a href="sections.html#the-nav-element">nav</a></code>, <code><a href="obsolete.html#noembed">noembed</a></code>,
   <code><a href="obsolete.html#noframes">noframes</a></code>, <code><a href="scripting-1.html#the-noscript-element">noscript</a></code>, <code><a href="embedded-content-0.html#the-object-element">object</a></code>, <code><a href="grouping-content.html#the-ol-element">ol</a></code>,
   <code><a href="grouping-content.html#the-p-element">p</a></code>, <code><a href="embedded-content-0.html#the-param-element">param</a></code>, <code><a href="obsolete.html#plaintext">plaintext</a></code>, <code><a href="grouping-content.html#the-pre-element">pre</a></code>,
   <code><a href="scripting-1.html#the-script-element">script</a></code>, <code><a href="sections.html#the-section-element">section</a></code>, <code><a href="forms.html#the-select-element">select</a></code>, <code><a href="embedded-content-0.html#the-source-element">source</a></code>,
   <code><a href="document-metadata.html#the-style-element">style</a></code>, <code>summary</code>, <code><a href="tabular-data.html#the-table-element">table</a></code>, <code><a href="tabular-data.html#the-tbody-element">tbody</a></code>,
   <code><a href="tabular-data.html#the-td-element">td</a></code>, <code><a href="scripting-1.html#the-template-element">template</a></code>, <code><a href="forms.html#the-textarea-element">textarea</a></code>, <code><a href="tabular-data.html#the-tfoot-element">tfoot</a></code>,
   <code><a href="tabular-data.html#the-th-element">th</a></code>, <code><a href="tabular-data.html#the-thead-element">thead</a></code>, <code><a href="document-metadata.html#the-title-element">title</a></code>, <code><a href="tabular-data.html#the-tr-element">tr</a></code>, <code><a href="embedded-content-0.html#the-track-element">track</a></code>,
   <code><a href="grouping-content.html#the-ul-element">ul</a></code>, <code><a href="text-level-semantics.html#the-wbr-element">wbr</a></code>, and <code><a href="obsolete.html#xmp">xmp</a></code>; MathML's <code data-anolis-xref="">mi</code>, <code data-anolis-xref="">mo</code>, <code data-anolis-xref="">mn</code>, <code data-anolis-xref="">ms</code>, <code data-anolis-xref="">mtext</code>, and <code data-anolis-xref="">annotation-xml</code>; and SVG's <code data-anolis-xref="">foreignObject</code>, <code data-anolis-xref="">desc</code>, and <code data-anolis-xref="">title</code>.</dd> <!-- we could actually put all non-HTML elements in this list, I
   think -->

   <dt><dfn id="formatting">Formatting</dfn></dt>
   <dd><p>The following HTML elements are those that end up in the <a href="#list-of-active-formatting-elements">list of active formatting
   elements</a>: <code><a href="text-level-semantics.html#the-a-element">a</a></code>, <code><a href="text-level-semantics.html#the-b-element">b</a></code>, <code><a href="obsolete.html#big">big</a></code>, <code><a href="text-level-semantics.html#the-code-element">code</a></code>,
   <code><a href="text-level-semantics.html#the-em-element">em</a></code>, <code><a href="obsolete.html#font">font</a></code>, <code><a href="text-level-semantics.html#the-i-element">i</a></code>, <code><a href="obsolete.html#nobr">nobr</a></code>, <code><a href="text-level-semantics.html#the-s-element">s</a></code>,
   <code><a href="text-level-semantics.html#the-small-element">small</a></code>, <code><a href="obsolete.html#strike">strike</a></code>, <code><a href="text-level-semantics.html#the-strong-element">strong</a></code>, <code><a href="obsolete.html#tt">tt</a></code>, and
   <code><a href="text-level-semantics.html#the-u-element">u</a></code>.</dd>

   <dt><dfn id="ordinary">Ordinary</dfn></dt>
   <dd><p>All other elements found while parsing an HTML document.</dd>

  </dl><p>The <a href="#stack-of-open-elements">stack of open elements</a> is said to <dfn data-anolis-xref="has an element in the specific
  scope" id="has-an-element-in-the-specific-scope">have an element <var data-anolis-xref="">target node</var> in a specific scope</dfn> consisting of a
  list of element types <var data-anolis-xref="">list</var> when the following algorithm terminates in a match
  state:</p>

  <ol><li><p>Initialize <var data-anolis-xref="">node</var> to be the <a href="#current-node">current node</a> (the bottommost
   node of the stack).</li>

   <li><p>If <var data-anolis-xref="">node</var> is the target node, terminate in a match state.</li>

   <li><p>Otherwise, if <var data-anolis-xref="">node</var> is one of the element types in <var data-anolis-xref="">list</var>, terminate in a failure state.</li>

   <li><p>Otherwise, set <var data-anolis-xref="">node</var> to the previous entry in the <a href="#stack-of-open-elements">stack of open
   elements</a> and return to step 2. (This will never fail, since the loop will always terminate
   in the previous step if the top of the stack — an <code><a href="semantics.html#the-html-element">html</a></code> element — is
   reached.)</li>

  </ol><p>The <a href="#stack-of-open-elements">stack of open elements</a> is said to <dfn data-anolis-xref="has an element in scope" id="has-an-element-in-scope">have a
  particular element in scope</dfn> when it <a data-anolis-xref="has an element in the specific scope" href="#has-an-element-in-the-specific-scope">has
  that element in the specific scope</a> consisting of the following element types:</p>

  <ul class="brief"><li><code><a href="obsolete.html#the-applet-element">applet</a></code> in the <a href="infrastructure.html#html-namespace-0">HTML namespace</a></li>
   <li><code><a href="tabular-data.html#the-caption-element">caption</a></code> in the <a href="infrastructure.html#html-namespace-0">HTML namespace</a></li>
   <li><code><a href="semantics.html#the-html-element">html</a></code> in the <a href="infrastructure.html#html-namespace-0">HTML namespace</a></li> <!-- (This can only happen if the <var data-x="">node</var> is the topmost node of the <span>stack of open elements</span>, and prevents the next step from being invoked if there are no more elements in the stack.) -->
   <li><code><a href="tabular-data.html#the-table-element">table</a></code> in the <a href="infrastructure.html#html-namespace-0">HTML namespace</a></li>
   <li><code><a href="tabular-data.html#the-td-element">td</a></code> in the <a href="infrastructure.html#html-namespace-0">HTML namespace</a></li>
   <li><code><a href="tabular-data.html#the-th-element">th</a></code> in the <a href="infrastructure.html#html-namespace-0">HTML namespace</a></li>
   <li><code><a href="obsolete.html#the-marquee-element-0">marquee</a></code> in the <a href="infrastructure.html#html-namespace-0">HTML namespace</a></li>
   <li><code><a href="embedded-content-0.html#the-object-element">object</a></code> in the <a href="infrastructure.html#html-namespace-0">HTML namespace</a></li>
   <li><code><a href="scripting-1.html#the-template-element">template</a></code> in the <a href="infrastructure.html#html-namespace-0">HTML namespace</a></li>
   <li><code data-anolis-xref="">mi</code> in the <a href="infrastructure.html#mathml-namespace">MathML namespace</a></li>
   <li><code data-anolis-xref="">mo</code> in the <a href="infrastructure.html#mathml-namespace">MathML namespace</a></li>
   <li><code data-anolis-xref="">mn</code> in the <a href="infrastructure.html#mathml-namespace">MathML namespace</a></li>
   <li><code data-anolis-xref="">ms</code> in the <a href="infrastructure.html#mathml-namespace">MathML namespace</a></li>
   <li><code data-anolis-xref="">mtext</code> in the <a href="infrastructure.html#mathml-namespace">MathML namespace</a></li>
   <li><code data-anolis-xref="">annotation-xml</code> in the <a href="infrastructure.html#mathml-namespace">MathML namespace</a></li>
   <li><code data-anolis-xref="">foreignObject</code> in the <a href="infrastructure.html#svg-namespace">SVG namespace</a></li>
   <li><code data-anolis-xref="">desc</code> in the <a href="infrastructure.html#svg-namespace">SVG namespace</a></li>
   <li><code data-anolis-xref="">title</code> in the <a href="infrastructure.html#svg-namespace">SVG namespace</a></li>
  </ul><p>The <a href="#stack-of-open-elements">stack of open elements</a> is said to <dfn data-anolis-xref="has an element in list item
  scope" id="has-an-element-in-list-item-scope">have a particular element in list item scope</dfn> when it <a data-anolis-xref="has an element in
  the specific scope" href="#has-an-element-in-the-specific-scope">has that element in the specific scope</a> consisting of the following
  element types:</p>

  <ul class="brief"><li>All the element types listed above for the <i><a href="#has-an-element-in-scope">has an element in scope</a></i> algorithm.</li>
   <li><code><a href="grouping-content.html#the-ol-element">ol</a></code> in the <a href="infrastructure.html#html-namespace-0">HTML namespace</a></li>
   <li><code><a href="grouping-content.html#the-ul-element">ul</a></code> in the <a href="infrastructure.html#html-namespace-0">HTML namespace</a></li>
  </ul><p>The <a href="#stack-of-open-elements">stack of open elements</a> is said to <dfn data-anolis-xref="has an element in button
  scope" id="has-an-element-in-button-scope">have a particular element in button scope</dfn> when it <a data-anolis-xref="has an element in the
  specific scope" href="#has-an-element-in-the-specific-scope">has that element in the specific scope</a> consisting of the following element
  types:</p>

  <ul class="brief"><li>All the element types listed above for the <i><a href="#has-an-element-in-scope">has an element in scope</a></i> algorithm.</li>
   <li><code><a href="forms.html#the-button-element">button</a></code> in the <a href="infrastructure.html#html-namespace-0">HTML namespace</a></li>
  </ul><p>The <a href="#stack-of-open-elements">stack of open elements</a> is said to <dfn data-anolis-xref="has an element in table
  scope" id="has-an-element-in-table-scope">have a particular element in table scope</dfn> when it <a data-anolis-xref="has an element in the
  specific scope" href="#has-an-element-in-the-specific-scope">has that element in the specific scope</a> consisting of the following element
  types:</p>

  <ul class="brief"><li><code><a href="semantics.html#the-html-element">html</a></code> in the <a href="infrastructure.html#html-namespace-0">HTML namespace</a></li> <!-- (This can only happen if the
   <var data-x="">node</var> is the topmost node of the <span>stack of open elements</span>, and
   prevents the next step from being invoked if there are no more elements in the stack.) -->
   <li><code><a href="tabular-data.html#the-table-element">table</a></code> in the <a href="infrastructure.html#html-namespace-0">HTML namespace</a></li>
   <li><code><a href="scripting-1.html#the-template-element">template</a></code> in the <a href="infrastructure.html#html-namespace-0">HTML namespace</a></li>
  </ul><p>The <a href="#stack-of-open-elements">stack of open elements</a> is said to <dfn data-anolis-xref="has an element in select
  scope" id="has-an-element-in-select-scope">have a particular element in select scope</dfn> when it <a data-anolis-xref="has an element in the
  specific scope" href="#has-an-element-in-the-specific-scope">has that element in the specific scope</a> consisting of all element types
  <em>except</em> the following:</p>

  <ul class="brief"><!--<li><code>select</code> in the <span>HTML namespace</span></li>--><li><code><a href="forms.html#the-optgroup-element">optgroup</a></code> in the <a href="infrastructure.html#html-namespace-0">HTML namespace</a></li>
   <li><code><a href="forms.html#the-option-element">option</a></code> in the <a href="infrastructure.html#html-namespace-0">HTML namespace</a></li>
  </ul><p>Nothing happens if at any time any of the elements in the <a href="#stack-of-open-elements">stack of open elements</a>
  are moved to a new location in, or removed from, the <code><a href="dom.html#document">Document</a></code> tree. In particular,
  the stack is not changed in this situation. This can cause, amongst other strange effects, content
  to be appended to nodes that are no longer in the DOM.</p>

  <p class="note">In some cases (namely, when <a href="#adoptionAgency">closing misnested formatting
  elements</a>), the stack is manipulated in a random-access fashion.</p>


  <h5 id="the-list-of-active-formatting-elements"><span class="secno">8.2.3.3 </span>The list of active formatting elements</h5>

  <p>Initially, the <dfn id="list-of-active-formatting-elements">list of active formatting elements</dfn> is empty. It is used to handle
  mis-nested <a data-anolis-xref="formatting" href="#formatting">formatting element tags</a>.</p>

  <p>The list contains elements in the <a href="#formatting">formatting</a> category, and scope markers. The
  scope markers are inserted when entering <code><a href="obsolete.html#the-applet-element">applet</a></code> elements, buttons,
  <code><a href="embedded-content-0.html#the-object-element">object</a></code> elements, marquees, table cells, and table captions, and are used to prevent
  formatting from "leaking" <em>into</em> <code><a href="obsolete.html#the-applet-element">applet</a></code> elements, buttons, <code><a href="embedded-content-0.html#the-object-element">object</a></code>
  elements, marquees, and tables.</p>

  <p class="note">The scope markers are unrelated to the concept of an element being <a data-anolis-xref="has an element in scope" href="#has-an-element-in-scope">in scope</a>.</p>

  <p>In addition, each element in the <a href="#list-of-active-formatting-elements">list of active formatting elements</a> is associated
  with the token for which it was created, so that further elements can be created for that token if
  necessary.</p>

  <p>When the steps below require the UA to <dfn id="push-onto-the-list-of-active-formatting-elements">push onto the list of active formatting
  elements</dfn> an element <var data-anolis-xref="">element</var>, the UA must perform the following
  steps:</p>

  <ol id="noah"><li><p>If there are already three elements in the <a href="#list-of-active-formatting-elements">list of active formatting elements</a>
   after the last list marker, if any, or anywhere in the list if there are no list markers, that
   have the same tag name, namespace, and attributes as <var data-anolis-xref="">element</var>, then remove the
   earliest such element from the <a href="#list-of-active-formatting-elements">list of active formatting elements</a>. For these
   purposes, the attributes must be compared as they were when the elements were created by the
   parser; two elements have the same attributes if all their parsed attributes can be paired such
   that the two attributes in each pair have identical names, namespaces, and values (the order of
   the attributes does not matter).</p>

   <p class="note">This is the Noah's Ark clause. But with three per family instead of two.</li>
   <!-- A sort of polyamorous Noah's Ark, if you will. -->

   <li><p>Add <var data-anolis-xref="">element</var> to the <a href="#list-of-active-formatting-elements">list of active formatting
   elements</a>.</li>

  </ol><p>When the steps below require the UA to <dfn id="reconstruct-the-active-formatting-elements">reconstruct the active formatting elements</dfn>,
  the UA must perform the following steps:</p>

  <ol><li><p>If there are no entries in the <a href="#list-of-active-formatting-elements">list of active formatting elements</a>, then there
   is nothing to reconstruct; stop this algorithm.</li>

   <li><p>If the last (most recently added) entry in the <a href="#list-of-active-formatting-elements">list of active formatting
   elements</a> is a marker, or if it is an element that is in the <a href="#stack-of-open-elements">stack of open
   elements</a>, then there is nothing to reconstruct; stop this algorithm.</li>

   <li><p>Let <var data-anolis-xref="">entry</var> be the last (most recently added) element in the <a href="#list-of-active-formatting-elements">list
   of active formatting elements</a>.</li>

   <li><p><i>Rewind</i>: If there are no entries before <var data-anolis-xref="">entry</var> in the <a href="#list-of-active-formatting-elements">list
   of active formatting elements</a>, then jump to the step labeled <i>create</i>.</li>

   <li><p>Let <var data-anolis-xref="">entry</var> be the entry one earlier than <var data-anolis-xref="">entry</var> in
   the <a href="#list-of-active-formatting-elements">list of active formatting elements</a>.</li>

   <li><p>If <var data-anolis-xref="">entry</var> is neither a marker nor an element that is also in the
   <a href="#stack-of-open-elements">stack of open elements</a>, go to the step labeled <i>rewind</i>.</li>

   <li><p><i>Advance</i>: Let <var data-anolis-xref="">entry</var> be the element one later than <var data-anolis-xref="">entry</var> in the <a href="#list-of-active-formatting-elements">list of active formatting elements</a>.</li>

   <li><p><i>Create</i>: <a href="#insert-an-html-element">Insert an HTML element</a> for the token for which the element
   <var data-anolis-xref="">entry</var> was created, to obtain <var data-anolis-xref="">new element</var>.</li>

   <li><p>Replace the entry for <var data-anolis-xref="">entry</var> in the list with an entry for <var data-anolis-xref="">new element</var>.</li>

   <li><p>If the entry for <var data-anolis-xref="">new element</var> in the <a href="#list-of-active-formatting-elements">list of active formatting
   elements</a> is not the last entry in the list, return to the step labeled
   <i>advance</i>.</li>

  </ol><p>This has the effect of reopening all the formatting elements that were opened in the current
  body, cell, or caption (whichever is youngest) that haven't been explicitly closed.</p>

  <p class="note">The way this specification is written, the <a href="#list-of-active-formatting-elements">list of active formatting
  elements</a> always consists of elements in chronological order with the least recently added
  element first and the most recently added element last (except for while steps 8 to 11 of the
  above algorithm are being executed, of course).</p>

  <p>When the steps below require the UA to <dfn id="clear-the-list-of-active-formatting-elements-up-to-the-last-marker">clear the list of active formatting elements up to
  the last marker</dfn>, the UA must perform the following steps:</p>

  <ol><li><p>Let <var data-anolis-xref="">entry</var> be the last (most recently added) entry in the <a href="#list-of-active-formatting-elements">list of
   active formatting elements</a>.</li>

   <li><p>Remove <var data-anolis-xref="">entry</var> from the <a href="#list-of-active-formatting-elements">list of active formatting
   elements</a>.</li>

   <li><p>If <var data-anolis-xref="">entry</var> was a marker, then stop the algorithm at this point. The list
   has been cleared up to the last marker.</li>

   <li><p>Go to step 1.</li>

  </ol><h5 id="the-element-pointers"><span class="secno">8.2.3.4 </span>The element pointers</h5>

  <p>Initially, the <dfn id="head-element-pointer"><code data-anolis-xref="">head</code> element pointer</dfn> and the <dfn id="form-element-pointer"><code data-anolis-xref="">form</code> element pointer</dfn> are both null.</p>

  <p>Once a <code><a href="document-metadata.html#the-head-element">head</a></code> element has been parsed (whether implicitly or explicitly) the
  <a href="#head-element-pointer"><code data-anolis-xref="">head</code> element pointer</a> gets set to point to this node.</p>

  <p>The <a href="#form-element-pointer"><code data-anolis-xref="">form</code> element pointer</a> points to the last
  <code><a href="forms.html#the-form-element">form</a></code> element that was opened and whose end tag has not yet been seen. It is used to
  make form controls associate with forms in the face of dramatically bad markup, for historical
  reasons. It is ignored inside <code><a href="scripting-1.html#the-template-element">template</a></code> elements.</p>


  <h5 id="other-parsing-state-flags"><span class="secno">8.2.3.5 </span>Other parsing state flags</h5>

  <p>The <dfn id="scripting-flag">scripting flag</dfn> is set to "enabled" if <a data-anolis-xref="concept-n-script" href="webappapis.html#concept-n-script">scripting
  was enabled</a> for the <code><a href="dom.html#document">Document</a></code> with which the parser is associated when the
  parser was created, and "disabled" otherwise.</p>

  <p class="note">The <a href="#scripting-flag">scripting flag</a> can be enabled even when the parser was originally
  created for the <a href="#html-fragment-parsing-algorithm">HTML fragment parsing algorithm</a>, even though <code><a href="scripting-1.html#the-script-element">script</a></code>
  elements don't execute in that case.</p>

  <p>The <dfn id="frameset-ok-flag">frameset-ok flag</dfn> is set to "ok" when the parser is created. It is set to "not
  ok" after certain tokens are seen.</p>

  </div>


  <div class="impl">

  <h4 id="tokenization"><span class="secno">8.2.4 </span><dfn>Tokenization</dfn></h4>

  <p>Implementations must act as if they used the following state machine to tokenize HTML. The
  state machine must start in the <a href="#data-state">data state</a>. Most states consume a single character,
  which may have various side-effects, and either switches the state machine to a new state to
  <i>reconsume</i> the same character, or switches it to a new state to consume the next character,
  or stays in the same state to consume the next character. Some states have more complicated
  behavior and can consume several characters before switching to another state. In some cases, the
  tokenizer state is also changed by the tree construction stage.</p>

  <p>The exact behavior of certain states depends on the <a href="#insertion-mode">insertion mode</a> and the
  <a href="#stack-of-open-elements">stack of open elements</a>. Certain states also use a <dfn id="temporary-buffer"><var>temporary
  buffer</var></dfn> to track progress.</p>

  <p>The output of the tokenization step is a series of zero or more of the following tokens:
  DOCTYPE, start tag, end tag, comment, character, end-of-file. DOCTYPE tokens have a name, a public
  identifier, a system identifier, and a <i>force-quirks flag</i>. When a DOCTYPE token is created,
  its name, public identifier, and system identifier must be marked as missing (which is a distinct
  state from the empty string), and the <i>force-quirks flag</i> must be set to <i>off</i> (its
  other state is <i>on</i>). Start and end tag tokens have a tag name, a <i>self-closing flag</i>,
  and a list of attributes, each of which has a name and a value. When a start or end tag token is
  created, its <i>self-closing flag</i> must be unset (its other state is that it be set), and its
  attributes list must be empty. Comment and character tokens have data.</p>

  <p>When a token is emitted, it must immediately be handled by the <a href="#tree-construction">tree construction</a>
  stage. The tree construction stage can affect the state of the tokenization stage, and can insert
  additional characters into the stream. (For example, the <code><a href="scripting-1.html#the-script-element">script</a></code> element can result in
  scripts executing and using the <a href="webappapis.html#dynamic-markup-insertion">dynamic markup insertion</a> APIs to insert characters
  into the stream being tokenized.)</p>

  <p class="note">Creating a token and emitting it are distinct actions. It is possible for a token
  to be created but implicitly abandoned (never emitted), e.g. if the file ends unexpectedly while
  processing the characters that are being parsed into a start tag token.</p>

  <p>When a start tag token is emitted with its <i>self-closing flag</i> set, if the flag is not
  <dfn data-anolis-xref="acknowledge self-closing flag" id="acknowledge-self-closing-flag">acknowledged</dfn> when it is processed by the tree
  construction stage, that is a <a href="#parse-error">parse error</a>.</p>

  <p>When an end tag token is emitted with attributes, that is a <a href="#parse-error">parse error</a>.</p>

  <p>When an end tag token is emitted with its <i>self-closing flag</i> set, that is a <a href="#parse-error">parse
  error</a>.</p>

  <p>An <dfn id="appropriate-end-tag-token">appropriate end tag token</dfn> is an end tag token whose tag name matches the tag name
  of the last start tag to have been emitted from this tokenizer, if any. If no start tag has been
  emitted from this tokenizer, then no end tag token is appropriate.</p>

  <p>Before each step of the tokenizer, the user agent must first check the <a href="#parser-pause-flag">parser pause
  flag</a>. If it is true, then the tokenizer must abort the processing of any nested invocations
  of the tokenizer, yielding control back to the caller.</p>

  <p>The tokenizer state machine consists of the states defined in the following subsections.</p>


  <!-- Order of the lists below is supposed to be non-error then error, by unicode, then EOF, ending
  with "anything else" -->


  <h5 id="data-state"><span class="secno">8.2.4.1 </span><dfn>Data state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>U+0026 AMPERSAND (&amp;)</dt>
   <dd>Switch to the <a href="#character-reference-in-data-state">character reference in data state</a>.</dd>

   <dt>"&lt;" (U+003C)</dt>
   <dd>Switch to the <a href="#tag-open-state">tag open state</a>.</dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Emit the <a href="#current-input-character">current input character</a> as a character
   token.</dd>

   <dt>EOF</dt>
   <dd>Emit an end-of-file token.</dd>

   <dt>Anything else</dt>
   <dd>Emit the <a href="#current-input-character">current input character</a> as a character token.</dd>

  </dl><h5 id="character-reference-in-data-state"><span class="secno">8.2.4.2 </span><dfn>Character reference in data state</dfn></h5>

  <p>Switch to the <a href="#data-state">data state</a>.</p>

  <p>Attempt to <a href="#consume-a-character-reference">consume a character reference</a>, with no <a href="#additional-allowed-character">additional allowed
  character</a>.</p>

  <p>If nothing is returned, emit a U+0026 AMPERSAND character (&amp;) token.</p>

  <p>Otherwise, emit the character tokens that were returned.</p>


  <h5 id="rcdata-state"><span class="secno">8.2.4.3 </span><dfn>RCDATA state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>U+0026 AMPERSAND (&amp;)</dt>
   <dd>Switch to the <a href="#character-reference-in-rcdata-state">character reference in RCDATA state</a>.</dd>

   <dt>"&lt;" (U+003C)</dt>
   <dd>Switch to the <a href="#rcdata-less-than-sign-state">RCDATA less-than sign state</a>.</dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Emit a U+FFFD REPLACEMENT CHARACTER character token.</dd>

   <dt>EOF</dt>
   <dd>Emit an end-of-file token.</dd>

   <dt>Anything else</dt>
   <dd>Emit the <a href="#current-input-character">current input character</a> as a character token.</dd>

  </dl><h5 id="character-reference-in-rcdata-state"><span class="secno">8.2.4.4 </span><dfn>Character reference in RCDATA state</dfn></h5>

  <p>Switch to the <a href="#rcdata-state">RCDATA state</a>.</p>

  <p>Attempt to <a href="#consume-a-character-reference">consume a character reference</a>, with no <a href="#additional-allowed-character">additional allowed
  character</a>.</p>

  <p>If nothing is returned, emit a U+0026 AMPERSAND character (&amp;) token.</p>

  <p>Otherwise, emit the character tokens that were returned.</p>


  <h5 id="rawtext-state"><span class="secno">8.2.4.5 </span><dfn>RAWTEXT state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"&lt;" (U+003C)</dt>
   <dd>Switch to the <a href="#rawtext-less-than-sign-state">RAWTEXT less-than sign state</a>.</dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Emit a U+FFFD REPLACEMENT CHARACTER character token.</dd>

   <dt>EOF</dt>
   <dd>Emit an end-of-file token.</dd>

   <dt>Anything else</dt>
   <dd>Emit the <a href="#current-input-character">current input character</a> as a character token.</dd>

  </dl><h5 id="script-data-state"><span class="secno">8.2.4.6 </span><dfn>Script data state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"&lt;" (U+003C)</dt>
   <dd>Switch to the <a href="#script-data-less-than-sign-state">script data less-than sign state</a>.</dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Emit a U+FFFD REPLACEMENT CHARACTER character token.</dd>

   <dt>EOF</dt>
   <dd>Emit an end-of-file token.</dd>

   <dt>Anything else</dt>
   <dd>Emit the <a href="#current-input-character">current input character</a> as a character token.</dd>

  </dl><h5 id="plaintext-state"><span class="secno">8.2.4.7 </span><dfn>PLAINTEXT state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Emit a U+FFFD REPLACEMENT CHARACTER character token.</dd>

   <dt>EOF</dt>
   <dd>Emit an end-of-file token.</dd>

   <dt>Anything else</dt>
   <dd>Emit the <a href="#current-input-character">current input character</a> as a character token.</dd>

  </dl><h5 id="tag-open-state"><span class="secno">8.2.4.8 </span><dfn>Tag open state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"!" (U+0021)</dt>
   <dd>Switch to the <a href="#markup-declaration-open-state">markup declaration open state</a>.</dd>

   <dt>"/" (U+002F)</dt>
   <dd>Switch to the <a href="#end-tag-open-state">end tag open state</a>.</dd>

   <dt><a data-anolis-xref="uppercase ASCII letters" href="infrastructure.html#uppercase-ascii-letters">Uppercase ASCII letter</a></dt>
   <dd>Create a new start tag token, set its tag name to the lowercase version of the <a href="#current-input-character">current
   input character</a> (add 0x0020 to the character's code point), then switch to the <a href="#tag-name-state">tag
   name state</a>. (Don't emit the token yet; further details will be filled in before it is
   emitted.)</dd>

   <dt><a data-anolis-xref="lowercase ASCII letters" href="infrastructure.html#lowercase-ascii-letters">Lowercase ASCII letter</a></dt>
   <dd>Create a new start tag token, set its tag name to the <a href="#current-input-character">current input character</a>,
   then switch to the <a href="#tag-name-state">tag name state</a>. (Don't emit the token yet; further details will
   be filled in before it is emitted.)</dd>

   <dt>"?" (U+003F)</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#bogus-comment-state">bogus comment state</a>.</dd>

   <dt>Anything else</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Emit a U+003C LESS-THAN SIGN
   character token. Reconsume the <a href="#current-input-character">current input character</a>.</dd>

  </dl><h5 id="end-tag-open-state"><span class="secno">8.2.4.9 </span><dfn>End tag open state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt><a data-anolis-xref="uppercase ASCII letters" href="infrastructure.html#uppercase-ascii-letters">Uppercase ASCII letter</a></dt>
   <dd>Create a new end tag token, set its tag name to the lowercase version of the <a href="#current-input-character">current
   input character</a> (add 0x0020 to the character's code point), then switch to the <a href="#tag-name-state">tag
   name state</a>. (Don't emit the token yet; further details will be filled in before it is
   emitted.)</dd>

   <dt><a data-anolis-xref="lowercase ASCII letters" href="infrastructure.html#lowercase-ascii-letters">Lowercase ASCII letter</a></dt>
   <dd>Create a new end tag token, set its tag name to the <a href="#current-input-character">current input character</a>,
   then switch to the <a href="#tag-name-state">tag name state</a>. (Don't emit the token yet; further details will
   be filled in before it is emitted.)</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Emit a U+003C LESS-THAN SIGN
   character token and a U+002F SOLIDUS character token. Reconsume the EOF character.</dd>

   <dt>Anything else</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#bogus-comment-state">bogus comment state</a>.</dd>

  </dl><h5 id="tag-name-state"><span class="secno">8.2.4.10 </span><dfn>Tag name state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"tab" (U+0009)</dt>
   <dt>"LF" (U+000A)</dt>
   <dt>"FF" (U+000C)</dt>
   <!--<dt>"CR" (U+000D)</dt>-->
   <dt>U+0020 SPACE</dt>
   <dd>Switch to the <a href="#before-attribute-name-state">before attribute name state</a>.</dd>

   <dt>"/" (U+002F)</dt>
   <dd>Switch to the <a href="#self-closing-start-tag-state">self-closing start tag state</a>.</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd>Switch to the <a href="#data-state">data state</a>. Emit the current tag token.</dd>

   <dt><a data-anolis-xref="uppercase ASCII letters" href="infrastructure.html#uppercase-ascii-letters">Uppercase ASCII letter</a></dt>
   <dd>Append the lowercase version of the <a href="#current-input-character">current input character</a> (add 0x0020 to the
   character's code point) to the current tag token's tag name.</dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Append a U+FFFD REPLACEMENT CHARACTER character to the current tag
   token's tag name.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Reconsume the EOF
   character.</dd>

   <dt>Anything else</dt>
   <dd>Append the <a href="#current-input-character">current input character</a> to the current tag token's tag name.</dd>

  </dl><h5 id="rcdata-less-than-sign-state"><span class="secno">8.2.4.11 </span><dfn>RCDATA less-than sign state</dfn></h5>
  <!-- identical to the RAWTEXT less-than sign state, except s/RAWTEXT/RCDATA/g -->

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"/" (U+002F)</dt>
   <dd>Set the <var><a href="#temporary-buffer">temporary buffer</a></var> to the empty string. Switch to the <a href="#rcdata-end-tag-open-state">RCDATA end tag
   open state</a>.</dd>

   <dt>Anything else</dt>
   <dd>Switch to the <a href="#rcdata-state">RCDATA state</a>. Emit a U+003C LESS-THAN SIGN character token.
   Reconsume the <a href="#current-input-character">current input character</a>.</dd>

  </dl><h5 id="rcdata-end-tag-open-state"><span class="secno">8.2.4.12 </span><dfn>RCDATA end tag open state</dfn></h5>
  <!-- identical to the RAWTEXT (and Script data) end tag open state, except s/RAWTEXT/RCDATA/g -->

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt><a data-anolis-xref="uppercase ASCII letters" href="infrastructure.html#uppercase-ascii-letters">Uppercase ASCII letter</a></dt>
   <dd>Create a new end tag token, and set its tag name to the lowercase version of the
   <a href="#current-input-character">current input character</a> (add 0x0020 to the character's code point). Append the
   <a href="#current-input-character">current input character</a> to the <var><a href="#temporary-buffer">temporary buffer</a></var>. Finally, switch to the
   <a href="#rcdata-end-tag-name-state">RCDATA end tag name state</a>. (Don't emit the token yet; further details will be filled
   in before it is emitted.)</dd>

   <dt><a data-anolis-xref="lowercase ASCII letters" href="infrastructure.html#lowercase-ascii-letters">Lowercase ASCII letter</a></dt>
   <dd>Create a new end tag token, and set its tag name to the <a href="#current-input-character">current input character</a>.
   Append the <a href="#current-input-character">current input character</a> to the <var><a href="#temporary-buffer">temporary buffer</a></var>. Finally,
   switch to the <a href="#rcdata-end-tag-name-state">RCDATA end tag name state</a>. (Don't emit the token yet; further details
   will be filled in before it is emitted.)</dd>

   <dt>Anything else</dt>
   <dd>Switch to the <a href="#rcdata-state">RCDATA state</a>. Emit a U+003C LESS-THAN SIGN character token and a
   U+002F SOLIDUS character token. Reconsume the <a href="#current-input-character">current input character</a>.</dd>

  </dl><h5 id="rcdata-end-tag-name-state"><span class="secno">8.2.4.13 </span><dfn>RCDATA end tag name state</dfn></h5>
  <!-- identical to the RAWTEXT (and Script data) end tag name state, except s/RAWTEXT/RCDATA/g -->

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"tab" (U+0009)</dt>
   <dt>"LF" (U+000A)</dt>
   <dt>"FF" (U+000C)</dt>
   <!--<dt>"CR" (U+000D)</dt>-->
   <dt>U+0020 SPACE</dt>
   <dd>If the current end tag token is an <a href="#appropriate-end-tag-token">appropriate end tag token</a>, then switch to the
   <a href="#before-attribute-name-state">before attribute name state</a>. Otherwise, treat it as per the "anything else" entry
   below.</dd>

   <dt>"/" (U+002F)</dt>
   <dd>If the current end tag token is an <a href="#appropriate-end-tag-token">appropriate end tag token</a>, then switch to the
   <a href="#self-closing-start-tag-state">self-closing start tag state</a>. Otherwise, treat it as per the "anything else" entry
   below.</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd>If the current end tag token is an <a href="#appropriate-end-tag-token">appropriate end tag token</a>, then switch to the
   <a href="#data-state">data state</a> and emit the current tag token. Otherwise, treat it as per the "anything
   else" entry below.</dd>

   <dt><a data-anolis-xref="uppercase ASCII letters" href="infrastructure.html#uppercase-ascii-letters">Uppercase ASCII letter</a></dt>
   <dd>Append the lowercase version of the <a href="#current-input-character">current input character</a> (add 0x0020 to the
   character's code point) to the current tag token's tag name. Append the <a href="#current-input-character">current input
   character</a> to the <var><a href="#temporary-buffer">temporary buffer</a></var>.</dd>

   <dt><a data-anolis-xref="lowercase ASCII letters" href="infrastructure.html#lowercase-ascii-letters">Lowercase ASCII letter</a></dt>
   <dd>Append the <a href="#current-input-character">current input character</a> to the current tag token's tag name. Append
   the <a href="#current-input-character">current input character</a> to the <var><a href="#temporary-buffer">temporary buffer</a></var>.</dd>

   <dt>Anything else</dt>
   <dd>Switch to the <a href="#rcdata-state">RCDATA state</a>. Emit a U+003C LESS-THAN SIGN character token, a
   U+002F SOLIDUS character token, and a character token for each of the characters in the
   <var><a href="#temporary-buffer">temporary buffer</a></var> (in the order they were added to the buffer). Reconsume the
   <a href="#current-input-character">current input character</a>.</dd>

  </dl><h5 id="rawtext-less-than-sign-state"><span class="secno">8.2.4.14 </span><dfn>RAWTEXT less-than sign state</dfn></h5>
  <!-- identical to the RCDATA less-than sign state, except s/RCDATA/RAWTEXT/g -->

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"/" (U+002F)</dt>
   <dd>Set the <var><a href="#temporary-buffer">temporary buffer</a></var> to the empty string. Switch to the <a href="#rawtext-end-tag-open-state">RAWTEXT end tag
   open state</a>.</dd>

   <dt>Anything else</dt>
   <dd>Switch to the <a href="#rawtext-state">RAWTEXT state</a>. Emit a U+003C LESS-THAN SIGN character token.
   Reconsume the <a href="#current-input-character">current input character</a>.</dd>

  </dl><h5 id="rawtext-end-tag-open-state"><span class="secno">8.2.4.15 </span><dfn>RAWTEXT end tag open state</dfn></h5>
  <!-- identical to the RCDATA (and Script data) end tag open state, except s/RCDATA/RAWTEXT/g -->

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt><a data-anolis-xref="uppercase ASCII letters" href="infrastructure.html#uppercase-ascii-letters">Uppercase ASCII letter</a></dt>
   <dd>Create a new end tag token, and set its tag name to the lowercase version of the
   <a href="#current-input-character">current input character</a> (add 0x0020 to the character's code point). Append the
   <a href="#current-input-character">current input character</a> to the <var><a href="#temporary-buffer">temporary buffer</a></var>. Finally, switch to the
   <a href="#rawtext-end-tag-name-state">RAWTEXT end tag name state</a>. (Don't emit the token yet; further details will be
   filled in before it is emitted.)</dd>

   <dt><a data-anolis-xref="lowercase ASCII letters" href="infrastructure.html#lowercase-ascii-letters">Lowercase ASCII letter</a></dt>
   <dd>Create a new end tag token, and set its tag name to the <a href="#current-input-character">current input character</a>.
   Append the <a href="#current-input-character">current input character</a> to the <var><a href="#temporary-buffer">temporary buffer</a></var>. Finally,
   switch to the <a href="#rawtext-end-tag-name-state">RAWTEXT end tag name state</a>. (Don't emit the token yet; further details
   will be filled in before it is emitted.)</dd>

   <dt>Anything else</dt>
   <dd>Switch to the <a href="#rawtext-state">RAWTEXT state</a>. Emit a U+003C LESS-THAN SIGN character token and a
   U+002F SOLIDUS character token. Reconsume the <a href="#current-input-character">current input character</a>.</dd>

  </dl><h5 id="rawtext-end-tag-name-state"><span class="secno">8.2.4.16 </span><dfn>RAWTEXT end tag name state</dfn></h5>
  <!-- identical to the RCDATA (and Script data) end tag name state, except s/RCDATA/RAWTEXT/g -->

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"tab" (U+0009)</dt>
   <dt>"LF" (U+000A)</dt>
   <dt>"FF" (U+000C)</dt>
   <!--<dt>"CR" (U+000D)</dt>-->
   <dt>U+0020 SPACE</dt>
   <dd>If the current end tag token is an <a href="#appropriate-end-tag-token">appropriate end tag token</a>, then switch to the
   <a href="#before-attribute-name-state">before attribute name state</a>. Otherwise, treat it as per the "anything else" entry
   below.</dd>

   <dt>"/" (U+002F)</dt>
   <dd>If the current end tag token is an <a href="#appropriate-end-tag-token">appropriate end tag token</a>, then switch to the
   <a href="#self-closing-start-tag-state">self-closing start tag state</a>. Otherwise, treat it as per the "anything else" entry
   below.</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd>If the current end tag token is an <a href="#appropriate-end-tag-token">appropriate end tag token</a>, then switch to the
   <a href="#data-state">data state</a> and emit the current tag token. Otherwise, treat it as per the "anything
   else" entry below.</dd>

   <dt><a data-anolis-xref="uppercase ASCII letters" href="infrastructure.html#uppercase-ascii-letters">Uppercase ASCII letter</a></dt>
   <dd>Append the lowercase version of the <a href="#current-input-character">current input character</a> (add 0x0020 to the
   character's code point) to the current tag token's tag name. Append the <a href="#current-input-character">current input
   character</a> to the <var><a href="#temporary-buffer">temporary buffer</a></var>.</dd>

   <dt><a data-anolis-xref="lowercase ASCII letters" href="infrastructure.html#lowercase-ascii-letters">Lowercase ASCII letter</a></dt>
   <dd>Append the <a href="#current-input-character">current input character</a> to the current tag token's tag name. Append
   the <a href="#current-input-character">current input character</a> to the <var><a href="#temporary-buffer">temporary buffer</a></var>.</dd>

   <dt>Anything else</dt>
   <dd>Switch to the <a href="#rawtext-state">RAWTEXT state</a>. Emit a U+003C LESS-THAN SIGN character token, a
   U+002F SOLIDUS character token, and a character token for each of the characters in the
   <var><a href="#temporary-buffer">temporary buffer</a></var> (in the order they were added to the buffer). Reconsume the
   <a href="#current-input-character">current input character</a>.</dd>

  </dl><h5 id="script-data-less-than-sign-state"><span class="secno">8.2.4.17 </span><dfn>Script data less-than sign state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"/" (U+002F)</dt>
   <dd>Set the <var><a href="#temporary-buffer">temporary buffer</a></var> to the empty string. Switch to the <a href="#script-data-end-tag-open-state">script data end
   tag open state</a>.</dd>

   <dt>"!" (U+0021)</dt>
   <dd>Switch to the <a href="#script-data-escape-start-state">script data escape start state</a>. Emit a U+003C LESS-THAN SIGN
   character token and a U+0021 EXCLAMATION MARK character token.</dd>

   <dt>Anything else</dt>
   <dd>Switch to the <a href="#script-data-state">script data state</a>. Emit a U+003C LESS-THAN SIGN character token.
   Reconsume the <a href="#current-input-character">current input character</a>.</dd>

  </dl><h5 id="script-data-end-tag-open-state"><span class="secno">8.2.4.18 </span><dfn>Script data end tag open state</dfn></h5>
  <!-- identical to the RCDATA (and RAWTEXT) end tag open state, except s/RCDATA/Script data/g -->

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt><a data-anolis-xref="uppercase ASCII letters" href="infrastructure.html#uppercase-ascii-letters">Uppercase ASCII letter</a></dt>
   <dd>Create a new end tag token, and set its tag name to the lowercase version of the
   <a href="#current-input-character">current input character</a> (add 0x0020 to the character's code point). Append the
   <a href="#current-input-character">current input character</a> to the <var><a href="#temporary-buffer">temporary buffer</a></var>. Finally, switch to the
   <a href="#script-data-end-tag-name-state">script data end tag name state</a>. (Don't emit the token yet; further details will be
   filled in before it is emitted.)</dd>

   <dt><a data-anolis-xref="lowercase ASCII letters" href="infrastructure.html#lowercase-ascii-letters">Lowercase ASCII letter</a></dt>
   <dd>Create a new end tag token, and set its tag name to the <a href="#current-input-character">current input character</a>.
   Append the <a href="#current-input-character">current input character</a> to the <var><a href="#temporary-buffer">temporary buffer</a></var>. Finally,
   switch to the <a href="#script-data-end-tag-name-state">script data end tag name state</a>. (Don't emit the token yet; further
   details will be filled in before it is emitted.)</dd>

   <dt>Anything else</dt>
   <dd>Switch to the <a href="#script-data-state">script data state</a>. Emit a U+003C LESS-THAN SIGN character token
   and a U+002F SOLIDUS character token. Reconsume the <a href="#current-input-character">current input character</a>.</dd>

  </dl><h5 id="script-data-end-tag-name-state"><span class="secno">8.2.4.19 </span><dfn>Script data end tag name state</dfn></h5>
  <!-- identical to the RCDATA (and RAWTEXT) end tag name state, except s/RCDATA/Script data/g -->

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"tab" (U+0009)</dt>
   <dt>"LF" (U+000A)</dt>
   <dt>"FF" (U+000C)</dt>
   <!--<dt>"CR" (U+000D)</dt>-->
   <dt>U+0020 SPACE</dt>
   <dd>If the current end tag token is an <a href="#appropriate-end-tag-token">appropriate end tag token</a>, then switch to the
   <a href="#before-attribute-name-state">before attribute name state</a>. Otherwise, treat it as per the "anything else" entry
   below.</dd>

   <dt>"/" (U+002F)</dt>
   <dd>If the current end tag token is an <a href="#appropriate-end-tag-token">appropriate end tag token</a>, then switch to the
   <a href="#self-closing-start-tag-state">self-closing start tag state</a>. Otherwise, treat it as per the "anything else" entry
   below.</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd>If the current end tag token is an <a href="#appropriate-end-tag-token">appropriate end tag token</a>, then switch to the
   <a href="#data-state">data state</a> and emit the current tag token. Otherwise, treat it as per the "anything
   else" entry below.</dd>

   <dt><a data-anolis-xref="uppercase ASCII letters" href="infrastructure.html#uppercase-ascii-letters">Uppercase ASCII letter</a></dt>
   <dd>Append the lowercase version of the <a href="#current-input-character">current input character</a> (add 0x0020 to the
   character's code point) to the current tag token's tag name. Append the <a href="#current-input-character">current input
   character</a> to the <var><a href="#temporary-buffer">temporary buffer</a></var>.</dd>

   <dt><a data-anolis-xref="lowercase ASCII letters" href="infrastructure.html#lowercase-ascii-letters">Lowercase ASCII letter</a></dt>
   <dd>Append the <a href="#current-input-character">current input character</a> to the current tag token's tag name. Append
   the <a href="#current-input-character">current input character</a> to the <var><a href="#temporary-buffer">temporary buffer</a></var>.</dd>

   <dt>Anything else</dt>
   <dd>Switch to the <a href="#script-data-state">script data state</a>. Emit a U+003C LESS-THAN SIGN character token, a
   U+002F SOLIDUS character token, and a character token for each of the characters in the
   <var><a href="#temporary-buffer">temporary buffer</a></var> (in the order they were added to the buffer). Reconsume the
   <a href="#current-input-character">current input character</a>.</dd>

  </dl><h5 id="script-data-escape-start-state"><span class="secno">8.2.4.20 </span><dfn>Script data escape start state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"-" (U+002D)</dt>
   <dd>Switch to the <a href="#script-data-escape-start-dash-state">script data escape start dash state</a>. Emit a U+002D HYPHEN-MINUS
   character token.</dd>

   <dt>Anything else</dt>
   <dd>Switch to the <a href="#script-data-state">script data state</a>. Reconsume the <a href="#current-input-character">current input
   character</a>.</dd>

  </dl><h5 id="script-data-escape-start-dash-state"><span class="secno">8.2.4.21 </span><dfn>Script data escape start dash state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"-" (U+002D)</dt>
   <dd>Switch to the <a href="#script-data-escaped-dash-dash-state">script data escaped dash dash state</a>. Emit a U+002D HYPHEN-MINUS
   character token.</dd>

   <dt>Anything else</dt>
   <dd>Switch to the <a href="#script-data-state">script data state</a>. Reconsume the <a href="#current-input-character">current input
   character</a>.</dd>

  </dl><h5 id="script-data-escaped-state"><span class="secno">8.2.4.22 </span><dfn>Script data escaped state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"-" (U+002D)</dt>
   <dd>Switch to the <a href="#script-data-escaped-dash-state">script data escaped dash state</a>. Emit a U+002D HYPHEN-MINUS
   character token.</dd>

   <dt>"&lt;" (U+003C)</dt>
   <dd>Switch to the <a href="#script-data-escaped-less-than-sign-state">script data escaped less-than sign state</a>.</dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Emit a U+FFFD REPLACEMENT CHARACTER character token.</dd>

   <dt>EOF</dt>
   <dd>Switch to the <a href="#data-state">data state</a>. <a href="#parse-error">Parse error</a>. Reconsume the EOF
   character.</dd>

   <dt>Anything else</dt>
   <dd>Emit the <a href="#current-input-character">current input character</a> as a character token.</dd>

  </dl><h5 id="script-data-escaped-dash-state"><span class="secno">8.2.4.23 </span><dfn>Script data escaped dash state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"-" (U+002D)</dt>
   <dd>Switch to the <a href="#script-data-escaped-dash-dash-state">script data escaped dash dash state</a>. Emit a U+002D HYPHEN-MINUS
   character token.</dd>

   <dt>"&lt;" (U+003C)</dt>
   <dd>Switch to the <a href="#script-data-escaped-less-than-sign-state">script data escaped less-than sign state</a>.</dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#script-data-escaped-state">script data escaped state</a>. Emit a U+FFFD
   REPLACEMENT CHARACTER character token.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Reconsume the EOF
   character.</dd>

   <dt>Anything else</dt>
   <dd>Switch to the <a href="#script-data-escaped-state">script data escaped state</a>. Emit the <a href="#current-input-character">current input
   character</a> as a character token.</dd>

  </dl><h5 id="script-data-escaped-dash-dash-state"><span class="secno">8.2.4.24 </span><dfn>Script data escaped dash dash state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"-" (U+002D)</dt>
   <dd>Emit a U+002D HYPHEN-MINUS character token.</dd>

   <dt>"&lt;" (U+003C)</dt>
   <dd>Switch to the <a href="#script-data-escaped-less-than-sign-state">script data escaped less-than sign state</a>.</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd>Switch to the <a href="#script-data-state">script data state</a>. Emit a U+003E GREATER-THAN SIGN character
   token.</dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#script-data-escaped-state">script data escaped state</a>. Emit a U+FFFD
   REPLACEMENT CHARACTER character token.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Reconsume the EOF
   character.</dd>

   <dt>Anything else</dt>
   <dd>Switch to the <a href="#script-data-escaped-state">script data escaped state</a>. Emit the <a href="#current-input-character">current input
   character</a> as a character token.</dd>

  </dl><h5 id="script-data-escaped-less-than-sign-state"><span class="secno">8.2.4.25 </span><dfn>Script data escaped less-than sign state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"/" (U+002F)</dt>

   <dd>Set the <var><a href="#temporary-buffer">temporary buffer</a></var> to the empty string. Switch to the <a href="#script-data-escaped-end-tag-open-state">script data
   escaped end tag open state</a>.</dd>

   <dt><a data-anolis-xref="uppercase ASCII letters" href="infrastructure.html#uppercase-ascii-letters">Uppercase ASCII letter</a></dt>
   <dd>Set the <var><a href="#temporary-buffer">temporary buffer</a></var> to the empty string. Append the lowercase version of the
   <a href="#current-input-character">current input character</a> (add 0x0020 to the character's code point) to the
   <var><a href="#temporary-buffer">temporary buffer</a></var>. Switch to the <a href="#script-data-double-escape-start-state">script data double escape start state</a>.
   Emit a U+003C LESS-THAN SIGN character token and the <a href="#current-input-character">current input character</a> as a
   character token.</dd>

   <dt><a data-anolis-xref="lowercase ASCII letters" href="infrastructure.html#lowercase-ascii-letters">Lowercase ASCII letter</a></dt>
   <dd>Set the <var><a href="#temporary-buffer">temporary buffer</a></var> to the empty string. Append the <a href="#current-input-character">current input
   character</a> to the <var><a href="#temporary-buffer">temporary buffer</a></var>. Switch to the <a href="#script-data-double-escape-start-state">script data double
   escape start state</a>. Emit a U+003C LESS-THAN SIGN character token and the <a href="#current-input-character">current
   input character</a> as a character token.</dd>

   <dt>Anything else</dt>
   <dd>Switch to the <a href="#script-data-escaped-state">script data escaped state</a>. Emit a U+003C LESS-THAN SIGN character
   token. Reconsume the <a href="#current-input-character">current input character</a>.</dd>

  </dl><h5 id="script-data-escaped-end-tag-open-state"><span class="secno">8.2.4.26 </span><dfn>Script data escaped end tag open state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt><a data-anolis-xref="uppercase ASCII letters" href="infrastructure.html#uppercase-ascii-letters">Uppercase ASCII letter</a></dt>
   <dd>Create a new end tag token, and set its tag name to the lowercase version of the
   <a href="#current-input-character">current input character</a> (add 0x0020 to the character's code point). Append the
   <a href="#current-input-character">current input character</a> to the <var><a href="#temporary-buffer">temporary buffer</a></var>. Finally, switch to the
   <a href="#script-data-escaped-end-tag-name-state">script data escaped end tag name state</a>. (Don't emit the token yet; further details
   will be filled in before it is emitted.)</dd>

   <dt><a data-anolis-xref="lowercase ASCII letters" href="infrastructure.html#lowercase-ascii-letters">Lowercase ASCII letter</a></dt>
   <dd>Create a new end tag token, and set its tag name to the <a href="#current-input-character">current input character</a>.
   Append the <a href="#current-input-character">current input character</a> to the <var><a href="#temporary-buffer">temporary buffer</a></var>. Finally,
   switch to the <a href="#script-data-escaped-end-tag-name-state">script data escaped end tag name state</a>. (Don't emit the token yet;
   further details will be filled in before it is emitted.)</dd>

   <dt>Anything else</dt>
   <dd>Switch to the <a href="#script-data-escaped-state">script data escaped state</a>. Emit a U+003C LESS-THAN SIGN character
   token and a U+002F SOLIDUS character token. Reconsume the <a href="#current-input-character">current input
   character</a>.</dd>

  </dl><h5 id="script-data-escaped-end-tag-name-state"><span class="secno">8.2.4.27 </span><dfn>Script data escaped end tag name state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"tab" (U+0009)</dt>
   <dt>"LF" (U+000A)</dt>
   <dt>"FF" (U+000C)</dt>
   <!--<dt>"CR" (U+000D)</dt>-->
   <dt>U+0020 SPACE</dt>
   <dd>If the current end tag token is an <a href="#appropriate-end-tag-token">appropriate end tag token</a>, then switch to the
   <a href="#before-attribute-name-state">before attribute name state</a>. Otherwise, treat it as per the "anything else" entry
   below.</dd>

   <dt>"/" (U+002F)</dt>
   <dd>If the current end tag token is an <a href="#appropriate-end-tag-token">appropriate end tag token</a>, then switch to the
   <a href="#self-closing-start-tag-state">self-closing start tag state</a>. Otherwise, treat it as per the "anything else" entry
   below.</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd>If the current end tag token is an <a href="#appropriate-end-tag-token">appropriate end tag token</a>, then switch to the
   <a href="#data-state">data state</a> and emit the current tag token. Otherwise, treat it as per the "anything
   else" entry below.</dd>

   <dt><a data-anolis-xref="uppercase ASCII letters" href="infrastructure.html#uppercase-ascii-letters">Uppercase ASCII letter</a></dt>
   <dd>Append the lowercase version of the <a href="#current-input-character">current input character</a> (add 0x0020 to the
   character's code point) to the current tag token's tag name. Append the <a href="#current-input-character">current input
   character</a> to the <var><a href="#temporary-buffer">temporary buffer</a></var>.</dd>

   <dt><a data-anolis-xref="lowercase ASCII letters" href="infrastructure.html#lowercase-ascii-letters">Lowercase ASCII letter</a></dt>
   <dd>Append the <a href="#current-input-character">current input character</a> to the current tag token's tag name. Append
   the <a href="#current-input-character">current input character</a> to the <var><a href="#temporary-buffer">temporary buffer</a></var>.</dd>

   <dt>Anything else</dt>
   <dd>Switch to the <a href="#script-data-escaped-state">script data escaped state</a>. Emit a U+003C LESS-THAN SIGN character
   token, a U+002F SOLIDUS character token, and a character token for each of the characters in the
   <var><a href="#temporary-buffer">temporary buffer</a></var> (in the order they were added to the buffer). Reconsume the
   <a href="#current-input-character">current input character</a>.</dd>

  </dl><h5 id="script-data-double-escape-start-state"><span class="secno">8.2.4.28 </span><dfn>Script data double escape start state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"tab" (U+0009)</dt>
   <dt>"LF" (U+000A)</dt>
   <dt>"FF" (U+000C)</dt>
   <!--<dt>"CR" (U+000D)</dt>-->
   <dt>U+0020 SPACE</dt>
   <dt>"/" (U+002F)</dt>
   <dt>"&gt;" (U+003E)</dt>

   <dd>If the <var><a href="#temporary-buffer">temporary buffer</a></var> is the string "<code data-anolis-xref="">script</code>", then switch
   to the <a href="#script-data-double-escaped-state">script data double escaped state</a>. Otherwise, switch to the <a href="#script-data-escaped-state">script data
   escaped state</a>. Emit the <a href="#current-input-character">current input character</a> as a character token.</dd>

   <dt><a data-anolis-xref="uppercase ASCII letters" href="infrastructure.html#uppercase-ascii-letters">Uppercase ASCII letter</a></dt>
   <dd>Append the lowercase version of the <a href="#current-input-character">current input character</a> (add 0x0020 to the
   character's code point) to the <var><a href="#temporary-buffer">temporary buffer</a></var>. Emit the <a href="#current-input-character">current input
   character</a> as a character token.</dd>

   <dt><a data-anolis-xref="lowercase ASCII letters" href="infrastructure.html#lowercase-ascii-letters">Lowercase ASCII letter</a></dt>
   <dd>Append the <a href="#current-input-character">current input character</a> to the <var><a href="#temporary-buffer">temporary buffer</a></var>. Emit the
   <a href="#current-input-character">current input character</a> as a character token.</dd>

   <dt>Anything else</dt>
   <dd>Switch to the <a href="#script-data-escaped-state">script data escaped state</a>. Reconsume the <a href="#current-input-character">current input
   character</a>.</dd>

  </dl><h5 id="script-data-double-escaped-state"><span class="secno">8.2.4.29 </span><dfn>Script data double escaped state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"-" (U+002D)</dt>
   <dd>Switch to the <a href="#script-data-double-escaped-dash-state">script data double escaped dash state</a>. Emit a U+002D HYPHEN-MINUS
   character token.</dd>

   <dt>"&lt;" (U+003C)</dt>
   <dd>Switch to the <a href="#script-data-double-escaped-less-than-sign-state">script data double escaped less-than sign state</a>. Emit a U+003C
   LESS-THAN SIGN character token.</dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Emit a U+FFFD REPLACEMENT CHARACTER character token.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Reconsume the EOF
   character.</dd>

   <dt>Anything else</dt>
   <dd>Emit the <a href="#current-input-character">current input character</a> as a character token.</dd>

  </dl><h5 id="script-data-double-escaped-dash-state"><span class="secno">8.2.4.30 </span><dfn>Script data double escaped dash state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"-" (U+002D)</dt>
   <dd>Switch to the <a href="#script-data-double-escaped-dash-dash-state">script data double escaped dash dash state</a>. Emit a U+002D
   HYPHEN-MINUS character token.</dd>

   <dt>"&lt;" (U+003C)</dt>
   <dd>Switch to the <a href="#script-data-double-escaped-less-than-sign-state">script data double escaped less-than sign state</a>. Emit a U+003C
   LESS-THAN SIGN character token.</dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#script-data-double-escaped-state">script data double escaped state</a>. Emit a
   U+FFFD REPLACEMENT CHARACTER character token.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Reconsume the EOF
   character.</dd>

   <dt>Anything else</dt>
   <dd>Switch to the <a href="#script-data-double-escaped-state">script data double escaped state</a>. Emit the <a href="#current-input-character">current input
   character</a> as a character token.</dd>

  </dl><h5 id="script-data-double-escaped-dash-dash-state"><span class="secno">8.2.4.31 </span><dfn>Script data double escaped dash dash state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"-" (U+002D)</dt>
   <dd>Emit a U+002D HYPHEN-MINUS character token.</dd>

   <dt>"&lt;" (U+003C)</dt>
   <dd>Switch to the <a href="#script-data-double-escaped-less-than-sign-state">script data double escaped less-than sign state</a>. Emit a U+003C
   LESS-THAN SIGN character token.</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd>Switch to the <a href="#script-data-state">script data state</a>. Emit a U+003E GREATER-THAN SIGN character
   token.</dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#script-data-double-escaped-state">script data double escaped state</a>. Emit a
   U+FFFD REPLACEMENT CHARACTER character token.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Reconsume the EOF
   character.</dd>

   <dt>Anything else</dt>
   <dd>Switch to the <a href="#script-data-double-escaped-state">script data double escaped state</a>. Emit the <a href="#current-input-character">current input
   character</a> as a character token.</dd>

  </dl><h5 id="script-data-double-escaped-less-than-sign-state"><span class="secno">8.2.4.32 </span><dfn>Script data double escaped less-than sign state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"/" (U+002F)</dt>
   <dd>Set the <var><a href="#temporary-buffer">temporary buffer</a></var> to the empty string. Switch to the <a href="#script-data-double-escape-end-state">script data
   double escape end state</a>. Emit a U+002F SOLIDUS character token.</dd>

   <dt>Anything else</dt>
   <dd>Switch to the <a href="#script-data-double-escaped-state">script data double escaped state</a>. Reconsume the <a href="#current-input-character">current
   input character</a>.</dd>

  </dl><h5 id="script-data-double-escape-end-state"><span class="secno">8.2.4.33 </span><dfn>Script data double escape end state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"tab" (U+0009)</dt>
   <dt>"LF" (U+000A)</dt>
   <dt>"FF" (U+000C)</dt>
   <!--<dt>"CR" (U+000D)</dt>-->
   <dt>U+0020 SPACE</dt>
   <dt>"/" (U+002F)</dt>
   <dt>"&gt;" (U+003E)</dt>

   <dd>If the <var><a href="#temporary-buffer">temporary buffer</a></var> is the string "<code data-anolis-xref="">script</code>", then switch
   to the <a href="#script-data-escaped-state">script data escaped state</a>. Otherwise, switch to the <a href="#script-data-double-escaped-state">script data double
   escaped state</a>. Emit the <a href="#current-input-character">current input character</a> as a character token.</dd>

   <dt><a data-anolis-xref="uppercase ASCII letters" href="infrastructure.html#uppercase-ascii-letters">Uppercase ASCII letter</a></dt>
   <dd>Append the lowercase version of the <a href="#current-input-character">current input character</a> (add 0x0020 to the
   character's code point) to the <var><a href="#temporary-buffer">temporary buffer</a></var>. Emit the <a href="#current-input-character">current input
   character</a> as a character token.</dd>

   <dt><a data-anolis-xref="lowercase ASCII letters" href="infrastructure.html#lowercase-ascii-letters">Lowercase ASCII letter</a></dt>
   <dd>Append the <a href="#current-input-character">current input character</a> to the <var><a href="#temporary-buffer">temporary buffer</a></var>. Emit the
   <a href="#current-input-character">current input character</a> as a character token.</dd>

   <dt>Anything else</dt>
   <dd>Switch to the <a href="#script-data-double-escaped-state">script data double escaped state</a>. Reconsume the <a href="#current-input-character">current
   input character</a>.</dd>

  </dl><h5 id="before-attribute-name-state"><span class="secno">8.2.4.34 </span><dfn>Before attribute name state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"tab" (U+0009)</dt>
   <dt>"LF" (U+000A)</dt>
   <dt>"FF" (U+000C)</dt>
   <!--<dt>"CR" (U+000D)</dt>-->
   <dt>U+0020 SPACE</dt>
   <dd>Ignore the character.</dd>

   <dt>"/" (U+002F)</dt>
   <dd>Switch to the <a href="#self-closing-start-tag-state">self-closing start tag state</a>.</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd>Switch to the <a href="#data-state">data state</a>. Emit the current tag token.</dd>

   <dt><a data-anolis-xref="uppercase ASCII letters" href="infrastructure.html#uppercase-ascii-letters">Uppercase ASCII letter</a></dt>
   <dd>Start a new attribute in the current tag token. Set that attribute's name to the lowercase
   version of the <a href="#current-input-character">current input character</a> (add 0x0020 to the character's code point),
   and its value to the empty string. Switch to the <a href="#attribute-name-state">attribute name state</a>.</dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Start a new attribute in the current tag token. Set that
   attribute's name to a U+FFFD REPLACEMENT CHARACTER character, and its value to the empty string.
   Switch to the <a href="#attribute-name-state">attribute name state</a>.</dd>

   <dt>U+0022 QUOTATION MARK (")</dt>
   <dt>"'" (U+0027)</dt>
   <dt>"&lt;" (U+003C)</dt>
   <dt>"=" (U+003D)</dt>
   <dd><a href="#parse-error">Parse error</a>. Treat it as per the "anything else" entry below.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Reconsume the EOF
   character.</dd>

   <dt>Anything else</dt>
   <dd>Start a new attribute in the current tag token. Set that attribute's name to the
   <a href="#current-input-character">current input character</a>, and its value to the empty string. Switch to the
   <a href="#attribute-name-state">attribute name state</a>.</dd>

  </dl><h5 id="attribute-name-state"><span class="secno">8.2.4.35 </span><dfn>Attribute name state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"tab" (U+0009)</dt>
   <dt>"LF" (U+000A)</dt>
   <dt>"FF" (U+000C)</dt>
   <!--<dt>"CR" (U+000D)</dt>-->
   <dt>U+0020 SPACE</dt>
   <dd>Switch to the <a href="#after-attribute-name-state">after attribute name state</a>.</dd>

   <dt>"/" (U+002F)</dt>
   <dd>Switch to the <a href="#self-closing-start-tag-state">self-closing start tag state</a>.</dd>

   <dt>"=" (U+003D)</dt>
   <dd>Switch to the <a href="#before-attribute-value-state">before attribute value state</a>.</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd>Switch to the <a href="#data-state">data state</a>. Emit the current tag token.</dd>

   <dt><a data-anolis-xref="uppercase ASCII letters" href="infrastructure.html#uppercase-ascii-letters">Uppercase ASCII letter</a></dt>
   <dd>Append the lowercase version of the <a href="#current-input-character">current input character</a> (add 0x0020 to the
   character's code point) to the current attribute's name.</dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Append a U+FFFD REPLACEMENT CHARACTER character to the current
   attribute's name.</dd>

   <dt>U+0022 QUOTATION MARK (")</dt>
   <dt>"'" (U+0027)</dt>
   <dt>"&lt;" (U+003C)</dt>
   <dd><a href="#parse-error">Parse error</a>. Treat it as per the "anything else" entry below.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Reconsume the EOF
   character.</dd>

   <dt>Anything else</dt>
   <dd>Append the <a href="#current-input-character">current input character</a> to the current attribute's name.</dd>

  </dl><p>When the user agent leaves the attribute name state (and before emitting the tag token, if
  appropriate), the complete attribute's name must be compared to the other attributes on the same
  token; if there is already an attribute on the token with the exact same name, then this is a
  <a href="#parse-error">parse error</a> and the new attribute must be removed from the token.</p>

  <p class="note">If an attribute is so removed from a token, it, along with the value that gets
  associated with it, if any, are never subsequently used by the parser, and are therefore
  effectively discarded. Removing the attribute in this way does not change its status as the
  "current attribute" for the purposes of the tokenizer, however.</p>


  <h5 id="after-attribute-name-state"><span class="secno">8.2.4.36 </span><dfn>After attribute name state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"tab" (U+0009)</dt>
   <dt>"LF" (U+000A)</dt>
   <dt>"FF" (U+000C)</dt>
   <!--<dt>"CR" (U+000D)</dt>-->
   <dt>U+0020 SPACE</dt>
   <dd>Ignore the character.</dd>

   <dt>"/" (U+002F)</dt>
   <dd>Switch to the <a href="#self-closing-start-tag-state">self-closing start tag state</a>.</dd>

   <dt>"=" (U+003D)</dt>
   <dd>Switch to the <a href="#before-attribute-value-state">before attribute value state</a>.</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd>Switch to the <a href="#data-state">data state</a>. Emit the current tag token.</dd>

   <dt><a data-anolis-xref="uppercase ASCII letters" href="infrastructure.html#uppercase-ascii-letters">Uppercase ASCII letter</a></dt>
   <dd>Start a new attribute in the current tag token. Set that attribute's name to the lowercase
   version of the <a href="#current-input-character">current input character</a> (add 0x0020 to the character's code point),
   and its value to the empty string. Switch to the <a href="#attribute-name-state">attribute name state</a>.</dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Start a new attribute in the current tag token. Set that
   attribute's name to a U+FFFD REPLACEMENT CHARACTER character, and its value to the empty string.
   Switch to the <a href="#attribute-name-state">attribute name state</a>.</dd>

   <dt>U+0022 QUOTATION MARK (")</dt>
   <dt>"'" (U+0027)</dt>
   <dt>"&lt;" (U+003C)</dt>
   <dd><a href="#parse-error">Parse error</a>. Treat it as per the "anything else" entry below.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Reconsume the EOF
   character.</dd>

   <dt>Anything else</dt>
   <dd>Start a new attribute in the current tag token. Set that attribute's name to the
   <a href="#current-input-character">current input character</a>, and its value to the empty string. Switch to the
   <a href="#attribute-name-state">attribute name state</a>.</dd>

  </dl><h5 id="before-attribute-value-state"><span class="secno">8.2.4.37 </span><dfn>Before attribute value state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"tab" (U+0009)</dt>
   <dt>"LF" (U+000A)</dt>
   <dt>"FF" (U+000C)</dt>
   <!--<dt>"CR" (U+000D)</dt>-->
   <dt>U+0020 SPACE</dt>
   <dd>Ignore the character.</dd>

   <dt>U+0022 QUOTATION MARK (")</dt>
   <dd>Switch to the <a href="#attribute-value-(double-quoted)-state">attribute value (double-quoted) state</a>.</dd>

   <dt>U+0026 AMPERSAND (&amp;)</dt>
   <dd>Switch to the <a href="#attribute-value-(unquoted)-state">attribute value (unquoted) state</a>. Reconsume the <a href="#current-input-character">current
   input character</a>.</dd>

   <dt>"'" (U+0027)</dt>
   <dd>Switch to the <a href="#attribute-value-(single-quoted)-state">attribute value (single-quoted) state</a>.</dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Append a U+FFFD REPLACEMENT CHARACTER character to the current
   attribute's value. Switch to the <a href="#attribute-value-(unquoted)-state">attribute value (unquoted) state</a>.</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Emit the current tag
   token.</dd>

   <dt>"&lt;" (U+003C)</dt>
   <dt>"=" (U+003D)</dt>
   <dt>"`" (U+0060)</dt>
   <dd><a href="#parse-error">Parse error</a>. Treat it as per the "anything else" entry below.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Reconsume the EOF
   character.</dd>

   <dt>Anything else</dt>
   <dd>Append the <a href="#current-input-character">current input character</a> to the current attribute's value. Switch to
   the <a href="#attribute-value-(unquoted)-state">attribute value (unquoted) state</a>.</dd>

  </dl><h5 id="attribute-value-(double-quoted)-state"><span class="secno">8.2.4.38 </span><dfn>Attribute value (double-quoted) state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>U+0022 QUOTATION MARK (")</dt>
   <dd>Switch to the <a href="#after-attribute-value-(quoted)-state">after attribute value (quoted) state</a>.</dd>

   <dt>U+0026 AMPERSAND (&amp;)</dt>
   <dd>Switch to the <a href="#character-reference-in-attribute-value-state">character reference in attribute value state</a>, with the
   <a href="#additional-allowed-character">additional allowed character</a> being U+0022 QUOTATION MARK (").</dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Append a U+FFFD REPLACEMENT CHARACTER character to the current
   attribute's value.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Reconsume the EOF
   character.</dd>

   <dt>Anything else</dt>
   <dd>Append the <a href="#current-input-character">current input character</a> to the current attribute's value.</dd>

  </dl><h5 id="attribute-value-(single-quoted)-state"><span class="secno">8.2.4.39 </span><dfn>Attribute value (single-quoted) state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"'" (U+0027)</dt>
   <dd>Switch to the <a href="#after-attribute-value-(quoted)-state">after attribute value (quoted) state</a>.</dd>

   <dt>U+0026 AMPERSAND (&amp;)</dt>
   <dd>Switch to the <a href="#character-reference-in-attribute-value-state">character reference in attribute value state</a>, with the
   <a href="#additional-allowed-character">additional allowed character</a> being "'" (U+0027).</dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Append a U+FFFD REPLACEMENT CHARACTER character to the current
   attribute's value.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Reconsume the EOF
   character.</dd>

   <dt>Anything else</dt>
   <dd>Append the <a href="#current-input-character">current input character</a> to the current attribute's value.</dd>

  </dl><h5 id="attribute-value-(unquoted)-state"><span class="secno">8.2.4.40 </span><dfn>Attribute value (unquoted) state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"tab" (U+0009)</dt>
   <dt>"LF" (U+000A)</dt>
   <dt>"FF" (U+000C)</dt>
   <!--<dt>"CR" (U+000D)</dt>-->
   <dt>U+0020 SPACE</dt>
   <dd>Switch to the <a href="#before-attribute-name-state">before attribute name state</a>.</dd>

   <dt>U+0026 AMPERSAND (&amp;)</dt>
   <dd>Switch to the <a href="#character-reference-in-attribute-value-state">character reference in attribute value state</a>, with the
   <a href="#additional-allowed-character">additional allowed character</a> being "&gt;" (U+003E).</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd>Switch to the <a href="#data-state">data state</a>. Emit the current tag token.</dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Append a U+FFFD REPLACEMENT CHARACTER character to the current
   attribute's value.</dd>

   <dt>U+0022 QUOTATION MARK (")</dt>
   <dt>"'" (U+0027)</dt>
   <dt>"&lt;" (U+003C)</dt>
   <dt>"=" (U+003D)</dt>
   <dt>"`" (U+0060)</dt>
   <dd><a href="#parse-error">Parse error</a>. Treat it as per the "anything else" entry below.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Reconsume the EOF
   character.</dd>

   <dt>Anything else</dt>
   <dd>Append the <a href="#current-input-character">current input character</a> to the current attribute's value.</dd>

  </dl><h5 id="character-reference-in-attribute-value-state"><span class="secno">8.2.4.41 </span><dfn>Character reference in attribute value state</dfn></h5>

  <p>Attempt to <a href="#consume-a-character-reference">consume a character reference</a>.</p>

  <p>If nothing is returned, append a U+0026 AMPERSAND character (&amp;) to the current attribute's
  value.</p>

  <p>Otherwise, append the returned character tokens to the current attribute's value.</p>

  <p>Finally, switch back to the attribute value state that switched into this state.</p>


  <h5 id="after-attribute-value-(quoted)-state"><span class="secno">8.2.4.42 </span><dfn>After attribute value (quoted) state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"tab" (U+0009)</dt>
   <dt>"LF" (U+000A)</dt>
   <dt>"FF" (U+000C)</dt>
   <!--<dt>"CR" (U+000D)</dt>-->
   <dt>U+0020 SPACE</dt>
   <dd>Switch to the <a href="#before-attribute-name-state">before attribute name state</a>.</dd>

   <dt>"/" (U+002F)</dt>
   <dd>Switch to the <a href="#self-closing-start-tag-state">self-closing start tag state</a>.</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd>Switch to the <a href="#data-state">data state</a>. Emit the current tag token.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Reconsume the EOF
   character.</dd>

   <dt>Anything else</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#before-attribute-name-state">before attribute name state</a>. Reconsume
   the character.</dd>

  </dl><h5 id="self-closing-start-tag-state"><span class="secno">8.2.4.43 </span><dfn>Self-closing start tag state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"&gt;" (U+003E)</dt>
   <dd>Set the <i>self-closing flag</i> of the current tag token. Switch to the <a href="#data-state">data
   state</a>. Emit the current tag token.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Reconsume the EOF
   character.</dd>

   <dt>Anything else</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#before-attribute-name-state">before attribute name state</a>. Reconsume
   the character.</dd>

  </dl><h5 id="bogus-comment-state"><span class="secno">8.2.4.44 </span><dfn>Bogus comment state</dfn></h5>


  <p>Consume every character up to and including the first "&gt;" (U+003E) character
  or the end of the file (EOF), whichever comes first. Emit a comment token whose data is the
  concatenation of all the characters starting from and including the character that caused the
  state machine to switch into the bogus comment state, up to and including the character
  immediately before the last consumed character (i.e. up to the character just before the U+003E or
  EOF character), but with any U+0000 NULL characters replaced by U+FFFD REPLACEMENT CHARACTER
  characters. (If the comment was started by the end of the file (EOF), the token is empty.
  Similarly, the token is empty if it was generated by the string "<code data-anolis-xref="">&lt;!&gt;</code>".)</p>

  <p>Switch to the <a href="#data-state">data state</a>.</p>

  <p>If the end of the file was reached, reconsume the EOF character.</p>


  <h5 id="markup-declaration-open-state"><span class="secno">8.2.4.45 </span><dfn>Markup declaration open state</dfn></h5>

  <p>If the next two characters are both "-" (U+002D) characters, consume those two
  characters, create a comment token whose data is the empty string, and switch to the <a href="#comment-start-state">comment
  start state</a>.</p>

  <p>Otherwise, if the next seven characters are an <a href="infrastructure.html#ascii-case-insensitive">ASCII case-insensitive</a> match for
  the word "DOCTYPE", then consume those characters and switch to the <a href="#doctype-state">DOCTYPE
  state</a>.</p>

  <p>Otherwise, if there is an <a href="#adjusted-current-node">adjusted current node</a> and it is not an element in the
  <a href="infrastructure.html#html-namespace-0">HTML namespace</a> and the next seven characters are a <a href="infrastructure.html#case-sensitive">case-sensitive</a> match
  for the string "[CDATA[" (the five uppercase letters "CDATA" with a U+005B LEFT SQUARE BRACKET
  character before and after), then consume those characters and switch to the <a href="#cdata-section-state">CDATA section
  state</a>.</p>

  <p>Otherwise, this is a <a href="#parse-error">parse error</a>. Switch to the <a href="#bogus-comment-state">bogus comment state</a>.
  The next character that is consumed, if any, is the first character that will be in the
  comment.</p>


  <h5 id="comment-start-state"><span class="secno">8.2.4.46 </span><dfn>Comment start state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"-" (U+002D)</dt>
   <dd>Switch to the <a href="#comment-start-dash-state">comment start dash state</a>.</dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Append a U+FFFD REPLACEMENT CHARACTER character to the comment
   token's data. Switch to the <a href="#comment-state">comment state</a>.</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Emit the comment token.</dd>
   <!-- see comment in comment end state -->

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Emit the comment token.
   Reconsume the EOF character.</dd>

   <dt>Anything else</dt>
   <dd>Append the <a href="#current-input-character">current input character</a> to the comment token's data. Switch to the
   <a href="#comment-state">comment state</a>.</dd>

  </dl><h5 id="comment-start-dash-state"><span class="secno">8.2.4.47 </span><dfn>Comment start dash state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"-" (U+002D)</dt>
   <dd>Switch to the <a href="#comment-end-state">comment end state</a></dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Append a "-" (U+002D) character and a U+FFFD REPLACEMENT
   CHARACTER character to the comment token's data. Switch to the <a href="#comment-state">comment state</a>.</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Emit the comment token.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Emit the comment token.
   Reconsume the EOF character.</dd> <!-- see comment in comment end state -->

   <dt>Anything else</dt>
   <dd>Append a "-" (U+002D) character and the <a href="#current-input-character">current input character</a> to
   the comment token's data. Switch to the <a href="#comment-state">comment state</a>.</dd>

  </dl><h5 id="comment-state"><span class="secno">8.2.4.48 </span><dfn id="comment">Comment state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"-" (U+002D)</dt>
   <dd>Switch to the <a href="#comment-end-dash-state">comment end dash state</a></dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Append a U+FFFD REPLACEMENT CHARACTER character to the comment
   token's data.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Emit the comment token.
   Reconsume the EOF character.</dd> <!-- see comment in comment end state -->

   <dt>Anything else</dt>
   <dd>Append the <a href="#current-input-character">current input character</a> to the comment token's data.</dd>

  </dl><h5 id="comment-end-dash-state"><span class="secno">8.2.4.49 </span><dfn>Comment end dash state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"-" (U+002D)</dt>
   <dd>Switch to the <a href="#comment-end-state">comment end state</a></dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Append a "-" (U+002D) character and a U+FFFD REPLACEMENT
   CHARACTER character to the comment token's data. Switch to the <a href="#comment-state">comment state</a>.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Emit the comment token.
   Reconsume the EOF character.</dd> <!-- see comment in comment end state -->

   <dt>Anything else</dt>
   <dd>Append a "-" (U+002D) character and the <a href="#current-input-character">current input character</a> to
   the comment token's data. Switch to the <a href="#comment-state">comment state</a>.</dd>

  </dl><h5 id="comment-end-state"><span class="secno">8.2.4.50 </span><dfn>Comment end state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"&gt;" (U+003E)</dt>
   <dd>Switch to the <a href="#data-state">data state</a>. Emit the comment token.</dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Append two "-" (U+002D) characters and a U+FFFD
   REPLACEMENT CHARACTER character to the comment token's data. Switch to the <a href="#comment-state">comment
   state</a>.</dd>

   <dt>"!" (U+0021)</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#comment-end-bang-state">comment end bang state</a>.</dd>

   <dt>"-" (U+002D)</dt>
   <dd><a href="#parse-error">Parse error</a>. Append a "-" (U+002D) character to the comment token's
   data.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Emit the comment token.
   Reconsume the EOF character.</dd> <!-- For security reasons: otherwise, hostile user could put a
   <script> in a comment e.g. in a blog comment and then DOS the server so that the end tag isn't
   read, and then the commented <script> tag would be treated as live code -->

   <dt>Anything else</dt>
   <dd><a href="#parse-error">Parse error</a>. Append two "-" (U+002D) characters and the <a href="#current-input-character">current
   input character</a> to the comment token's data. Switch to the <a href="#comment-state">comment
   state</a>.</dd>

  </dl><h5 id="comment-end-bang-state"><span class="secno">8.2.4.51 </span><dfn>Comment end bang state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"-" (U+002D)</dt>
   <dd>Append two "-" (U+002D) characters and a "!" (U+0021) character to
   the comment token's data. Switch to the <a href="#comment-end-dash-state">comment end dash state</a>.</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd>Switch to the <a href="#data-state">data state</a>. Emit the comment token.</dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Append two "-" (U+002D) characters, a "!" (U+0021) character, and a U+FFFD REPLACEMENT CHARACTER character to the comment token's data.
   Switch to the <a href="#comment-state">comment state</a>.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Emit the comment token.
   Reconsume the EOF character.</dd> <!-- see comment in comment end state -->

   <dt>Anything else</dt>
   <dd>Append two "-" (U+002D) characters, a "!" (U+0021) character, and
   the <a href="#current-input-character">current input character</a> to the comment token's data. Switch to the <a href="#comment-state">comment
   state</a>.</dd>

  </dl><h5 id="doctype-state"><span class="secno">8.2.4.52 </span><dfn>DOCTYPE state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"tab" (U+0009)</dt>
   <dt>"LF" (U+000A)</dt>
   <dt>"FF" (U+000C)</dt>
   <!--<dt>"CR" (U+000D)</dt>-->
   <dt>U+0020 SPACE</dt>
   <dd>Switch to the <a href="#before-doctype-name-state">before DOCTYPE name state</a>.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Create a new DOCTYPE token.
   Set its <i>force-quirks flag</i> to <i>on</i>. Emit the token. Reconsume the EOF character.</dd>

   <dt>Anything else</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#before-doctype-name-state">before DOCTYPE name state</a>. Reconsume the
   character.</dd>

  </dl><h5 id="before-doctype-name-state"><span class="secno">8.2.4.53 </span><dfn>Before DOCTYPE name state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"tab" (U+0009)</dt>
   <dt>"LF" (U+000A)</dt>
   <dt>"FF" (U+000C)</dt>
   <!--<dt>"CR" (U+000D)</dt>-->
   <dt>U+0020 SPACE</dt>
   <dd>Ignore the character.</dd>

   <dt><a data-anolis-xref="uppercase ASCII letters" href="infrastructure.html#uppercase-ascii-letters">Uppercase ASCII letter</a></dt>
   <dd>Create a new DOCTYPE token. Set the token's name to the lowercase version of the
   <a href="#current-input-character">current input character</a> (add 0x0020 to the character's code point). Switch to the
   <a href="#doctype-name-state">DOCTYPE name state</a>.</dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Create a new DOCTYPE token. Set the token's name to a U+FFFD
   REPLACEMENT CHARACTER character. Switch to the <a href="#doctype-name-state">DOCTYPE name state</a>.</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd><a href="#parse-error">Parse error</a>. Create a new DOCTYPE token. Set its <i>force-quirks flag</i> to
   <i>on</i>. Switch to the <a href="#data-state">data state</a>. Emit the token.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Create a new DOCTYPE token.
   Set its <i>force-quirks flag</i> to <i>on</i>. Emit the token. Reconsume the EOF character.</dd>

   <dt>Anything else</dt>
   <dd>Create a new DOCTYPE token. Set the token's name to the <a href="#current-input-character">current input character</a>.
   Switch to the <a href="#doctype-name-state">DOCTYPE name state</a>.</dd>

  </dl><h5 id="doctype-name-state"><span class="secno">8.2.4.54 </span><dfn>DOCTYPE name state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"tab" (U+0009)</dt>
   <dt>"LF" (U+000A)</dt>
   <dt>"FF" (U+000C)</dt>
   <!--<dt>"CR" (U+000D)</dt>-->
   <dt>U+0020 SPACE</dt>
   <dd>Switch to the <a href="#after-doctype-name-state">after DOCTYPE name state</a>.</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd>Switch to the <a href="#data-state">data state</a>. Emit the current DOCTYPE token.</dd>

   <dt><a data-anolis-xref="uppercase ASCII letters" href="infrastructure.html#uppercase-ascii-letters">Uppercase ASCII letter</a></dt>
   <dd>Append the lowercase version of the <a href="#current-input-character">current input character</a> (add 0x0020 to the
   character's code point) to the current DOCTYPE token's name.</dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Append a U+FFFD REPLACEMENT CHARACTER character to the current
   DOCTYPE token's name.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Set the DOCTYPE token's
   <i>force-quirks flag</i> to <i>on</i>. Emit that DOCTYPE token. Reconsume the EOF character.</dd>

   <dt>Anything else</dt>
   <dd>Append the <a href="#current-input-character">current input character</a> to the current DOCTYPE token's name.</dd>

  </dl><h5 id="after-doctype-name-state"><span class="secno">8.2.4.55 </span><dfn>After DOCTYPE name state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"tab" (U+0009)</dt>
   <dt>"LF" (U+000A)</dt>
   <dt>"FF" (U+000C)</dt>
   <!--<dt>"CR" (U+000D)</dt>-->
   <dt>U+0020 SPACE</dt>
   <dd>Ignore the character.</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd>Switch to the <a href="#data-state">data state</a>. Emit the current DOCTYPE token.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Set the DOCTYPE token's
   <i>force-quirks flag</i> to <i>on</i>. Emit that DOCTYPE token. Reconsume the EOF character.</dd>

   <dt>Anything else</dt>
   <dd>

    <p>If the six characters starting from the <a href="#current-input-character">current input character</a> are an
    <a href="infrastructure.html#ascii-case-insensitive">ASCII case-insensitive</a> match for the word "PUBLIC", then consume those characters
    and switch to the <a href="#after-doctype-public-keyword-state">after DOCTYPE public keyword state</a>.</p>

    <p>Otherwise, if the six characters starting from the <a href="#current-input-character">current input character</a> are
    an <a href="infrastructure.html#ascii-case-insensitive">ASCII case-insensitive</a> match for the word "SYSTEM", then consume those
    characters and switch to the <a href="#after-doctype-system-keyword-state">after DOCTYPE system keyword state</a>.</p>

    <p>Otherwise, this is a <a href="#parse-error">parse error</a>. Set the DOCTYPE token's <i>force-quirks
    flag</i> to <i>on</i>. Switch to the <a href="#bogus-doctype-state">bogus DOCTYPE state</a>.</p>

   </dd>

  </dl><h5 id="after-doctype-public-keyword-state"><span class="secno">8.2.4.56 </span><dfn>After DOCTYPE public keyword state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"tab" (U+0009)</dt>
   <dt>"LF" (U+000A)</dt>
   <dt>"FF" (U+000C)</dt>
   <!--<dt>"CR" (U+000D)</dt>-->
   <dt>U+0020 SPACE</dt>
   <dd>Switch to the <a href="#before-doctype-public-identifier-state">before DOCTYPE public identifier state</a>.</dd>

   <dt>U+0022 QUOTATION MARK (")</dt>
   <dd><a href="#parse-error">Parse error</a>. Set the DOCTYPE token's public identifier to the empty string (not
   missing), then switch to the <a href="#doctype-public-identifier-(double-quoted)-state">DOCTYPE public identifier (double-quoted) state</a>.</dd>

   <dt>"'" (U+0027)</dt>
   <dd><a href="#parse-error">Parse error</a>. Set the DOCTYPE token's public identifier to the empty string (not
   missing), then switch to the <a href="#doctype-public-identifier-(single-quoted)-state">DOCTYPE public identifier (single-quoted) state</a>.</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd><a href="#parse-error">Parse error</a>. Set the DOCTYPE token's <i>force-quirks flag</i> to <i>on</i>.
   Switch to the <a href="#data-state">data state</a>. Emit that DOCTYPE token.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Set the DOCTYPE token's
   <i>force-quirks flag</i> to <i>on</i>. Emit that DOCTYPE token. Reconsume the EOF character.</dd>

   <dt>Anything else</dt>
   <dd><a href="#parse-error">Parse error</a>. Set the DOCTYPE token's <i>force-quirks flag</i> to <i>on</i>.
   Switch to the <a href="#bogus-doctype-state">bogus DOCTYPE state</a>.</dd>

  </dl><h5 id="before-doctype-public-identifier-state"><span class="secno">8.2.4.57 </span><dfn>Before DOCTYPE public identifier state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"tab" (U+0009)</dt>
   <dt>"LF" (U+000A)</dt>
   <dt>"FF" (U+000C)</dt>
   <!--<dt>"CR" (U+000D)</dt>-->
   <dt>U+0020 SPACE</dt>
   <dd>Ignore the character.</dd>

   <dt>U+0022 QUOTATION MARK (")</dt>
   <dd>Set the DOCTYPE token's public identifier to the empty string (not missing), then switch to
   the <a href="#doctype-public-identifier-(double-quoted)-state">DOCTYPE public identifier (double-quoted) state</a>.</dd>

   <dt>"'" (U+0027)</dt>
   <dd>Set the DOCTYPE token's public identifier to the empty string (not missing), then switch to
   the <a href="#doctype-public-identifier-(single-quoted)-state">DOCTYPE public identifier (single-quoted) state</a>.</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd><a href="#parse-error">Parse error</a>. Set the DOCTYPE token's <i>force-quirks flag</i> to <i>on</i>.
   Switch to the <a href="#data-state">data state</a>. Emit that DOCTYPE token.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Set the DOCTYPE token's
   <i>force-quirks flag</i> to <i>on</i>. Emit that DOCTYPE token. Reconsume the EOF character.</dd>

   <dt>Anything else</dt>
   <dd><a href="#parse-error">Parse error</a>. Set the DOCTYPE token's <i>force-quirks flag</i> to <i>on</i>.
   Switch to the <a href="#bogus-doctype-state">bogus DOCTYPE state</a>.</dd>

  </dl><h5 id="doctype-public-identifier-(double-quoted)-state"><span class="secno">8.2.4.58 </span><dfn>DOCTYPE public identifier (double-quoted) state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>U+0022 QUOTATION MARK (")</dt>
   <dd>Switch to the <a href="#after-doctype-public-identifier-state">after DOCTYPE public identifier state</a>.</dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Append a U+FFFD REPLACEMENT CHARACTER character to the current
   DOCTYPE token's public identifier.</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd><a href="#parse-error">Parse error</a>. Set the DOCTYPE token's <i>force-quirks flag</i> to <i>on</i>.
   Switch to the <a href="#data-state">data state</a>. Emit that DOCTYPE token.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Set the DOCTYPE token's
   <i>force-quirks flag</i> to <i>on</i>. Emit that DOCTYPE token. Reconsume the EOF character.</dd>

   <dt>Anything else</dt>
   <dd>Append the <a href="#current-input-character">current input character</a> to the current DOCTYPE token's public
   identifier.</dd>

  </dl><h5 id="doctype-public-identifier-(single-quoted)-state"><span class="secno">8.2.4.59 </span><dfn>DOCTYPE public identifier (single-quoted) state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"'" (U+0027)</dt>
   <dd>Switch to the <a href="#after-doctype-public-identifier-state">after DOCTYPE public identifier state</a>.</dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Append a U+FFFD REPLACEMENT CHARACTER character to the current
   DOCTYPE token's public identifier.</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd><a href="#parse-error">Parse error</a>. Set the DOCTYPE token's <i>force-quirks flag</i> to <i>on</i>.
   Switch to the <a href="#data-state">data state</a>. Emit that DOCTYPE token.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Set the DOCTYPE token's
   <i>force-quirks flag</i> to <i>on</i>. Emit that DOCTYPE token. Reconsume the EOF character.</dd>

   <dt>Anything else</dt>
   <dd>Append the <a href="#current-input-character">current input character</a> to the current DOCTYPE token's public
   identifier.</dd>

  </dl><h5 id="after-doctype-public-identifier-state"><span class="secno">8.2.4.60 </span><dfn>After DOCTYPE public identifier state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"tab" (U+0009)</dt>
   <dt>"LF" (U+000A)</dt>
   <dt>"FF" (U+000C)</dt>
   <!--<dt>"CR" (U+000D)</dt>-->
   <dt>U+0020 SPACE</dt>
   <dd>Switch to the <a href="#between-doctype-public-and-system-identifiers-state">between DOCTYPE public and system identifiers state</a>.</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd>Switch to the <a href="#data-state">data state</a>. Emit the current DOCTYPE token.</dd>

   <dt>U+0022 QUOTATION MARK (")</dt>
   <dd><a href="#parse-error">Parse error</a>. Set the DOCTYPE token's system identifier to the empty string (not
   missing), then switch to the <a href="#doctype-system-identifier-(double-quoted)-state">DOCTYPE system identifier (double-quoted) state</a>.</dd>

   <dt>"'" (U+0027)</dt>
   <dd><a href="#parse-error">Parse error</a>. Set the DOCTYPE token's system identifier to the empty string (not
   missing), then switch to the <a href="#doctype-system-identifier-(single-quoted)-state">DOCTYPE system identifier (single-quoted) state</a>.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Set the DOCTYPE token's
   <i>force-quirks flag</i> to <i>on</i>. Emit that DOCTYPE token. Reconsume the EOF character.</dd>

   <dt>Anything else</dt>
   <dd><a href="#parse-error">Parse error</a>. Set the DOCTYPE token's <i>force-quirks flag</i> to <i>on</i>.
   Switch to the <a href="#bogus-doctype-state">bogus DOCTYPE state</a>.</dd>

  </dl><h5 id="between-doctype-public-and-system-identifiers-state"><span class="secno">8.2.4.61 </span><dfn>Between DOCTYPE public and system identifiers state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"tab" (U+0009)</dt>
   <dt>"LF" (U+000A)</dt>
   <dt>"FF" (U+000C)</dt>
   <!--<dt>"CR" (U+000D)</dt>-->
   <dt>U+0020 SPACE</dt>
   <dd>Ignore the character.</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd>Switch to the <a href="#data-state">data state</a>. Emit the current DOCTYPE token.</dd>

   <dt>U+0022 QUOTATION MARK (")</dt>
   <dd>Set the DOCTYPE token's system identifier to the empty string (not missing), then switch to
   the <a href="#doctype-system-identifier-(double-quoted)-state">DOCTYPE system identifier (double-quoted) state</a>.</dd>

   <dt>"'" (U+0027)</dt>
   <dd>Set the DOCTYPE token's system identifier to the empty string (not missing), then switch to
   the <a href="#doctype-system-identifier-(single-quoted)-state">DOCTYPE system identifier (single-quoted) state</a>.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Set the DOCTYPE token's
   <i>force-quirks flag</i> to <i>on</i>. Emit that DOCTYPE token. Reconsume the EOF character.</dd>

   <dt>Anything else</dt>
   <dd><a href="#parse-error">Parse error</a>. Set the DOCTYPE token's <i>force-quirks flag</i> to <i>on</i>.
   Switch to the <a href="#bogus-doctype-state">bogus DOCTYPE state</a>.</dd>

  </dl><h5 id="after-doctype-system-keyword-state"><span class="secno">8.2.4.62 </span><dfn>After DOCTYPE system keyword state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"tab" (U+0009)</dt>
   <dt>"LF" (U+000A)</dt>
   <dt>"FF" (U+000C)</dt>
   <!--<dt>"CR" (U+000D)</dt>-->
   <dt>U+0020 SPACE</dt>
   <dd>Switch to the <a href="#before-doctype-system-identifier-state">before DOCTYPE system identifier state</a>.</dd>

   <dt>U+0022 QUOTATION MARK (")</dt>
   <dd><a href="#parse-error">Parse error</a>. Set the DOCTYPE token's system identifier to the empty string (not
   missing), then switch to the <a href="#doctype-system-identifier-(double-quoted)-state">DOCTYPE system identifier (double-quoted) state</a>.</dd>

   <dt>"'" (U+0027)</dt>
   <dd><a href="#parse-error">Parse error</a>. Set the DOCTYPE token's system identifier to the empty string (not
   missing), then switch to the <a href="#doctype-system-identifier-(single-quoted)-state">DOCTYPE system identifier (single-quoted) state</a>.</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd><a href="#parse-error">Parse error</a>. Set the DOCTYPE token's <i>force-quirks flag</i> to <i>on</i>.
   Switch to the <a href="#data-state">data state</a>. Emit that DOCTYPE token.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Set the DOCTYPE token's
   <i>force-quirks flag</i> to <i>on</i>. Emit that DOCTYPE token. Reconsume the EOF character.</dd>

   <dt>Anything else</dt>
   <dd><a href="#parse-error">Parse error</a>. Set the DOCTYPE token's <i>force-quirks flag</i> to <i>on</i>.
   Switch to the <a href="#bogus-doctype-state">bogus DOCTYPE state</a>.</dd>

  </dl><h5 id="before-doctype-system-identifier-state"><span class="secno">8.2.4.63 </span><dfn>Before DOCTYPE system identifier state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"tab" (U+0009)</dt>
   <dt>"LF" (U+000A)</dt>
   <dt>"FF" (U+000C)</dt>
   <!--<dt>"CR" (U+000D)</dt>-->
   <dt>U+0020 SPACE</dt>
   <dd>Ignore the character.</dd>

   <dt>U+0022 QUOTATION MARK (")</dt>
   <dd>Set the DOCTYPE token's system identifier to the empty string (not missing), then switch to
   the <a href="#doctype-system-identifier-(double-quoted)-state">DOCTYPE system identifier (double-quoted) state</a>.</dd>

   <dt>"'" (U+0027)</dt>
   <dd>Set the DOCTYPE token's system identifier to the empty string (not missing), then switch to
   the <a href="#doctype-system-identifier-(single-quoted)-state">DOCTYPE system identifier (single-quoted) state</a>.</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd><a href="#parse-error">Parse error</a>. Set the DOCTYPE token's <i>force-quirks flag</i> to <i>on</i>.
   Switch to the <a href="#data-state">data state</a>. Emit that DOCTYPE token.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Set the DOCTYPE token's
   <i>force-quirks flag</i> to <i>on</i>. Emit that DOCTYPE token. Reconsume the EOF character.</dd>

   <dt>Anything else</dt>
   <dd><a href="#parse-error">Parse error</a>. Set the DOCTYPE token's <i>force-quirks flag</i> to <i>on</i>.
   Switch to the <a href="#bogus-doctype-state">bogus DOCTYPE state</a>.</dd>

  </dl><h5 id="doctype-system-identifier-(double-quoted)-state"><span class="secno">8.2.4.64 </span><dfn>DOCTYPE system identifier (double-quoted) state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>U+0022 QUOTATION MARK (")</dt>
   <dd>Switch to the <a href="#after-doctype-system-identifier-state">after DOCTYPE system identifier state</a>.</dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Append a U+FFFD REPLACEMENT CHARACTER character to the current
   DOCTYPE token's system identifier.</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd><a href="#parse-error">Parse error</a>. Set the DOCTYPE token's <i>force-quirks flag</i> to <i>on</i>.
   Switch to the <a href="#data-state">data state</a>. Emit that DOCTYPE token.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Set the DOCTYPE token's
   <i>force-quirks flag</i> to <i>on</i>. Emit that DOCTYPE token. Reconsume the EOF character.</dd>

   <dt>Anything else</dt>
   <dd>Append the <a href="#current-input-character">current input character</a> to the current DOCTYPE token's system
   identifier.</dd>

  </dl><h5 id="doctype-system-identifier-(single-quoted)-state"><span class="secno">8.2.4.65 </span><dfn>DOCTYPE system identifier (single-quoted) state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"'" (U+0027)</dt>
   <dd>Switch to the <a href="#after-doctype-system-identifier-state">after DOCTYPE system identifier state</a>.</dd>

   <dt>U+0000 NULL</dt>
   <dd><a href="#parse-error">Parse error</a>. Append a U+FFFD REPLACEMENT CHARACTER character to the current
   DOCTYPE token's system identifier.</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd><a href="#parse-error">Parse error</a>. Set the DOCTYPE token's <i>force-quirks flag</i> to <i>on</i>.
   Switch to the <a href="#data-state">data state</a>. Emit that DOCTYPE token.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Set the DOCTYPE token's
   <i>force-quirks flag</i> to <i>on</i>. Emit that DOCTYPE token. Reconsume the EOF character.</dd>

   <dt>Anything else</dt>
   <dd>Append the <a href="#current-input-character">current input character</a> to the current DOCTYPE token's system
   identifier.</dd>

  </dl><h5 id="after-doctype-system-identifier-state"><span class="secno">8.2.4.66 </span><dfn>After DOCTYPE system identifier state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"tab" (U+0009)</dt>
   <dt>"LF" (U+000A)</dt>
   <dt>"FF" (U+000C)</dt>
   <!--<dt>"CR" (U+000D)</dt>-->
   <dt>U+0020 SPACE</dt>
   <dd>Ignore the character.</dd>

   <dt>"&gt;" (U+003E)</dt>
   <dd>Switch to the <a href="#data-state">data state</a>. Emit the current DOCTYPE token.</dd>

   <dt>EOF</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#data-state">data state</a>. Set the DOCTYPE token's
   <i>force-quirks flag</i> to <i>on</i>. Emit that DOCTYPE token. Reconsume the EOF character.</dd>

   <dt>Anything else</dt>
   <dd><a href="#parse-error">Parse error</a>. Switch to the <a href="#bogus-doctype-state">bogus DOCTYPE state</a>. (This does
   <em>not</em> set the DOCTYPE token's <i>force-quirks flag</i> to <i>on</i>.)</dd>

  </dl><h5 id="bogus-doctype-state"><span class="secno">8.2.4.67 </span><dfn>Bogus DOCTYPE state</dfn></h5>

  <p>Consume the <a href="#next-input-character">next input character</a>:</p>

  <dl class="switch"><dt>"&gt;" (U+003E)</dt>
   <dd>Switch to the <a href="#data-state">data state</a>. Emit the DOCTYPE token.</dd>

   <dt>EOF</dt>
   <dd>Switch to the <a href="#data-state">data state</a>. Emit the DOCTYPE token. Reconsume the EOF
   character.</dd>

   <dt>Anything else</dt>
   <dd>Ignore the character.</dd>

  </dl><h5 id="cdata-section-state"><span class="secno">8.2.4.68 </span><dfn>CDATA section state</dfn></h5>

  <p>Switch to the <a href="#data-state">data state</a>.</p>

  <p>Consume every character up to the next occurrence of the three character sequence U+005D RIGHT
  SQUARE BRACKET U+005D RIGHT SQUARE BRACKET U+003E GREATER-THAN SIGN (<code data-anolis-xref="">]]&gt;</code>),
  or the end of the file (EOF), whichever comes first. Emit a series of character tokens consisting
  of all the characters consumed except the matching three character sequence at the end (if one was
  found before the end of the file)<!--(not needed; taken care of by the tree constructor), but with
  any U+0000 NULL characters replaced by U+FFFD REPLACEMENT CHARACTER characters-->.</p>

  <p>If the end of the file was reached, reconsume the EOF character.</p>



  <h5 id="tokenizing-character-references"><span class="secno">8.2.4.69 </span>Tokenizing character references</h5>

  <p>This section defines how to <dfn id="consume-a-character-reference">consume a character reference</dfn>, optionally with an
  <dfn id="additional-allowed-character">additional allowed character</dfn>, which, if specified where the algorithm is invoked, adds
  a character to the list of characters that cause there to not be a character reference.</p>

  <p>This definition is used when parsing character references <a data-anolis-xref="character reference in
  data state" href="#character-reference-in-data-state">in text</a> and <a data-anolis-xref="character reference in attribute value state" href="#character-reference-in-attribute-value-state">in
  attributes</a>.</p>

  <p>The behavior depends on the identity of the next character (the one immediately after the
  U+0026 AMPERSAND character), as follows:</p>

  <dl class="switch"><dt>"tab" (U+0009)</dt>
   <dt>"LF" (U+000A)</dt>
   <dt>"FF" (U+000C)</dt>
   <!--<dt>"CR" (U+000D)</dt>-->
   <dt>U+0020 SPACE</dt>
   <dt>U+003C LESS-THAN SIGN</dt>
   <dt>U+0026 AMPERSAND</dt>
   <dt>EOF</dt>
   <dt>The <a href="#additional-allowed-character">additional allowed character</a>, if there is one</dt>

   <dd>Not a character reference. No characters are consumed, and nothing is returned. (This is not
   an error, either.)</dd>


   <dt>"#" (U+0023)</dt>

   <dd>

    <p>Consume the U+0023 NUMBER SIGN.</p>

    <p>The behavior further depends on the character after the U+0023 NUMBER SIGN:</p>

    <dl class="switch"><dt>U+0078 LATIN SMALL LETTER X</dt>
     <dt>U+0058 LATIN CAPITAL LETTER X</dt>

     <dd>

      <p>Consume the X.</p>

      <p>Follow the steps below, but using <a href="infrastructure.html#ascii-hex-digits">ASCII hex digits</a>.</p>

      <p>When it comes to interpreting the number, interpret it as a hexadecimal number.</p>

     </dd>


     <dt>Anything else</dt>

     <dd>

      <p>Follow the steps below, but using <a href="infrastructure.html#ascii-digits">ASCII digits</a>.</p>

      <p>When it comes to interpreting the number, interpret it as a decimal number.</p>

     </dd>

    </dl><p>Consume as many characters as match the range of characters given above (<a href="infrastructure.html#ascii-hex-digits">ASCII hex
    digits</a> or <a href="infrastructure.html#ascii-digits">ASCII digits</a>).</p>

    <p>If no characters match the range, then don't consume any characters (and unconsume the U+0023
    NUMBER SIGN character and, if appropriate, the X character). This is a <a href="#parse-error">parse error</a>;
    nothing is returned.</p>

    <p>Otherwise, if the next character is a U+003B SEMICOLON, consume that too. If it isn't, there
    is a <a href="#parse-error">parse error</a>.</p>

    <p>If one or more characters match the range, then take them all and interpret the string of
    characters as a number (either hexadecimal or decimal as appropriate).</p>

    <p>If that number is one of the numbers in the first column of the following table, then this is
    a <a href="#parse-error">parse error</a>. Find the row with that number in the first column, and return a
    character token for the Unicode character given in the second column of that row.</p>

    <table id="table-charref-overrides"><thead><tr><th>Number </th><th colspan="2">Unicode character
     <tbody></th></tr><tr><td>0x00 </td><td>U+FFFD </td><td>REPLACEMENT CHARACTER
      <!-- <tr><td>0x0D <td>U+000D <td>CARRIAGE RETURN (CR) -->
      </td></tr><tr><td>0x80 </td><td>U+20AC </td><td>EURO SIGN (€)
      <!-- <tr><td>0x81 <td>U+0081 <td>&lt;control> -->
      </td></tr><tr><td>0x82 </td><td>U+201A </td><td>SINGLE LOW-9 QUOTATION MARK (‚)
      </td></tr><tr><td>0x83 </td><td>U+0192 </td><td>LATIN SMALL LETTER F WITH HOOK (ƒ)
      </td></tr><tr><td>0x84 </td><td>U+201E </td><td>DOUBLE LOW-9 QUOTATION MARK („)
      </td></tr><tr><td>0x85 </td><td>U+2026 </td><td>HORIZONTAL ELLIPSIS (…)
      </td></tr><tr><td>0x86 </td><td>U+2020 </td><td>DAGGER (†)
      </td></tr><tr><td>0x87 </td><td>U+2021 </td><td>DOUBLE DAGGER (‡)
      </td></tr><tr><td>0x88 </td><td>U+02C6 </td><td>MODIFIER LETTER CIRCUMFLEX ACCENT (ˆ)
      </td></tr><tr><td>0x89 </td><td>U+2030 </td><td>PER MILLE SIGN (‰)
      </td></tr><tr><td>0x8A </td><td>U+0160 </td><td>LATIN CAPITAL LETTER S WITH CARON (Š)
      </td></tr><tr><td>0x8B </td><td>U+2039 </td><td>SINGLE LEFT-POINTING ANGLE QUOTATION MARK (‹)
      </td></tr><tr><td>0x8C </td><td>U+0152 </td><td>LATIN CAPITAL LIGATURE OE (Œ)
      <!-- <tr><td>0x8D <td>U+008D <td>&lt;control> -->
      </td></tr><tr><td>0x8E </td><td>U+017D </td><td>LATIN CAPITAL LETTER Z WITH CARON (Ž)
      <!-- <tr><td>0x8F <td>U+008F <td>&lt;control> -->
      <!-- <tr><td>0x90 <td>U+0090 <td>&lt;control> -->
      </td></tr><tr><td>0x91 </td><td>U+2018 </td><td>LEFT SINGLE QUOTATION MARK (‘)
      </td></tr><tr><td>0x92 </td><td>U+2019 </td><td>RIGHT SINGLE QUOTATION MARK (’)
      </td></tr><tr><td>0x93 </td><td>U+201C </td><td>LEFT DOUBLE QUOTATION MARK (“)
      </td></tr><tr><td>0x94 </td><td>U+201D </td><td>RIGHT DOUBLE QUOTATION MARK (”)
      </td></tr><tr><td>0x95 </td><td>U+2022 </td><td>BULLET (•)
      </td></tr><tr><td>0x96 </td><td>U+2013 </td><td>EN DASH (–)
      </td></tr><tr><td>0x97 </td><td>U+2014 </td><td>EM DASH (—)
      </td></tr><tr><td>0x98 </td><td>U+02DC </td><td>SMALL TILDE (˜)
      </td></tr><tr><td>0x99 </td><td>U+2122 </td><td>TRADE MARK SIGN (™)
      </td></tr><tr><td>0x9A </td><td>U+0161 </td><td>LATIN SMALL LETTER S WITH CARON (š)
      </td></tr><tr><td>0x9B </td><td>U+203A </td><td>SINGLE RIGHT-POINTING ANGLE QUOTATION MARK (›)
      </td></tr><tr><td>0x9C </td><td>U+0153 </td><td>LATIN SMALL LIGATURE OE (œ)
      <!-- <tr><td>0x9D <td>U+009D <td>&lt;control> -->
      </td></tr><tr><td>0x9E </td><td>U+017E </td><td>LATIN SMALL LETTER Z WITH CARON (ž)
      </td></tr><tr><td>0x9F </td><td>U+0178 </td><td>LATIN CAPITAL LETTER Y WITH DIAERESIS (Ÿ)
    </td></tr></table><p>Otherwise, if the number is in the range 0xD800 to 0xDFFF<!-- surrogates --> or is greater
    than 0x10FFFF, then this is a <a href="#parse-error">parse error</a>. Return a U+FFFD REPLACEMENT CHARACTER
    character token.</p>

    <p>Otherwise, return a character token for the Unicode character whose code point is that
    number.

    <!-- this is the same as the equivalent list in the input stream section, except U+000D is not
    allowed --> Additionally, if the number is in the range 0x0001 to 0x0008, <!-- HT, LF allowed
    --> <!-- U+000B is in the next list --> <!-- FF allowed --> 0x000D to 0x001F, <!-- ASCII allowed
    --> 0x007F <!--to 0x0084, (0x0085 NEL not allowed), 0x0086--> to 0x009F, 0xFDD0 to 0xFDEF, or is
    one of 0x000B, 0xFFFE, 0xFFFF, 0x1FFFE, 0x1FFFF, 0x2FFFE, 0x2FFFF, 0x3FFFE, 0x3FFFF, 0x4FFFE,
    0x4FFFF, 0x5FFFE, 0x5FFFF, 0x6FFFE, 0x6FFFF, 0x7FFFE, 0x7FFFF, 0x8FFFE, 0x8FFFF, 0x9FFFE,
    0x9FFFF, 0xAFFFE, 0xAFFFF, 0xBFFFE, 0xBFFFF, 0xCFFFE, 0xCFFFF, 0xDFFFE, 0xDFFFF, 0xEFFFE,
    0xEFFFF, 0xFFFFE, 0xFFFFF, 0x10FFFE, or 0x10FFFF, then this is a <a href="#parse-error">parse error</a>.</p>

   </dd>


   <dt>Anything else</dt>

   <dd>

    <p>Consume the maximum number of characters possible, with the consumed characters matching one
    of the identifiers in the first column of the <a href="#named-character-references">named character references</a> table (in
    a <a href="infrastructure.html#case-sensitive">case-sensitive</a> manner).</p>

    <p>If no match can be made, then no characters are consumed, and nothing is returned. In this
    case, if the characters after the U+0026 AMPERSAND character (&amp;) consist of a sequence of
    one or more <a href="infrastructure.html#alphanumeric-ascii-characters">alphanumeric ASCII characters</a> followed by a U+003B SEMICOLON character
    (;), then this is a <a href="#parse-error">parse error</a>.</p>

    <p>If the character reference is being consumed <a data-anolis-xref="character reference in attribute
    value state" href="#character-reference-in-attribute-value-state">as part of an attribute</a>, and the last character matched is not a ";" (U+003B) character, and the next character is either a "=" (U+003D) character or
    an <a data-anolis-xref="alphanumeric ASCII characters" href="infrastructure.html#alphanumeric-ascii-characters">alphanumeric ASCII character</a>, then, for
    historical reasons, all the characters that were matched after the U+0026 AMPERSAND character
    (&amp;) must be unconsumed, and nothing is returned. <!-- "=" added because of
    http://www.w3.org/Bugs/Public/show_bug.cgi?id=9207#c5 -->

    However, if this next character is in fact a "=" (U+003D) character, then this is a
    <a href="#parse-error">parse error</a>, because some legacy user agents <!-- IE, version 9 and before --> will
    misinterpret the markup in those cases.</p> <!-- v2: should make this no longer a conformance
    error at some point in the future; revisit in 2015? -->

    <p>Otherwise, a character reference is parsed. If the last character matched is not a ";" (U+003B) character, there is a <a href="#parse-error">parse error</a>.</p>

    <p>Return one or two character tokens for the character(s) corresponding to the character
    reference name (as given by the second column of the <a href="#named-character-references">named character references</a>
    table).</p>

    <div class="example">

     <p>If the markup contains (not in an attribute) the string <code data-anolis-xref="">I'm &amp;notit; I
     tell you</code>, the character reference is parsed as "not", as in, <code data-anolis-xref="">I'm ¬it;
     I tell you</code> (and this is a parse error). But if the markup was <code data-anolis-xref="">I'm
     &amp;notin; I tell you</code>, the character reference would be parsed as "notin;", resulting
     in <code data-anolis-xref="">I'm ∉ I tell you</code> (and no parse error).</p>

    </div>

   </dd>

  </dl></div>


  <div class="impl">

  <!-- v2: One thing that this doesn't define is handling deeply nested documents. There are
  compatibility requirements around that: you can't throw away the elements altogether, consider Tux
  made only with opening <font> elements, one per character. Seems that the best thing to do is to
  close some formatting elements from the middle of the stack when you hit a limit, or something.
  -->

  <h4 id="tree-construction"><span class="secno">8.2.5 </span><dfn>Tree construction</dfn></h4>

  <p>The input to the tree construction stage is a sequence of tokens from the
  <a href="#tokenization">tokenization</a> stage. The tree construction stage is associated with a DOM
  <code><a href="dom.html#document">Document</a></code> object when a parser is created. The "output" of this stage consists of
  dynamically modifying or extending that document's DOM tree.</p>

  <p>This specification does not define when an interactive user agent has to render the
  <code><a href="dom.html#document">Document</a></code> so that it is available to the user, or when it has to begin accepting user
  input.</p>

  <hr><p>As each token is emitted from the tokenizer, the user agent must follow the appropriate steps
  from the following list, known as the <dfn id="tree-construction-dispatcher">tree construction dispatcher</dfn>:</p>

  <dl class="switch"><dt>If there is no <a href="#adjusted-current-node">adjusted current node</a></dt>
   <dt>If the <a href="#adjusted-current-node">adjusted current node</a> is an element in the <a href="infrastructure.html#html-namespace-0">HTML namespace</a></dt>
   <dt>If the <a href="#adjusted-current-node">adjusted current node</a> is a <a href="#mathml-text-integration-point">MathML text integration point</a> and the token is a start tag whose tag name is neither "mglyph" nor "malignmark"</dt>
   <dt>If the <a href="#adjusted-current-node">adjusted current node</a> is a <a href="#mathml-text-integration-point">MathML text integration point</a> and the token is a character token</dt>
   <dt>If the <a href="#adjusted-current-node">adjusted current node</a> is an <code data-anolis-xref="">annotation-xml</code> element in the <a href="infrastructure.html#mathml-namespace">MathML namespace</a> and the token is a start tag whose tag name is "svg"</dt>
   <dt>If the <a href="#adjusted-current-node">adjusted current node</a> is an <a href="#html-integration-point">HTML integration point</a> and the token is a start tag</dt>
   <dt>If the <a href="#adjusted-current-node">adjusted current node</a> is an <a href="#html-integration-point">HTML integration point</a> and the token is a character token</dt>
   <dt>If the token is an end-of-file token</dt>

   <dd>Process the token according to the rules given in the section corresponding to the current
   <a href="#insertion-mode">insertion mode</a> in HTML content.</dd>

   <dt>Otherwise</dt>

   <dd>Process the token according to the rules given in the section for parsing tokens <a data-anolis-xref="insertion mode: in foreign content" href="#parsing-main-inforeign">in foreign content</a>.</dd>

  </dl><p>The <dfn id="next-token">next token</dfn> is the token that is about to be processed by the <a href="#tree-construction-dispatcher">tree
  construction dispatcher</a> (even if the token is subsequently just ignored).</p>

  <p>A node is a <dfn id="mathml-text-integration-point">MathML text integration point</dfn> if it is one of the following
  elements:</p>

  <ul class="brief"><li>An <code data-anolis-xref="">mi</code> element in the <a href="infrastructure.html#mathml-namespace">MathML namespace</a></li>
   <li>An <code data-anolis-xref="">mo</code> element in the <a href="infrastructure.html#mathml-namespace">MathML namespace</a></li>
   <li>An <code data-anolis-xref="">mn</code> element in the <a href="infrastructure.html#mathml-namespace">MathML namespace</a></li>
   <li>An <code data-anolis-xref="">ms</code> element in the <a href="infrastructure.html#mathml-namespace">MathML namespace</a></li>
   <li>An <code data-anolis-xref="">mtext</code> element in the <a href="infrastructure.html#mathml-namespace">MathML namespace</a></li>
  </ul><p>A node is an <dfn id="html-integration-point">HTML integration point</dfn> if it is one of the following elements:</p>

  <ul class="brief"><li>An <code data-anolis-xref="">annotation-xml</code> element in the <a href="infrastructure.html#mathml-namespace">MathML namespace</a> whose
   start tag token had an attribute with the name "encoding" whose value was an <a href="infrastructure.html#ascii-case-insensitive">ASCII
   case-insensitive</a> match for the string "<code data-anolis-xref="">text/html</code>"</li>
   <li>An <code data-anolis-xref="">annotation-xml</code> element in the <a href="infrastructure.html#mathml-namespace">MathML namespace</a> whose
   start tag token had an attribute with the name "encoding" whose value was an <a href="infrastructure.html#ascii-case-insensitive">ASCII
   case-insensitive</a> match for the string "<code data-anolis-xref="">application/xhtml+xml</code>"</li>
   <li>A <code data-anolis-xref="">foreignObject</code> element in the <a href="infrastructure.html#svg-namespace">SVG namespace</a></li>
   <li>A <code data-anolis-xref="">desc</code> element in the <a href="infrastructure.html#svg-namespace">SVG namespace</a></li>
   <li>A <code data-anolis-xref="">title</code> element in the <a href="infrastructure.html#svg-namespace">SVG namespace</a></li>
  </ul><p class="note">Not all of the tag names mentioned below are conformant tag names in this
  specification; many are included to handle legacy content. They still form part of the algorithm
  that implementations are required to implement to claim conformance.</p>

  <p class="note">The algorithm described below places no limit on the depth of the DOM tree
  generated, or on the length of tag names, attribute names, attribute values, <code><a href="infrastructure.html#text-0">Text</a></code>
  nodes, etc. While implementors are encouraged to avoid arbitrary limits, it is recognized that <a href="infrastructure.html#hardwareLimitations">practical concerns</a> will likely force user agents to impose nesting
  depth constraints.</p>


  <h5 id="creating-and-inserting-nodes"><span class="secno">8.2.5.1 </span>Creating and inserting nodes</h5>

  <p>While the parser is processing a token, it can enable or disable <dfn data-anolis-xref="foster
  parent" id="foster-parent">foster parenting</dfn>. This affects the following algorithm.</p>

  <p>The <dfn id="appropriate-place-for-inserting-a-node">appropriate place for inserting a node</dfn>, optionally using a particular
  <i>override target</i>, is the position in an element returned by running the following steps:</p>

  <ol><li>

    <p>If there was an <i>override target</i> specified, then let <var data-anolis-xref="">target</var> be the
    <i>override target</i>.</p>

    <p>Otherwise, let <var data-anolis-xref="">target</var> be the <a href="#current-node">current node</a>.</p>

   </li>

   <li>

    <p>Determine the <var data-anolis-xref="">adjusted insertion location</var> using the first matching steps
    from the following list:</p>

    <dl class="switch"><dt>If <a data-anolis-xref="foster parent" href="#foster-parent">foster parenting</a> is enabled and <var data-anolis-xref="">target</var> is a <code><a href="tabular-data.html#the-table-element">table</a></code>, <code><a href="tabular-data.html#the-tbody-element">tbody</a></code>, <code><a href="tabular-data.html#the-tfoot-element">tfoot</a></code>,
     <code><a href="tabular-data.html#the-thead-element">thead</a></code>, or <code><a href="tabular-data.html#the-tr-element">tr</a></code> element</dt>

     <dd>

      <p class="note">Foster parenting happens when content is misnested in tables.</p>

      <p>Run these substeps:</p>

      <ol><li><p>Let <var data-anolis-xref="">last template</var> be the last <code><a href="scripting-1.html#the-template-element">template</a></code> element in the
       <a href="#stack-of-open-elements">stack of open elements</a>, if any.</p>

       </li><li><p>Let <var data-anolis-xref="">last table</var> be the last <code><a href="tabular-data.html#the-table-element">table</a></code> element in the
       <a href="#stack-of-open-elements">stack of open elements</a>, if any.</p>

       </li><li><p>If there is a <var data-anolis-xref="">last template</var> and either there is no <var data-anolis-xref="">last table</var>, or there is one, but <var data-anolis-xref="">last template</var> is lower
       (more recently added) than <var data-anolis-xref="">last table</var> in the <a href="#stack-of-open-elements">stack of open
       elements</a>, then: let <var data-anolis-xref="">adjusted insertion location</var> be inside <var data-anolis-xref="">last template</var>'s <a href="scripting-1.html#template-contents">template contents</a>, after its last child (if any),
       and abort these substeps.</li>

       <li><p>If there is no <var data-anolis-xref="">last table</var>, <!-- there's also implicitly no last
       template, since we didn't hit the previous step --> then let <var data-anolis-xref="">adjusted insertion
       location</var> be inside the first element in the <a href="#stack-of-open-elements">stack of open elements</a> (the
       <code><a href="semantics.html#the-html-element">html</a></code> element), after its last child (if any), and abort these substeps.
       (<a href="#fragment-case">fragment case</a>)</p>

       <!-- if we get here, we know there's a last table, and if there's a last template, it's older
       than the last table. -->

       </li><li><p>If <var data-anolis-xref="">last table</var> has a parent element, then let <var data-anolis-xref="">adjusted insertion location</var> be inside <var data-anolis-xref="">last table</var>'s parent
       element, immediately before <var data-anolis-xref="">last table</var>, and abort these
       substeps.</li>

       <!-- if we get here, we know there's a last table, but it has no parent, and if there's a
       last template, it's older than the last table. -->

       <li><p>Let <var data-anolis-xref="">previous element</var> be the element immediately above <var data-anolis-xref="">last table</var> in the <a href="#stack-of-open-elements">stack of open elements</a>.</li>

       <li><p>Let <var data-anolis-xref="">adjusted insertion location</var> be inside <var data-anolis-xref="">previous
       element</var>, after its last child (if any).</li>

      </ol><p class="note">These steps are involved in part because it's possible for elements, the
      <code><a href="tabular-data.html#the-table-element">table</a></code> element in this case in particular, to have been moved by a script around
      in the DOM, or indeed removed from the DOM entirely, after the element was inserted by the
      parser.</p>

     </dd>

     <dt>Otherwise</dt>

     <dd>

      <p>Let <var data-anolis-xref="">adjusted insertion location</var> be inside <var data-anolis-xref="">target</var>,
      after its last child (if any).</p>

     </dd>

    </dl></li>

   <li>

    <p>If the <var data-anolis-xref="">adjusted insertion location</var> is inside a <code><a href="scripting-1.html#the-template-element">template</a></code>
    element, let it instead be inside the <code><a href="scripting-1.html#the-template-element">template</a></code> element's <a href="scripting-1.html#template-contents">template
    contents</a>, after its last child (if any).</p>

   </li>

   <li>

    <p>Return the <var data-anolis-xref="">adjusted insertion location</var>.</p>

   </li>

  </ol><hr><p>When the steps below require the UA to <dfn data-anolis-xref="create an element for the token" id="create-an-element-for-the-token">create an
  element for a token</dfn> in a particular <var data-anolis-xref="">given namespace</var> and with a
  particular <var data-anolis-xref="">intended parent</var>, the UA must run the following steps:</p>

  <ol><li>

    <p>Create a node implementing the interface appropriate for the element type corresponding to
    the tag name of the token in <var data-anolis-xref="">given namespace</var> (as given in the specification
    that defines that element, e.g. for an <code><a href="text-level-semantics.html#the-a-element">a</a></code> element in the <a href="infrastructure.html#html-namespace-0">HTML
    namespace</a>, this specification defines it to be the <code><a href="text-level-semantics.html#htmlanchorelement">HTMLAnchorElement</a></code>
    interface), with the tag name being the name of that element, with the node being in the given
    namespace, and with the attributes on the node being those given in the given token.</p>

    <p>The interface appropriate for an element in the <a href="infrastructure.html#html-namespace-0">HTML namespace</a> that is not
    defined in this specification (or <a href="infrastructure.html#other-applicable-specifications">other applicable specifications</a>) is
    <code><a href="dom.html#htmlunknownelement">HTMLUnknownElement</a></code>. Elements in other namespaces whose interface is not defined by
    that namespace's specification must use the interface <code><a href="infrastructure.html#element">Element</a></code>.</p>

    <p>The <code data-anolis-xref="dom-Node-ownerDocument"><a href="infrastructure.html#dom-node-ownerdocument">ownerDocument</a></code> of the newly created element
    must be the same as that of the <var data-anolis-xref="">intended parent</var>.</p>

   </li>

   <li><p>If the newly created element has an <code data-anolis-xref="">xmlns</code> attribute <em>in the
   <a href="infrastructure.html#xmlns-namespace">XMLNS namespace</a></em> whose value is not exactly the same as the element's namespace,
   that is a <a href="#parse-error">parse error</a>. Similarly, if the newly created element has an <code data-anolis-xref="">xmlns:xlink</code> attribute in the <a href="infrastructure.html#xmlns-namespace">XMLNS namespace</a> whose value is not the
   <a href="infrastructure.html#xlink-namespace">XLink Namespace</a>, that is a <a href="#parse-error">parse error</a>.</li>

   <li><p>If the newly created element is a <a data-anolis-xref="category-reset" href="forms.html#category-reset">resettable element</a>,
   invoke its <a data-anolis-xref="concept-form-reset-control" href="forms.html#concept-form-reset-control">reset algorithm</a>. (This initializes the
   element's <a data-anolis-xref="concept-fe-value" href="forms.html#concept-fe-value">value</a> and <a data-anolis-xref="concept-fe-checked" href="forms.html#concept-fe-checked">checkedness</a> based on the element's attributes.)</li>

   <li><p>If the element is a <a href="forms.html#form-associated-element">form-associated element</a>, and the <a href="#form-element-pointer"><code data-anolis-xref="">form</code> element pointer</a> is not null, and there is no <code><a href="scripting-1.html#the-template-element">template</a></code>
   element on the <a href="#stack-of-open-elements">stack of open elements</a>, and the newly created element is either not
   <a data-anolis-xref="category-form-attr" href="forms.html#category-form-attr">reassociateable</a> or doesn't have a <code data-anolis-xref="attr-fae-form"><a href="forms.html#attr-fae-form">form</a></code> attribute, and the <var data-anolis-xref="">intended parent</var> is in
   the same <a href="infrastructure.html#home-subtree">home subtree</a> as the element pointed to by the <a href="#form-element-pointer"><code data-anolis-xref="">form</code> element pointer</a>, <a data-anolis-xref="concept-form-association" href="forms.html#concept-form-association">associate</a> the newly created element with the
   <code><a href="forms.html#the-form-element">form</a></code> element pointed to by the <a href="#form-element-pointer"><code data-anolis-xref="">form</code> element
   pointer</a>, and suppress the running of the <a href="forms.html#reset-the-form-owner">reset the form owner</a> algorithm when
   the parser subsequently attempts to insert the element.</li>

   <li><p>Return the newly created element.</li>

  </ol><hr><!-- The names of these algorithms are kinda confusing; e.g. see the confusion in
         https://www.w3.org/Bugs/Public/show_bug.cgi?id=18367
       Not sure what we could call them instead, though... --><p>When the steps below require the user agent to <dfn id="insert-a-foreign-element">insert a foreign element</dfn> for a token
  in a given namespace, the user agent must run these steps:</p>

  <ol><li><p>Let the <var data-anolis-xref="">adjusted insertion location</var> be the <a href="#appropriate-place-for-inserting-a-node">appropriate place for
   inserting a node</a>.</li>

   <li><p><a href="#create-an-element-for-the-token">Create an element for the token</a> in the given namespace, with the intended
   parent being the element in which the <var data-anolis-xref="">adjusted insertion location</var> finds
   itself.</li>

   <li>

    <p>If it is possible to insert an element at the <var data-anolis-xref="">adjusted insertion
    location</var>, then insert the newly created element at the <var data-anolis-xref="">adjusted insertion
    location</var>.</p>

    <p class="note">If the <var data-anolis-xref="">adjusted insertion location</var> cannot accept more
    elements, e.g. because it's a <code><a href="dom.html#document">Document</a></code> that already has an element child, then the
    newly created element is dropped on the floor.</p>

   </li>

   <li><p>Push the element onto the <a href="#stack-of-open-elements">stack of open elements</a> so that it is the new
   <a href="#current-node">current node</a>.</li>

   <li><p>Return the newly created element.</li>

  </ol><p>When the steps below require the user agent to <dfn id="insert-an-html-element">insert an HTML element</dfn> for a token,
  the user agent must <a href="#insert-a-foreign-element">insert a foreign element</a> for the token, in the <a href="infrastructure.html#html-namespace-0">HTML
  namespace</a>.</p>

  <hr><p>When the steps below require the user agent to <dfn id="adjust-mathml-attributes">adjust MathML attributes</dfn> for a token,
  then, if the token has an attribute named <code data-anolis-xref="">definitionurl</code>, change its name to
  <code data-anolis-xref="">definitionURL</code> (note the case difference).</p>

  <p>When the steps below require the user agent to <dfn id="adjust-svg-attributes">adjust SVG attributes</dfn> for a token,
  then, for each attribute on the token whose attribute name is one of the ones in the first column
  of the following table, change the attribute's name to the name given in the corresponding cell in
  the second column. (This fixes the case of SVG attributes that are not all lowercase.)</p>

  <table><thead><tr><th> Attribute name on token </th><th> Attribute name on element
   <tbody></th></tr><tr><td> <code data-anolis-xref="">attributename</code> </td><td> <code data-anolis-xref="">attributeName</code>
    </td></tr><tr><td> <code data-anolis-xref="">attributetype</code> </td><td> <code data-anolis-xref="">attributeType</code>
    </td></tr><tr><td> <code data-anolis-xref="">basefrequency</code> </td><td> <code data-anolis-xref="">baseFrequency</code>
    </td></tr><tr><td> <code data-anolis-xref="">baseprofile</code> </td><td> <code data-anolis-xref="">baseProfile</code>
    </td></tr><tr><td> <code data-anolis-xref="">calcmode</code> </td><td> <code data-anolis-xref="">calcMode</code>
    </td></tr><tr><td> <code data-anolis-xref="">clippathunits</code> </td><td> <code data-anolis-xref="">clipPathUnits</code>
    </td></tr><tr><td> <code data-anolis-xref="">contentscripttype</code> </td><td> <code data-anolis-xref="">contentScriptType</code>
    </td></tr><tr><td> <code data-anolis-xref="">contentstyletype</code> </td><td> <code data-anolis-xref="">contentStyleType</code>
    </td></tr><tr><td> <code data-anolis-xref="">diffuseconstant</code> </td><td> <code data-anolis-xref="">diffuseConstant</code>
    </td></tr><tr><td> <code data-anolis-xref="">edgemode</code> </td><td> <code data-anolis-xref="">edgeMode</code>
    </td></tr><tr><td> <code data-anolis-xref="">externalresourcesrequired</code> </td><td> <code data-anolis-xref="">externalResourcesRequired</code>
    </td></tr><tr><td> <code data-anolis-xref="">filterres</code> </td><td> <code data-anolis-xref="">filterRes</code>
    </td></tr><tr><td> <code data-anolis-xref="">filterunits</code> </td><td> <code data-anolis-xref="">filterUnits</code>
    </td></tr><tr><td> <code data-anolis-xref="">glyphref</code> </td><td> <code data-anolis-xref="">glyphRef</code>
    </td></tr><tr><td> <code data-anolis-xref="">gradienttransform</code> </td><td> <code data-anolis-xref="">gradientTransform</code>
    </td></tr><tr><td> <code data-anolis-xref="">gradientunits</code> </td><td> <code data-anolis-xref="">gradientUnits</code>
    </td></tr><tr><td> <code data-anolis-xref="">kernelmatrix</code> </td><td> <code data-anolis-xref="">kernelMatrix</code>
    </td></tr><tr><td> <code data-anolis-xref="">kernelunitlength</code> </td><td> <code data-anolis-xref="">kernelUnitLength</code>
    </td></tr><tr><td> <code data-anolis-xref="">keypoints</code> </td><td> <code data-anolis-xref="">keyPoints</code>
    </td></tr><tr><td> <code data-anolis-xref="">keysplines</code> </td><td> <code data-anolis-xref="">keySplines</code>
    </td></tr><tr><td> <code data-anolis-xref="">keytimes</code> </td><td> <code data-anolis-xref="">keyTimes</code>
    </td></tr><tr><td> <code data-anolis-xref="">lengthadjust</code> </td><td> <code data-anolis-xref="">lengthAdjust</code>
    </td></tr><tr><td> <code data-anolis-xref="">limitingconeangle</code> </td><td> <code data-anolis-xref="">limitingConeAngle</code>
    </td></tr><tr><td> <code data-anolis-xref="">markerheight</code> </td><td> <code data-anolis-xref="">markerHeight</code>
    </td></tr><tr><td> <code data-anolis-xref="">markerunits</code> </td><td> <code data-anolis-xref="">markerUnits</code>
    </td></tr><tr><td> <code data-anolis-xref="">markerwidth</code> </td><td> <code data-anolis-xref="">markerWidth</code>
    </td></tr><tr><td> <code data-anolis-xref="">maskcontentunits</code> </td><td> <code data-anolis-xref="">maskContentUnits</code>
    </td></tr><tr><td> <code data-anolis-xref="">maskunits</code> </td><td> <code data-anolis-xref="">maskUnits</code>
    </td></tr><tr><td> <code data-anolis-xref="">numoctaves</code> </td><td> <code data-anolis-xref="">numOctaves</code>
    </td></tr><tr><td> <code data-anolis-xref="">pathlength</code> </td><td> <code data-anolis-xref="">pathLength</code>
    </td></tr><tr><td> <code data-anolis-xref="">patterncontentunits</code> </td><td> <code data-anolis-xref="">patternContentUnits</code>
    </td></tr><tr><td> <code data-anolis-xref="">patterntransform</code> </td><td> <code data-anolis-xref="">patternTransform</code>
    </td></tr><tr><td> <code data-anolis-xref="">patternunits</code> </td><td> <code data-anolis-xref="">patternUnits</code>
    </td></tr><tr><td> <code data-anolis-xref="">pointsatx</code> </td><td> <code data-anolis-xref="">pointsAtX</code>
    </td></tr><tr><td> <code data-anolis-xref="">pointsaty</code> </td><td> <code data-anolis-xref="">pointsAtY</code>
    </td></tr><tr><td> <code data-anolis-xref="">pointsatz</code> </td><td> <code data-anolis-xref="">pointsAtZ</code>
    </td></tr><tr><td> <code data-anolis-xref="">preservealpha</code> </td><td> <code data-anolis-xref="">preserveAlpha</code>
    </td></tr><tr><td> <code data-anolis-xref="">preserveaspectratio</code> </td><td> <code data-anolis-xref="">preserveAspectRatio</code>
    </td></tr><tr><td> <code data-anolis-xref="">primitiveunits</code> </td><td> <code data-anolis-xref="">primitiveUnits</code>
    </td></tr><tr><td> <code data-anolis-xref="">refx</code> </td><td> <code data-anolis-xref="">refX</code>
    </td></tr><tr><td> <code data-anolis-xref="">refy</code> </td><td> <code data-anolis-xref="">refY</code>
    </td></tr><tr><td> <code data-anolis-xref="">repeatcount</code> </td><td> <code data-anolis-xref="">repeatCount</code>
    </td></tr><tr><td> <code data-anolis-xref="">repeatdur</code> </td><td> <code data-anolis-xref="">repeatDur</code>
    </td></tr><tr><td> <code data-anolis-xref="">requiredextensions</code> </td><td> <code data-anolis-xref="">requiredExtensions</code>
    </td></tr><tr><td> <code data-anolis-xref="">requiredfeatures</code> </td><td> <code data-anolis-xref="">requiredFeatures</code>
    </td></tr><tr><td> <code data-anolis-xref="">specularconstant</code> </td><td> <code data-anolis-xref="">specularConstant</code>
    </td></tr><tr><td> <code data-anolis-xref="">specularexponent</code> </td><td> <code data-anolis-xref="">specularExponent</code>
    </td></tr><tr><td> <code data-anolis-xref="">spreadmethod</code> </td><td> <code data-anolis-xref="">spreadMethod</code>
    </td></tr><tr><td> <code data-anolis-xref="">startoffset</code> </td><td> <code data-anolis-xref="">startOffset</code>
    </td></tr><tr><td> <code data-anolis-xref="">stddeviation</code> </td><td> <code data-anolis-xref="">stdDeviation</code>
    </td></tr><tr><td> <code data-anolis-xref="">stitchtiles</code> </td><td> <code data-anolis-xref="">stitchTiles</code>
    </td></tr><tr><td> <code data-anolis-xref="">surfacescale</code> </td><td> <code data-anolis-xref="">surfaceScale</code>
    </td></tr><tr><td> <code data-anolis-xref="">systemlanguage</code> </td><td> <code data-anolis-xref="">systemLanguage</code>
    </td></tr><tr><td> <code data-anolis-xref="">tablevalues</code> </td><td> <code data-anolis-xref="">tableValues</code>
    </td></tr><tr><td> <code data-anolis-xref="">targetx</code> </td><td> <code data-anolis-xref="">targetX</code>
    </td></tr><tr><td> <code data-anolis-xref="">targety</code> </td><td> <code data-anolis-xref="">targetY</code>
    </td></tr><tr><td> <code data-anolis-xref="">textlength</code> </td><td> <code data-anolis-xref="">textLength</code>
    </td></tr><tr><td> <code data-anolis-xref="">viewbox</code> </td><td> <code data-anolis-xref="">viewBox</code>
    </td></tr><tr><td> <code data-anolis-xref="">viewtarget</code> </td><td> <code data-anolis-xref="">viewTarget</code>
    </td></tr><tr><td> <code data-anolis-xref="">xchannelselector</code> </td><td> <code data-anolis-xref="">xChannelSelector</code>
    </td></tr><tr><td> <code data-anolis-xref="">ychannelselector</code> </td><td> <code data-anolis-xref="">yChannelSelector</code>
    </td></tr><tr><td> <code data-anolis-xref="">zoomandpan</code> </td><td> <code data-anolis-xref="">zoomAndPan</code>
  </td></tr></table><p>When the steps below require the user agent to <dfn id="adjust-foreign-attributes">adjust foreign attributes</dfn> for a
  token, then, if any of the attributes on the token match the strings given in the first column of
  the following table, let the attribute be a namespaced attribute, with the prefix being the string
  given in the corresponding cell in the second column, the local name being the string given in the
  corresponding cell in the third column, and the namespace being the namespace given in the
  corresponding cell in the fourth column. (This fixes the use of namespaced attributes, in
  particular <a data-anolis-xref="attr-xml-lang" href="dom.html#attr-xml-lang"><code data-anolis-xref="">lang</code> attributes in the <span>XML
  namespace</span></a>.)</p>

  <table><thead><tr><th> Attribute name </th><th> Prefix </th><th> Local name </th><th> Namespace
   <tbody></th></tr><tr><td> <code data-anolis-xref="">xlink:actuate</code> </td><td> <code data-anolis-xref="">xlink</code> </td><td> <code data-anolis-xref="">actuate</code> </td><td> <a href="infrastructure.html#xlink-namespace">XLink namespace</a>
    </td></tr><tr><td> <code data-anolis-xref="">xlink:arcrole</code> </td><td> <code data-anolis-xref="">xlink</code> </td><td> <code data-anolis-xref="">arcrole</code> </td><td> <a href="infrastructure.html#xlink-namespace">XLink namespace</a>
    </td></tr><tr><td> <code data-anolis-xref="">xlink:href</code> </td><td> <code data-anolis-xref="">xlink</code> </td><td> <code data-anolis-xref="">href</code> </td><td> <a href="infrastructure.html#xlink-namespace">XLink namespace</a>
    </td></tr><tr><td> <code data-anolis-xref="">xlink:role</code> </td><td> <code data-anolis-xref="">xlink</code> </td><td> <code data-anolis-xref="">role</code> </td><td> <a href="infrastructure.html#xlink-namespace">XLink namespace</a>
    </td></tr><tr><td> <code data-anolis-xref="">xlink:show</code> </td><td> <code data-anolis-xref="">xlink</code> </td><td> <code data-anolis-xref="">show</code> </td><td> <a href="infrastructure.html#xlink-namespace">XLink namespace</a>
    </td></tr><tr><td> <code data-anolis-xref="">xlink:title</code> </td><td> <code data-anolis-xref="">xlink</code> </td><td> <code data-anolis-xref="">title</code> </td><td> <a href="infrastructure.html#xlink-namespace">XLink namespace</a>
    </td></tr><tr><td> <code data-anolis-xref="">xlink:type</code> </td><td> <code data-anolis-xref="">xlink</code> </td><td> <code data-anolis-xref="">type</code> </td><td> <a href="infrastructure.html#xlink-namespace">XLink namespace</a>
    </td></tr><tr><td> <code data-anolis-xref="">xml:base</code> </td><td> <code data-anolis-xref="">xml</code> </td><td> <code data-anolis-xref="">base</code> </td><td> <a href="infrastructure.html#xml-namespace">XML namespace</a> <!-- attr-xml-base -->
    </td></tr><tr><td> <code data-anolis-xref="">xml:lang</code> </td><td> <code data-anolis-xref="">xml</code> </td><td> <code data-anolis-xref="">lang</code> </td><td> <a href="infrastructure.html#xml-namespace">XML namespace</a>
    </td></tr><tr><td> <code data-anolis-xref="">xml:space</code> </td><td> <code data-anolis-xref="">xml</code> </td><td> <code data-anolis-xref="">space</code> </td><td> <a href="infrastructure.html#xml-namespace">XML namespace</a>
    </td></tr><tr><td> <code data-anolis-xref="">xmlns</code> </td><td> (none) </td><td> <code data-anolis-xref="">xmlns</code> </td><td> <a href="infrastructure.html#xmlns-namespace">XMLNS namespace</a>
    </td></tr><tr><td> <code data-anolis-xref="">xmlns:xlink</code> </td><td> <code data-anolis-xref="">xmlns</code> </td><td> <code data-anolis-xref="">xlink</code> </td><td> <a href="infrastructure.html#xmlns-namespace">XMLNS namespace</a>
  </td></tr></table><hr><p>When the steps below require the user agent to <dfn id="insert-a-character">insert a character</dfn> while processing a
  token, the user agent must run the following steps:</p>

  <ol><li><p>Let <var data-anolis-xref="">data</var> be the characters passed to the algorithm, or, if no
   characters were explicitly specified, the character of the character token being
   processed.</li>

   <li><p>Let the <var data-anolis-xref="">adjusted insertion location</var> be the <a href="#appropriate-place-for-inserting-a-node">appropriate
   place for inserting a node</a>.</li>

   <li>

    <p>If the <var data-anolis-xref="">adjusted insertion location</var> is in a <code><a href="dom.html#document">Document</a></code> node,
    then abort these steps.

    <p class="note">The DOM will not let <code><a href="dom.html#document">Document</a></code> nodes have <code><a href="infrastructure.html#text-0">Text</a></code> node
    children, so they are dropped on the floor.</p>

   </li>

   <li>

    <p>If there is a <code><a href="infrastructure.html#text-0">Text</a></code> node immediately before the <var data-anolis-xref="">adjusted insertion
    location</var>, then append <var data-anolis-xref="">data</var> to that <code><a href="infrastructure.html#text-0">Text</a></code> node's data.</p>

    <p>Otherwise, create a new <code><a href="infrastructure.html#text-0">Text</a></code> node whose data is <var data-anolis-xref="">data</var> and
    whose <code data-anolis-xref="dom-Node-ownerDocument"><a href="infrastructure.html#dom-node-ownerdocument">ownerDocument</a></code> is the same as that of the
    element in which the <var data-anolis-xref="">adjusted insertion location</var> finds itself, and insert
    the newly created node at the <var data-anolis-xref="">adjusted insertion location</var>.</p>

   </li>

  </ol><div class="example">

   <p>Here are some sample inputs to the parser and the corresponding number of <code><a href="infrastructure.html#text-0">Text</a></code>
   nodes that they result in, assuming a user agent that executes scripts.</p>

   <table><thead><tr><th>Input </th><th>Number of <code><a href="infrastructure.html#text-0">Text</a></code> nodes
    <tbody></th></tr><tr><td><pre>A&lt;script&gt;
var script = document.getElementsByTagName('script')[0];
document.body.removeChild(script);
&lt;/script&gt;B</pre>
      </td><td>One <code><a href="infrastructure.html#text-0">Text</a></code> node in the document, containing "AB".
     </td></tr><tr><td><pre>A&lt;script&gt;
var text = document.createTextNode('B');
document.body.appendChild(text);
&lt;/script&gt;C</pre>
      </td><td>Three <code><a href="infrastructure.html#text-0">Text</a></code> nodes; "A" before the script, the script's contents, and "BC" after the script (the parser appends to the <code><a href="infrastructure.html#text-0">Text</a></code> node created by the script).
     </td></tr><tr><td><pre>A&lt;script&gt;
var text = document.getElementsByTagName('script')[0].firstChild;
text.data = 'B';
document.body.appendChild(text);
&lt;/script&gt;C</pre>
      </td><td>Two adjacent <code><a href="infrastructure.html#text-0">Text</a></code> nodes in the document, containing "A" and "BC".
     </td></tr><tr><td><pre>A&lt;table&gt;B&lt;tr&gt;C&lt;/tr&gt;D&lt;/table&gt;</pre>
      </td><td>One <code><a href="infrastructure.html#text-0">Text</a></code> node before the table, containing "ABCD". (This is caused by <a data-anolis-xref="foster parent" href="#foster-parent">foster parenting</a>.)
     </td></tr><tr><td><pre>A&lt;table&gt;&lt;tr&gt; B&lt;/tr&gt; C&lt;/table&gt;</pre>
      </td><td>One <code><a href="infrastructure.html#text-0">Text</a></code> node before the table, containing "A B C" (A-space-B-space-C). (This is caused by <a data-anolis-xref="foster parent" href="#foster-parent">foster parenting</a>.)
     </td></tr><tr><td><pre>A&lt;table&gt;&lt;tr&gt; B&lt;/tr&gt; &lt;/em&gt;C&lt;/table&gt;</pre>
      </td><td>One <code><a href="infrastructure.html#text-0">Text</a></code> node before the table, containing "A BC" (A-space-B-C), and one <code><a href="infrastructure.html#text-0">Text</a></code> node inside the table (as a child of a <code><a href="tabular-data.html#the-tbody-element">tbody</a></code>) with a single space character. (Space characters separated from non-space characters by non-character tokens are not affected by <a data-anolis-xref="foster parent" href="#foster-parent">foster parenting</a>, even if those other tokens then get ignored.)
   </td></tr></table></div>

  <hr><p>When the steps below require the user agent to <dfn id="insert-a-comment">insert a comment</dfn> while processing a
  comment token, optionally with an explicitly insertion position <var data-anolis-xref="">position</var>, the
  user agent must run the following steps:</p>

  <ol><li><p>Let <var data-anolis-xref="">data</var> be the data given in the comment token being
   processed.</li>

   <li><p>If <var data-anolis-xref="">position</var> was specified, then let the <var data-anolis-xref="">adjusted
   insertion location</var> be <var data-anolis-xref="">position</var>. Otherwise, let <var data-anolis-xref="">adjusted
   insertion location</var> be the <a href="#appropriate-place-for-inserting-a-node">appropriate place for inserting a node</a>.</li>

   <li><p>Create a <code><a href="infrastructure.html#comment-0">Comment</a></code> node whose <code data-anolis-xref="">data</code> attribute is set to
   <var data-anolis-xref="">data</var> and whose <code data-anolis-xref="dom-Node-ownerDocument"><a href="infrastructure.html#dom-node-ownerdocument">ownerDocument</a></code> is
   the same as that of the node in which the <var data-anolis-xref="">adjusted insertion location</var> finds
   itself.</p>

   </li><li><p>Insert the newly created node at the <var data-anolis-xref="">adjusted insertion
   location</var>.</li>

  </ol><hr><p id="mutation-during-parsing">DOM mutation events must not fire for changes caused by the UA
  parsing the document. This includes the parsing of any content inserted using <code data-anolis-xref="dom-document-write"><a href="webappapis.html#dom-document-write">document.write()</a></code> and <code data-anolis-xref="dom-document-writeln"><a href="webappapis.html#dom-document-writeln">document.writeln()</a></code> calls. <a href="references.html#refsDOMEVENTS">[DOMEVENTS]</a></p>

  <p>However, mutation observers <em>do</em> fire, as required by the DOM specification.</p>



  <h5 id="parsing-elements-that-contain-only-text"><span class="secno">8.2.5.2 </span>Parsing elements that contain only text</h5>

  <p>The <dfn id="generic-raw-text-element-parsing-algorithm">generic raw text element parsing algorithm</dfn> and the <dfn id="generic-rcdata-element-parsing-algorithm">generic RCDATA element
  parsing algorithm</dfn> consist of the following steps. These algorithms are always invoked in
  response to a start tag token.</p>

  <ol><li><p><a href="#insert-an-html-element">Insert an HTML element</a> for the token.</li>

   <li><p>If the algorithm that was invoked is the <a href="#generic-raw-text-element-parsing-algorithm">generic raw text element parsing
   algorithm</a>, switch the tokenizer to the <a href="#rawtext-state">RAWTEXT state</a>; otherwise the algorithm
   invoked was the <a href="#generic-rcdata-element-parsing-algorithm">generic RCDATA element parsing algorithm</a>, switch the tokenizer to
   the <a href="#rcdata-state">RCDATA state</a>.</li>

   <li><p>Let the <a href="#original-insertion-mode">original insertion mode</a> be the current <a href="#insertion-mode">insertion
   mode</a>.</p>

   </li><li><p>Then, switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode:
   text" href="#parsing-main-incdata">text</a>".</li>

  </ol><h5 id="closing-elements-that-have-implied-end-tags"><span class="secno">8.2.5.3 </span>Closing elements that have implied end tags</h5>

  <!-- FORK -->
  <p>When the steps below require the UA to <dfn id="generate-implied-end-tags">generate implied end
  tags</dfn>, then, while the <a href="#current-node">current node</a> is a
  <code><a href="grouping-content.html#the-dd-element">dd</a></code> element, a <code><a href="grouping-content.html#the-dt-element">dt</a></code> element, an
  <code><a href="grouping-content.html#the-li-element">li</a></code> element, an <code><a href="forms.html#the-option-element">option</a></code> element, an
  <code><a href="forms.html#the-optgroup-element">optgroup</a></code> element, a <code><a href="grouping-content.html#the-p-element">p</a></code> element, an
  <code><a href="text-level-semantics.html#the-rb-element">rb</a></code> element, an <code><a href="text-level-semantics.html#the-rp-element">rp</a></code> element, an <code><a href="text-level-semantics.html#the-rt-element">rt</a></code> 
  element, or an <code><a href="text-level-semantics.html#the-rtc-element">rtc</a></code> element, the UA must
  pop the <a href="#current-node">current node</a> off the <a href="#stack-of-open-elements">stack of open
  elements</a>.</p>
  <!-- /FORK -->

  <p>If a step requires the UA to generate implied end tags but lists
  an element to exclude from the process, then the UA must perform the
  above steps as if that element was not in the above list.</p>



  <h5 id="parsing-main-inhtml"><span class="secno">8.2.5.4 </span>The rules for parsing tokens in HTML content</h5>


  <h6 id="the-initial-insertion-mode"><span class="secno">8.2.5.4.1 </span>The "<dfn data-anolis-xref="insertion mode: initial" id="insertion-mode:-initial">initial</dfn>" insertion mode</h6>

  <p>When the user agent is to apply the rules for the "<a data-anolis-xref="insertion mode:
  initial" href="#the-initial-insertion-mode">initial</a>" <a href="#insertion-mode">insertion mode</a>, the user agent must handle the token as
  follows:</p>

  <dl class="switch"><dt>A character token that is one of U+0009 CHARACTER
   TABULATION, "LF" (U+000A), "FF" (U+000C),
   "CR" (U+000D), or U+0020 SPACE</dt>
   <dd>
    <p>Ignore the token.</p>
   </dd>

   <dt>A comment token</dt>
   <dd>
    <p><a href="#insert-a-comment">Insert a comment</a> as the last child of the <code><a href="dom.html#document">Document</a></code> object.</p>
   </dd>

   <dt>A DOCTYPE token</dt>
   <dd>

    <p>If the DOCTYPE token's name is not a <a href="infrastructure.html#case-sensitive">case-sensitive</a> match for the string "<code data-anolis-xref="">html</code>", or the token's public identifier is not missing, or the token's system
    identifier is neither missing nor a <a href="infrastructure.html#case-sensitive">case-sensitive</a> match for the string
    "<code><a href="infrastructure.html#about:legacy-compat">about:legacy-compat</a></code>", and none of the sets of conditions in the following list are
    matched, then there is a <a href="#parse-error">parse error</a>.</p>

    <ul><!-- only things that trigger no-quirks mode and were valid in some other spec are allowed in
     this list --><li>The DOCTYPE token's name is a <a href="infrastructure.html#case-sensitive">case-sensitive</a> match for the string "<code data-anolis-xref="">html</code>", the token's public identifier is the <a href="infrastructure.html#case-sensitive">case-sensitive</a> string
     "<code data-anolis-xref="">-//W3C//DTD HTML 4.0//EN</code>", and the token's system identifier
     is either missing or the <a href="infrastructure.html#case-sensitive">case-sensitive</a> string "<code data-anolis-xref="">http://www.w3.org/TR/REC-html40/strict.dtd</code>".</li>

     <li>The DOCTYPE token's name is a <a href="infrastructure.html#case-sensitive">case-sensitive</a> match for the string "<code data-anolis-xref="">html</code>", the token's public identifier is the <a href="infrastructure.html#case-sensitive">case-sensitive</a> string
     "<code data-anolis-xref="">-//W3C//DTD HTML 4.01//EN</code>", and the token's system identifier
     is either missing or the <a href="infrastructure.html#case-sensitive">case-sensitive</a> string "<code data-anolis-xref="">http://www.w3.org/TR/html4/strict.dtd</code>".</li>

     <li>The DOCTYPE token's name is a <a href="infrastructure.html#case-sensitive">case-sensitive</a> match for the string "<code data-anolis-xref="">html</code>", the token's public identifier is the <a href="infrastructure.html#case-sensitive">case-sensitive</a> string
     "<code data-anolis-xref="">-//W3C//DTD XHTML 1.0 Strict//EN</code>", and the token's system
     identifier is the <a href="infrastructure.html#case-sensitive">case-sensitive</a> string "<code data-anolis-xref="">http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd</code>".</li>

     <li>The DOCTYPE token's name is a <a href="infrastructure.html#case-sensitive">case-sensitive</a> match for the string "<code data-anolis-xref="">html</code>", the token's public identifier is the <a href="infrastructure.html#case-sensitive">case-sensitive</a> string
     "<code data-anolis-xref="">-//W3C//DTD XHTML 1.1//EN</code>", and the token's system identifier
     is the <a href="infrastructure.html#case-sensitive">case-sensitive</a> string "<code data-anolis-xref="">http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd</code>".</li>

    </ul><p>Conformance checkers may, based on the values (including presence or lack thereof) of the
    DOCTYPE token's name, public identifier, or system identifier, switch to a conformance checking
    mode for another language (e.g. based on the DOCTYPE token a conformance checker could recognize
    that the document is an HTML4-era document, and defer to an HTML4 conformance checker.)</p>

    <p>Append a <code><a href="infrastructure.html#documenttype">DocumentType</a></code> node to the <code><a href="dom.html#document">Document</a></code> node, with the <code data-anolis-xref="">name</code> attribute set to the name given in the DOCTYPE token, or the empty string
    if the name was missing; the <code data-anolis-xref="">publicId</code> attribute set to the public
    identifier given in the DOCTYPE token, or the empty string if the public identifier was missing;
    the <code data-anolis-xref="">systemId</code> attribute set to the system identifier given in the DOCTYPE
    token, or the empty string if the system identifier was missing; and the other attributes
    specific to <code><a href="infrastructure.html#documenttype">DocumentType</a></code> objects set to null and empty lists as appropriate.
    Associate the <code><a href="infrastructure.html#documenttype">DocumentType</a></code> node with the <code><a href="dom.html#document">Document</a></code> object so that it is
    returned as the value of the <code data-anolis-xref="">doctype</code> attribute of the
    <code><a href="dom.html#document">Document</a></code> object.</p>

    <p id="quirks-mode-doctypes">Then, if the document is <em>not</em> <a href="embedded-content-0.html#an-iframe-srcdoc-document">an <code>iframe</code>
    <code data-anolis-xref="attr-iframe-srcdoc">srcdoc</code> document</a>, and the DOCTYPE token matches
    one of the conditions in the following list, then set the <code><a href="dom.html#document">Document</a></code> to <a href="infrastructure.html#quirks-mode">quirks
    mode</a>:</p>

    <ul class="brief"><li> The <i>force-quirks flag</i> is set to <i>on</i>. </li>
     <li> The name is set to anything other than "<code data-anolis-xref="">html</code>" (compared <a data-anolis-xref="case-sensitive" href="infrastructure.html#case-sensitive">case-sensitively</a>). </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">+//Silmaril//dtd html Pro v0r11 19970101//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//AdvaSoft Ltd//DTD HTML 3.0 asWedit + extensions//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//AS//DTD HTML 3.0 asWedit + extensions//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//IETF//DTD HTML 2.0 Level 1//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//IETF//DTD HTML 2.0 Level 2//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//IETF//DTD HTML 2.0 Strict Level 1//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//IETF//DTD HTML 2.0 Strict Level 2//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//IETF//DTD HTML 2.0 Strict//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//IETF//DTD HTML 2.0//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//IETF//DTD HTML 2.1E//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//IETF//DTD HTML 3.0//<!--EN--></code>" </li>
   <!--<li> The public identifier is set to: "<code data-x="">-//IETF//DTD HTML 3.0//EN//</code>" </li>-->
     <li> The public identifier starts with: "<code data-anolis-xref="">-//IETF//DTD HTML 3.2 Final//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//IETF//DTD HTML 3.2//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//IETF//DTD HTML 3//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//IETF//DTD HTML Level 0//<!--EN--></code>" </li>
   <!--<li> The public identifier is set to: "<code data-x="">-//IETF//DTD HTML Level 0//EN//2.0</code>" </li>-->
     <li> The public identifier starts with: "<code data-anolis-xref="">-//IETF//DTD HTML Level 1//<!--EN--></code>" </li>
   <!--<li> The public identifier is set to: "<code data-x="">-//IETF//DTD HTML Level 1//EN//2.0</code>" </li>-->
     <li> The public identifier starts with: "<code data-anolis-xref="">-//IETF//DTD HTML Level 2//<!--EN--></code>" </li>
   <!--<li> The public identifier is set to: "<code data-x="">-//IETF//DTD HTML Level 2//EN//2.0</code>" </li>-->
     <li> The public identifier starts with: "<code data-anolis-xref="">-//IETF//DTD HTML Level 3//<!--EN--></code>" </li>
   <!--<li> The public identifier is set to: "<code data-x="">-//IETF//DTD HTML Level 3//EN//3.0</code>" </li>-->
     <li> The public identifier starts with: "<code data-anolis-xref="">-//IETF//DTD HTML Strict Level 0//<!--EN--></code>" </li>
   <!--<li> The public identifier is set to: "<code data-x="">-//IETF//DTD HTML Strict Level 0//EN//2.0</code>" </li>-->
     <li> The public identifier starts with: "<code data-anolis-xref="">-//IETF//DTD HTML Strict Level 1//<!--EN--></code>" </li>
   <!--<li> The public identifier is set to: "<code data-x="">-//IETF//DTD HTML Strict Level 1//EN//2.0</code>" </li>-->
     <li> The public identifier starts with: "<code data-anolis-xref="">-//IETF//DTD HTML Strict Level 2//<!--EN--></code>" </li>
   <!--<li> The public identifier is set to: "<code data-x="">-//IETF//DTD HTML Strict Level 2//EN//2.0</code>" </li>-->
     <li> The public identifier starts with: "<code data-anolis-xref="">-//IETF//DTD HTML Strict Level 3//<!--EN--></code>" </li>
   <!--<li> The public identifier is set to: "<code data-x="">-//IETF//DTD HTML Strict Level 3//EN//3.0</code>" </li>-->
     <li> The public identifier starts with: "<code data-anolis-xref="">-//IETF//DTD HTML Strict//<!--EN--></code>" </li>
   <!--<li> The public identifier is set to: "<code data-x="">-//IETF//DTD HTML Strict//EN//2.0</code>" </li>-->
   <!--<li> The public identifier is set to: "<code data-x="">-//IETF//DTD HTML Strict//EN//3.0</code>" </li>-->
     <li> The public identifier starts with: "<code data-anolis-xref="">-//IETF//DTD HTML//<!--EN--></code>" </li>
   <!--<li> The public identifier is set to: "<code data-x="">-//IETF//DTD HTML//EN//2.0</code>" </li>-->
   <!--<li> The public identifier is set to: "<code data-x="">-//IETF//DTD HTML//EN//3.0</code>" </li>-->
     <li> The public identifier starts with: "<code data-anolis-xref="">-//Metrius//DTD Metrius Presentational//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//Microsoft//DTD Internet Explorer 2.0 HTML Strict//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//Microsoft//DTD Internet Explorer 2.0 HTML//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//Microsoft//DTD Internet Explorer 2.0 Tables//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//Microsoft//DTD Internet Explorer 3.0 HTML Strict//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//Microsoft//DTD Internet Explorer 3.0 HTML//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//Microsoft//DTD Internet Explorer 3.0 Tables//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//Netscape Comm. Corp.//DTD HTML//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//Netscape Comm. Corp.//DTD Strict HTML//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//O'Reilly and Associates//DTD HTML 2.0//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//O'Reilly and Associates//DTD HTML Extended 1.0//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//O'Reilly and Associates//DTD HTML Extended Relaxed 1.0//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//SoftQuad Software//DTD HoTMetaL PRO 6.0::19990601::extensions to HTML 4.0//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//SoftQuad//DTD HoTMetaL PRO 4.0::19971010::extensions to HTML 4.0//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//Spyglass//DTD HTML 2.0 Extended//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//SQ//DTD HTML 2.0 HoTMetaL + extensions//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//Sun Microsystems Corp.//DTD HotJava HTML//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//Sun Microsystems Corp.//DTD HotJava Strict HTML//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//W3C//DTD HTML 3 1995-03-24//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//W3C//DTD HTML 3.2 Draft//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//W3C//DTD HTML 3.2 Final//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//W3C//DTD HTML 3.2//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//W3C//DTD HTML 3.2S Draft//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//W3C//DTD HTML 4.0 Frameset//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//W3C//DTD HTML 4.0 Transitional//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//W3C//DTD HTML Experimental 19960712//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//W3C//DTD HTML Experimental 970421//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//W3C//DTD W3 HTML//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//W3O//DTD W3 HTML 3.0//<!--EN--></code>" </li>
   <!--<li> The public identifier is set to: "<code data-x="">-//W3O//DTD W3 HTML 3.0//EN//</code>" </li>-->
     <li> The public identifier is set to: "<code data-anolis-xref="">-//W3O//DTD W3 HTML Strict 3.0//EN//</code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//WebTechs//DTD Mozilla HTML 2.0//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//WebTechs//DTD Mozilla HTML//<!--EN--></code>" </li>
     <li> The public identifier is set to: "<code data-anolis-xref="">-/W3C/DTD HTML 4.0 Transitional/EN</code>" </li>
     <li> The public identifier is set to: "<code data-anolis-xref="">HTML</code>" </li>
     <li> The system identifier is set to: "<code data-anolis-xref="">http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd</code>" </li>
     <li> The system identifier is missing and the public identifier starts with: "<code data-anolis-xref="">-//W3C//DTD HTML 4.01 Frameset//<!--EN--></code>" </li>
     <li> The system identifier is missing and the public identifier starts with: "<code data-anolis-xref="">-//W3C//DTD HTML 4.01 Transitional//<!--EN--></code>" </li>
    </ul><p>Otherwise, if the document is <em>not</em> <a href="embedded-content-0.html#an-iframe-srcdoc-document">an <code>iframe</code> <code data-anolis-xref="attr-iframe-srcdoc">srcdoc</code> document</a>, and the DOCTYPE token matches one of
    the conditions in the following list, then set the <code><a href="dom.html#document">Document</a></code> to <a href="infrastructure.html#limited-quirks-mode">limited-quirks
    mode</a>:</p>

    <ul class="brief"><li> The public identifier starts with: "<code data-anolis-xref="">-//W3C//DTD XHTML 1.0 Frameset//<!--EN--></code>" </li>
     <li> The public identifier starts with: "<code data-anolis-xref="">-//W3C//DTD XHTML 1.0 Transitional//<!--EN--></code>" </li>
     <li> The system identifier is not missing and the public identifier starts with: "<code data-anolis-xref="">-//W3C//DTD HTML 4.01 Frameset//<!--EN--></code>" </li>
     <li> The system identifier is not missing and the public identifier starts with: "<code data-anolis-xref="">-//W3C//DTD HTML 4.01 Transitional//<!--EN--></code>" </li>
    </ul><p>The system identifier and public identifier strings must be compared to the values given in
    the lists above in an <a href="infrastructure.html#ascii-case-insensitive">ASCII case-insensitive</a> manner. A system identifier whose
    value is the empty string is not considered missing for the purposes of the conditions
    above.</p>

    <p>Then, switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: before
    html" href="#the-before-html-insertion-mode">before html</a>".</p>

   </dd>

   <dt>Anything else</dt>
   <dd>

    <p>If the document is <em>not</em> <a href="embedded-content-0.html#an-iframe-srcdoc-document">an <code>iframe</code> <code data-anolis-xref="attr-iframe-srcdoc">srcdoc</code> document</a>, then this is a <a href="#parse-error">parse
    error</a>; set the <code><a href="dom.html#document">Document</a></code> to <a href="infrastructure.html#quirks-mode">quirks mode</a>.</p>

    <p>In any case, switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: before
    html" href="#the-before-html-insertion-mode">before html</a>", then reprocess the token.</p>

   </dd>

  </dl><h6 id="the-before-html-insertion-mode"><span class="secno">8.2.5.4.2 </span>The "<dfn data-anolis-xref="insertion mode: before html" id="insertion-mode:-before-html">before html</dfn>" insertion mode</h6>

  <p>When the user agent is to apply the rules for the "<a data-anolis-xref="insertion mode: before
  html" href="#the-before-html-insertion-mode">before html</a>" <a href="#insertion-mode">insertion mode</a>, the user agent must handle the token as
  follows:</p>

  <dl class="switch"><dt>A DOCTYPE token</dt>
   <dd>
    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>
   </dd>

   <dt>A comment token</dt>
   <dd>
    <p><a href="#insert-a-comment">Insert a comment</a> as the last child of the <code><a href="dom.html#document">Document</a></code> object.</p>
   </dd>

   <dt>A character token that is one of U+0009 CHARACTER TABULATION, "LF" (U+000A), "FF" (U+000C), "CR" (U+000D), or U+0020 SPACE</dt>
   <dd>
    <p>Ignore the token.</p>
   </dd>

   <dt>A start tag whose tag name is "html"</dt>
   <dd>

    <p><a href="#create-an-element-for-the-token">Create an element for the token</a> in the <a href="infrastructure.html#html-namespace-0">HTML namespace</a>, with the
    <code><a href="dom.html#document">Document</a></code> as the intended parent. Append it to the <code><a href="dom.html#document">Document</a></code> object. Put
    this element in the <a href="#stack-of-open-elements">stack of open elements</a>.</p>

    <p id="parser-appcache">If the <code><a href="dom.html#document">Document</a></code> is being loaded as part of <a data-anolis-xref="navigate" href="browsers.html#navigate">navigation</a> of a <a href="browsers.html#browsing-context">browsing context</a>, then: if the newly
    created element has a <code data-anolis-xref="attr-html-manifest"><a href="semantics.html#attr-html-manifest">manifest</a></code> attribute whose value is
    not the empty string, then <a data-anolis-xref="resolve a url" href="infrastructure.html#resolve-a-url">resolve</a> the value of that
    attribute to an <a href="infrastructure.html#absolute-url">absolute URL</a>, relative to the newly created element, and if that is
    successful, run the <a data-anolis-xref="concept-appcache-init" href="browsers.html#concept-appcache-init">application cache selection
    algorithm</a> with the result of applying the <a data-anolis-xref="concept-url-serializer" href="infrastructure.html#concept-url-serializer">URL
    serializer</a> algorithm to the resulting <a href="infrastructure.html#parsed-url">parsed URL</a> with the <i>exclude
    fragment flag</i> set; otherwise, if there is no such attribute, or its value is the empty
    string, or resolving its value fails, run the <a data-anolis-xref="concept-appcache-init" href="browsers.html#concept-appcache-init">application
    cache selection algorithm</a> with no manifest. The algorithm must be passed the
    <code><a href="dom.html#document">Document</a></code> object.</p>

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: before head" href="#the-before-head-insertion-mode">before
    head</a>".</p>

   </dd>

   <dt>An end tag whose tag name is one of: "head", "body", "html", "br"</dt>
   <dd>
    <p>Act as described in the "anything else" entry below.</p>
   </dd>

   <dt>Any other end tag</dt>
   <dd>
    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>
   </dd>

   <dt>Anything else</dt>
   <dd>

    <p>Create an <code><a href="semantics.html#the-html-element">html</a></code> element whose <code data-anolis-xref="dom-Node-ownerDocument"><a href="infrastructure.html#dom-node-ownerdocument">ownerDocument</a></code> is the <code><a href="dom.html#document">Document</a></code> object. Append
    it to the <code><a href="dom.html#document">Document</a></code> object. Put this element in the <a href="#stack-of-open-elements">stack of open
    elements</a>.</p>

    <p>If the <code><a href="dom.html#document">Document</a></code> is being loaded as part of <a data-anolis-xref="navigate" href="browsers.html#navigate">navigation</a> of a <a href="browsers.html#browsing-context">browsing context</a>, then: run the <a data-anolis-xref="concept-appcache-init" href="browsers.html#concept-appcache-init">application cache selection algorithm</a> with no manifest,
    passing it the <code><a href="dom.html#document">Document</a></code> object.</p>

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: before head" href="#the-before-head-insertion-mode">before
    head</a>", then reprocess the token.</p>

   </dd>

  </dl><p>The root element can end up being removed from the <code><a href="dom.html#document">Document</a></code> object, e.g. by
  scripts; nothing in particular happens in such cases, content continues being appended to the
  nodes as described in the next section.</p>


  <h6 id="the-before-head-insertion-mode"><span class="secno">8.2.5.4.3 </span>The "<dfn data-anolis-xref="insertion mode: before head" id="insertion-mode:-before-head">before head</dfn>" insertion mode</h6>

  <p>When the user agent is to apply the rules for the "<a data-anolis-xref="insertion mode: before
  head" href="#the-before-head-insertion-mode">before head</a>" <a href="#insertion-mode">insertion mode</a>, the user agent must handle the token as
  follows:</p>

  <dl class="switch"><dt>A character token that is one of U+0009 CHARACTER
   TABULATION, "LF" (U+000A), "FF" (U+000C),
   "CR" (U+000D), or U+0020 SPACE</dt>
   <dd>
    <p>Ignore the token.</p> <!-- :-( -->
   </dd>

   <dt>A comment token</dt>
   <dd>
    <p><a href="#insert-a-comment">Insert a comment</a>.</p>
   </dd>

   <dt>A DOCTYPE token</dt>
   <dd>
    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>
   </dd>

   <dt>A start tag whose tag name is "html"</dt>
   <dd>
    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    body" href="#parsing-main-inbody">in body</a>" <a href="#insertion-mode">insertion mode</a>.</p>
   </dd>

   <dt>A start tag whose tag name is "head"</dt>
   <dd>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token.</p>

    <p>Set the <a href="#head-element-pointer"><code data-anolis-xref="">head</code> element pointer</a> to the newly created
    <code><a href="document-metadata.html#the-head-element">head</a></code> element.</p>

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in head" href="#parsing-main-inhead">in
    head</a>".</p>

   </dd>

   <dt>An end tag whose tag name is one of: "head", "body", "html", "br"</dt>
   <dd>

    <p>Act as described in the "anything else" entry below.</p>

   </dd>

   <dt>Any other end tag</dt>
   <dd>

    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>

   </dd>

   <dt>Anything else</dt>
   <dd>

    <!-- fake <head> -->

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for a "head" start tag token with no attributes.</p>

    <p>Set the <a href="#head-element-pointer"><code data-anolis-xref="">head</code> element pointer</a> to the newly created
    <code><a href="document-metadata.html#the-head-element">head</a></code> element.</p>

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in head" href="#parsing-main-inhead">in
    head</a>".</p>

    <!-- end of fake <head> -->

    <p>Reprocess the current token.</p>

   </dd>

  </dl><h6 id="parsing-main-inhead"><span class="secno">8.2.5.4.4 </span>The "<dfn data-anolis-xref="insertion mode: in head" id="insertion-mode:-in-head">in head</dfn>" insertion mode</h6>

  <p>When the user agent is to apply the rules for the "<a data-anolis-xref="insertion mode: in head" href="#parsing-main-inhead">in
  head</a>" <a href="#insertion-mode">insertion mode</a>, the user agent must handle the token as follows:</p>

  <dl class="switch"><dt>A character token that is one of U+0009 CHARACTER
   TABULATION, "LF" (U+000A), "FF" (U+000C),
   "CR" (U+000D), or U+0020 SPACE</dt>
   <dd>
    <p><a data-anolis-xref="insert a character" href="#insert-a-character">Insert the character</a>.</p>
   </dd>

   <dt>A comment token</dt>
   <dd>
    <p><a href="#insert-a-comment">Insert a comment</a>.</p>
   </dd>

   <dt>A DOCTYPE token</dt>
   <dd>
    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>
   </dd>

   <dt>A start tag whose tag name is "html"</dt>
   <dd>
    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    body" href="#parsing-main-inbody">in body</a>" <a href="#insertion-mode">insertion mode</a>.</p>
   </dd>

   <dt>A start tag whose tag name is one of: "base", "basefont",
   "bgsound", "link"</dt>
   <dd>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token. Immediately pop the <a href="#current-node">current
    node</a> off the <a href="#stack-of-open-elements">stack of open elements</a>.</p>

    <p><a data-anolis-xref="acknowledge self-closing flag" href="#acknowledge-self-closing-flag">Acknowledge the token's <i>self-closing
    flag</i></a>, if it is set.</p>

   </dd>

   <dt>A start tag whose tag name is "meta"</dt>
   <dd>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token. Immediately pop the <a href="#current-node">current
    node</a> off the <a href="#stack-of-open-elements">stack of open elements</a>.</p>

    <p><a data-anolis-xref="acknowledge self-closing flag" href="#acknowledge-self-closing-flag">Acknowledge the token's <i>self-closing
    flag</i></a>, if it is set.</p>

    <p id="meta-charset-during-parse">If the element has a <code data-anolis-xref="attr-meta-charset"><a href="document-metadata.html#attr-meta-charset">charset</a></code> attribute, and <a href="infrastructure.html#getting-an-encoding">getting an encoding</a> from
    its value results in a supported <a href="infrastructure.html#ascii-compatible-character-encoding">ASCII-compatible character encoding</a> or <a href="infrastructure.html#a-utf-16-encoding">a
    UTF-16 encoding</a>, and the <a data-anolis-xref="concept-encoding-confidence" href="#concept-encoding-confidence">confidence</a> is
    currently <i>tentative</i>, then <a href="#change-the-encoding">change the encoding</a> to the resulting encoding.</p>

    <p>Otherwise, if the element has an <code data-anolis-xref="attr-meta-http-equiv"><a href="document-metadata.html#attr-meta-http-equiv">http-equiv</a></code>
    attribute whose value is an <a href="infrastructure.html#ascii-case-insensitive">ASCII case-insensitive</a> match for the string "<code data-anolis-xref="">Content-Type</code>", and the element has a <code data-anolis-xref="attr-meta-content"><a href="document-metadata.html#attr-meta-content">content</a></code> attribute, and applying the <a href="infrastructure.html#algorithm-for-extracting-a-character-encoding-from-a-meta-element">algorithm for
    extracting a character encoding from a <code>meta</code> element</a> to that attribute's
    value returns a supported <a href="infrastructure.html#ascii-compatible-character-encoding">ASCII-compatible character encoding</a> or <a href="infrastructure.html#a-utf-16-encoding">a UTF-16
    encoding</a>, and the <a data-anolis-xref="concept-encoding-confidence" href="#concept-encoding-confidence">confidence</a> is
    currently <i>tentative</i>, then <a href="#change-the-encoding">change the encoding</a> to the extracted encoding.</p>

   </dd>

   <dt>A start tag whose tag name is "title"</dt>
   <dd>
    <p>Follow the <a href="#generic-rcdata-element-parsing-algorithm">generic RCDATA element parsing algorithm</a>.</p>
   </dd>

   <dt>A start tag whose tag name is "noscript", if the <a href="#scripting-flag">scripting flag</a> is enabled</dt>
   <dt>A start tag whose tag name is one of: "noframes", "style"</dt>
   <dd>
    <p>Follow the <a href="#generic-raw-text-element-parsing-algorithm">generic raw text element parsing algorithm</a>.</p>
   </dd>

   <dt>A start tag whose tag name is "noscript", if the <a href="#scripting-flag">scripting flag</a> is disabled</dt>
   <dd>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token.</p>

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in head noscript" href="#parsing-main-inheadnoscript">in
    head noscript</a>".</p>

   </dd>


   <dt id="scriptTag">A start tag whose tag name is "script"</dt>
   <dd>

    <p>Run these steps:</p>

    <ol><li><p>Let the <var data-anolis-xref="">adjusted insertion location</var> be the <a href="#appropriate-place-for-inserting-a-node">appropriate place
     for inserting a node</a>.</li>

     <li><p><a href="#create-an-element-for-the-token">Create an element for the token</a> in the <a href="infrastructure.html#html-namespace-0">HTML namespace</a>, with
     the intended parent being the element in which the <var data-anolis-xref="">adjusted insertion
     location</var> finds itself.</li>

     <li>

      <p>Mark the element as being <a href="scripting-1.html#parser-inserted">"parser-inserted"</a> and unset the element's
      <a href="scripting-1.html#force-async">"force-async"</a> flag.</p>

      <p class="note">This ensures that, if the script is external, any <code data-anolis-xref="dom-document-write"><a href="webappapis.html#dom-document-write">document.write()</a></code> calls in the script will execute in-line,
      instead of blowing the document away, as would happen in most other cases. It also prevents
      the script from executing until the end tag is seen.</p>

     </li>

     <li><p>If the parser was originally created for the <a href="#html-fragment-parsing-algorithm">HTML fragment parsing
     algorithm</a>, then mark the <code><a href="scripting-1.html#the-script-element">script</a></code> element as <a href="scripting-1.html#already-started">"already started"</a>.
     (<a href="#fragment-case">fragment case</a>)</li>

     <li><p>Insert the newly created element at the <var data-anolis-xref="">adjusted insertion
     location</var>.</li>

     <li><p>Push the element onto the <a href="#stack-of-open-elements">stack of open elements</a> so that it is the new
     <a href="#current-node">current node</a>.</li>

     <li><p>Switch the tokenizer to the <a href="#script-data-state">script data state</a>.</li>

     <li><p>Let the <a href="#original-insertion-mode">original insertion mode</a> be the current <a href="#insertion-mode">insertion
     mode</a>.</p>

     </li><li><p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode:
     text" href="#parsing-main-incdata">text</a>".</li>

    </ol></dd>

   <dt>An end tag whose tag name is "head"</dt>
   <dd>

    <p>Pop the <a href="#current-node">current node</a> (which will be the <code><a href="document-metadata.html#the-head-element">head</a></code> element) off the
    <a href="#stack-of-open-elements">stack of open elements</a>.</p>

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: after head" href="#the-after-head-insertion-mode">after
    head</a>".</p>

   </dd>

   <dt>An end tag whose tag name is one of: "body", "html", "br"</dt>
   <dd>
    <p>Act as described in the "anything else" entry below.</p>
   </dd>

   <dt>A start tag whose tag name is "template"</dt>
   <dd>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token.</p>

    <p>Insert a marker at the end of the <a href="#list-of-active-formatting-elements">list of active formatting elements</a>.</p>

    <p>Set the <a href="#frameset-ok-flag">frameset-ok flag</a> to "not ok".</p>

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in template" href="#parsing-main-intemplate">in
    template</a>".</p>

    <p>Push "<a data-anolis-xref="insertion mode: in template" href="#parsing-main-intemplate">in template</a>" onto the <a href="#stack-of-template-insertion-modes">stack of
    template insertion modes</a> so that it is the new <a href="#current-template-insertion-mode">current template insertion
    mode</a>.</p>

   </dd>

   <dt>An end tag whose tag name is "template"</dt>
   <dd>

    <p>If there is no <code><a href="scripting-1.html#the-template-element">template</a></code> element on the <a href="#stack-of-open-elements">stack of open elements</a>, then
    this is a <a href="#parse-error">parse error</a>; ignore the token.</p>

    <p>Otherwise, run these steps:</p>

    <ol><li><p><a href="#generate-implied-end-tags">Generate implied end tags</a>.</li>

     <li><p>If the <a href="#current-node">current node</a> is not a <code><a href="scripting-1.html#the-template-element">template</a></code> element, then this is a
     <a href="#parse-error">parse error</a>.</li>

     <li><p>Pop elements from the <a href="#stack-of-open-elements">stack of open elements</a> until a <code><a href="scripting-1.html#the-template-element">template</a></code>
     element has been popped from the stack.</li>

     <li><a href="#clear-the-list-of-active-formatting-elements-up-to-the-last-marker">Clear the list of active formatting elements up to the last marker</a>.</li>

     <li><p>Pop the <a href="#current-template-insertion-mode">current template insertion mode</a> off the <a href="#stack-of-template-insertion-modes">stack of template
     insertion modes</a>.</p>

     </li><li><p><a href="#reset-the-insertion-mode-appropriately">Reset the insertion mode appropriately</a>.</li>

    </ol></dd>

   <dt>A start tag whose tag name is "head"</dt>
   <dt>Any other end tag</dt>
   <dd>
    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>
   </dd>

   <dt>Anything else</dt>
   <dd>

    <!-- can't get here with an EOF and a fragment case -->

    <!-- start of fake </head> -->
    <p>Pop the <a href="#current-node">current node</a> (which will be the <code><a href="document-metadata.html#the-head-element">head</a></code> element) off the
    <a href="#stack-of-open-elements">stack of open elements</a>.</p>

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: after head" href="#the-after-head-insertion-mode">after
    head</a>".</p>
    <!-- end of fake </head> -->

    <p>Reprocess the token.</p>

   </dd>

  </dl><h6 id="parsing-main-inheadnoscript"><span class="secno">8.2.5.4.5 </span>The "<dfn data-anolis-xref="insertion mode: in head noscript" id="insertion-mode:-in-head-noscript">in head noscript</dfn>" insertion mode</h6>

  <p>When the user agent is to apply the rules for the "<a data-anolis-xref="insertion mode: in head
  noscript" href="#parsing-main-inheadnoscript">in head noscript</a>" <a href="#insertion-mode">insertion mode</a>, the user agent must handle the
  token as follows:</p>

  <dl class="switch"><dt>A DOCTYPE token</dt>
   <dd>
    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>
   </dd>

   <dt>A start tag whose tag name is "html"</dt>
   <dd>

    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    body" href="#parsing-main-inbody">in body</a>" <a href="#insertion-mode">insertion mode</a>.</p>

   </dd>

   <dt>An end tag whose tag name is "noscript"</dt>
   <dd>

    <p>Pop the <a href="#current-node">current node</a> (which will be a <code><a href="scripting-1.html#the-noscript-element">noscript</a></code> element) from the
    <a href="#stack-of-open-elements">stack of open elements</a>; the new <a href="#current-node">current node</a> will be a
    <code><a href="document-metadata.html#the-head-element">head</a></code> element.</p>

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in head" href="#parsing-main-inhead">in
    head</a>".</p>

   </dd>

   <dt>A character token that is one of U+0009 CHARACTER TABULATION, "LF" (U+000A), "FF" (U+000C), "CR" (U+000D), or U+0020 SPACE</dt>
   <dt>A comment token</dt>
   <dt>A start tag whose tag name is one of: "basefont", "bgsound", "link", "meta", "noframes",
   "style"</dt>
   <dd>

    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    head" href="#parsing-main-inhead">in head</a>" <a href="#insertion-mode">insertion mode</a>.</p>

   </dd>

   <dt>An end tag whose tag name is "br"</dt>
   <dd>
    <p>Act as described in the "anything else" entry below.</p>
   </dd>

   <dt>A start tag whose tag name is one of: "head", "noscript"</dt>
   <dt>Any other end tag</dt>
   <dd>
    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>
   </dd>

   <dt>Anything else</dt>
   <dd>

    <!-- can't get here with an EOF and a fragment case -->

    <p><a href="#parse-error">Parse error</a>.</p>

    <!-- fake </noscript> -->
    <p>Pop the <a href="#current-node">current node</a> (which will be a <code><a href="scripting-1.html#the-noscript-element">noscript</a></code> element) from the
    <a href="#stack-of-open-elements">stack of open elements</a>; the new <a href="#current-node">current node</a> will be a
    <code><a href="document-metadata.html#the-head-element">head</a></code> element.</p>

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in head" href="#parsing-main-inhead">in
    head</a>".</p>
    <!-- end fake </noscript> -->

    <p>Reprocess the token.</p>

   </dd>

  </dl><h6 id="the-after-head-insertion-mode"><span class="secno">8.2.5.4.6 </span>The "<dfn data-anolis-xref="insertion mode: after head" id="insertion-mode:-after-head">after head</dfn>" insertion mode</h6>

  <p>When the user agent is to apply the rules for the "<a data-anolis-xref="insertion mode: after
  head" href="#the-after-head-insertion-mode">after head</a>" <a href="#insertion-mode">insertion mode</a>, the user agent must handle the token as
  follows:</p>

  <dl class="switch"><dt>A character token that is one of U+0009 CHARACTER
   TABULATION, "LF" (U+000A), "FF" (U+000C),
   "CR" (U+000D), or U+0020 SPACE</dt>
   <dd>
    <p><a data-anolis-xref="insert a character" href="#insert-a-character">Insert the character</a>.</p>
   </dd>

   <dt>A comment token</dt>
   <dd>
    <p><a href="#insert-a-comment">Insert a comment</a>.</p>
   </dd>

   <dt>A DOCTYPE token</dt>
   <dd>
    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>
   </dd>

   <dt>A start tag whose tag name is "html"</dt>
   <dd>

    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    body" href="#parsing-main-inbody">in body</a>" <a href="#insertion-mode">insertion mode</a>.</p>

   </dd>

   <dt>A start tag whose tag name is "body"</dt>
   <dd>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token.</p>

    <p>Set the <a href="#frameset-ok-flag">frameset-ok flag</a> to "not ok".</p>

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in body" href="#parsing-main-inbody">in
    body</a>".</p>

   </dd>

   <dt>A start tag whose tag name is "frameset"</dt>
   <dd>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token.</p>

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in frameset" href="#parsing-main-inframeset">in
    frameset</a>".</p>

   </dd>

   <dt>A start tag whose tag name is one of: "base", "basefont", "bgsound", "link", "meta",
   "noframes", "script", "style", "template", "title"</dt>
   <dd>

    <p><a href="#parse-error">Parse error</a>.</p>

    <p>Push the node pointed to by the <a href="#head-element-pointer"><code data-anolis-xref="">head</code> element pointer</a> onto
    the <a href="#stack-of-open-elements">stack of open elements</a>.</p>

    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    head" href="#parsing-main-inhead">in head</a>" <a href="#insertion-mode">insertion mode</a>.</p>

    <p>Remove the node pointed to by the <a href="#head-element-pointer"><code data-anolis-xref="">head</code> element pointer</a>
    from the <a href="#stack-of-open-elements">stack of open elements</a>. (It might not be the <a href="#current-node">current node</a> at
    this point.)</p>

    <p class="note">The <a href="#head-element-pointer"><code data-anolis-xref="">head</code> element pointer</a> cannot be null at
    this point.</p>

   </dd>

   <dt>An end tag whose tag name is "template"</dt>
   <dd>
    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    head" href="#parsing-main-inhead">in head</a>" <a href="#insertion-mode">insertion mode</a>.</p>
   </dd>

   <dt>An end tag whose tag name is one of: "body", "html", "br"</dt>
   <dd>
    <p>Act as described in the "anything else" entry below.</p>
   </dd>

   <dt>A start tag whose tag name is "head"</dt>
   <dt>Any other end tag</dt>
   <dd>
    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>
   </dd>

   <dt>Anything else</dt>
   <dd>

    <!-- fake <body>, but without resetting frameset-ok -->
    <p><a href="#insert-an-html-element">Insert an HTML element</a> for a "body" start tag token with no attributes.</p>

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in body" href="#parsing-main-inbody">in
    body</a>".</p>
    <!-- end fake <body> -->

    <p>Reprocess the current token.</p>

   </dd>

  </dl><h6 id="parsing-main-inbody"><span class="secno">8.2.5.4.7 </span>The "<dfn data-anolis-xref="insertion mode: in body" id="insertion-mode:-in-body">in body</dfn>" insertion mode</h6>

  <p>When the user agent is to apply the rules for the "<a data-anolis-xref="insertion mode: in body" href="#parsing-main-inbody">in
  body</a>" <a href="#insertion-mode">insertion mode</a>, the user agent must handle the token as follows:</p>

  <dl class="switch"><dt>A character token that is U+0000 NULL</dt>
   <dd>

    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>

    <!-- The D-Link DSL-G604T ADSL router has a zero byte in its
         configuration UI before a <frameset>, which is why U+0000 is
         special-cased here.
         refs: https://bugzilla.mozilla.org/show_bug.cgi?id=563526
               http://www.w3.org/Bugs/Public/show_bug.cgi?id=9659
    -->

   </dd>

   <dt>A character token that is one of U+0009 CHARACTER TABULATION,
   "LF" (U+000A), "FF" (U+000C), "CR" (U+000D), or U+0020 SPACE</dt>
   <dd>

    <p><a href="#reconstruct-the-active-formatting-elements">Reconstruct the active formatting elements</a>, if any.</p>

    <p><a data-anolis-xref="insert a character" href="#insert-a-character">Insert the token's character</a>.</p>

   </dd>

   <dt>Any other character token</dt>
   <dd>

    <p><a href="#reconstruct-the-active-formatting-elements">Reconstruct the active formatting elements</a>, if any.</p>

    <p><a data-anolis-xref="insert a character" href="#insert-a-character">Insert the token's character</a>.</p>

    <p>Set the <a href="#frameset-ok-flag">frameset-ok flag</a> to "not ok".</p>

   </dd>

   <dt>A comment token</dt>
   <dd>
    <p><a href="#insert-a-comment">Insert a comment</a>.</p>
   </dd>

   <dt>A DOCTYPE token</dt>
   <dd>
    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>
   </dd>

   <dt>A start tag whose tag name is "html"</dt>
   <dd>

    <p><a href="#parse-error">Parse error</a>.</p>

    <p>If there is a <code><a href="scripting-1.html#the-template-element">template</a></code> element on the <a href="#stack-of-open-elements">stack of open elements</a>, then
    ignore the token.</p>

    <p>Otherwise, for each attribute on the token, check to see if the attribute is already present
    on the top element of the <a href="#stack-of-open-elements">stack of open elements</a>. If it is not, add the attribute
    and its corresponding value to that element.</p>

   </dd>

   <dt>A start tag whose tag name is one of: "base", "basefont", "bgsound", "link", "meta",
   "noframes", "script", "style", "template", "title"</dt>
   <dt>An end tag whose tag name is "template"</dt>
   <dd>
    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    head" href="#parsing-main-inhead">in head</a>" <a href="#insertion-mode">insertion mode</a>.</p>
   </dd>

   <dt>A start tag whose tag name is "body"</dt>
   <dd>

    <p><a href="#parse-error">Parse error</a>.</p>

    <p>If the second element on the <a href="#stack-of-open-elements">stack of open elements</a> is not a <code><a href="sections.html#the-body-element">body</a></code>
    element, if the <a href="#stack-of-open-elements">stack of open elements</a> has only one node on it, or if there is a
    <code><a href="scripting-1.html#the-template-element">template</a></code> element on the <a href="#stack-of-open-elements">stack of open elements</a>, then ignore the token.
    (<a href="#fragment-case">fragment case</a>)</p>

    <p>Otherwise, set the <a href="#frameset-ok-flag">frameset-ok flag</a> to "not ok"; then, for each attribute on the
    token, check to see if the attribute is already present on the <code><a href="sections.html#the-body-element">body</a></code> element (the
    second element) on the <a href="#stack-of-open-elements">stack of open elements</a>, and if it is not, add the attribute
    and its corresponding value to that element.</p>

   </dd>

   <dt>A start tag whose tag name is "frameset"</dt>
   <dd>

    <p><a href="#parse-error">Parse error</a>.</p>

    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> has only one node on it, or if the second element
    on the <a href="#stack-of-open-elements">stack of open elements</a> is not a <code><a href="sections.html#the-body-element">body</a></code> element, then ignore the
    token. (<a href="#fragment-case">fragment case</a>)</p>

    <p>If the <a href="#frameset-ok-flag">frameset-ok flag</a> is set to "not ok", ignore the token.</p>

    <p>Otherwise, run the following steps:</p>

    <ol><li><p>Remove the second element on the <a href="#stack-of-open-elements">stack of open elements</a> from its parent
     node, if it has one.</li>

     <li><p>Pop all the nodes from the bottom of the <a href="#stack-of-open-elements">stack of open elements</a>, from the
     <a href="#current-node">current node</a> up to, but not including, the root <code><a href="semantics.html#the-html-element">html</a></code> element.</p>

     </li><li><p><a href="#insert-an-html-element">Insert an HTML element</a> for the token.</li>

     <li><p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in frameset" href="#parsing-main-inframeset">in
     frameset</a>".</p>

    </li></ol></dd>

   <dt>An end-of-file token</dt>
   <dd>

    <p>If there is a node in the <a href="#stack-of-open-elements">stack of open elements</a> that is not either a
    <code><a href="grouping-content.html#the-dd-element">dd</a></code> element, a <code><a href="grouping-content.html#the-dt-element">dt</a></code> element, an <code><a href="grouping-content.html#the-li-element">li</a></code> element, a <code><a href="grouping-content.html#the-p-element">p</a></code>
    element, a <code><a href="tabular-data.html#the-tbody-element">tbody</a></code> element, a <code><a href="tabular-data.html#the-td-element">td</a></code> element, a <code><a href="tabular-data.html#the-tfoot-element">tfoot</a></code> element,
    a <code><a href="tabular-data.html#the-th-element">th</a></code> element, a <code><a href="tabular-data.html#the-thead-element">thead</a></code> element, a <code><a href="tabular-data.html#the-tr-element">tr</a></code> element, the
    <code><a href="sections.html#the-body-element">body</a></code> element, or the <code><a href="semantics.html#the-html-element">html</a></code> element, then this is a <a href="#parse-error">parse
    error</a>.</p> <!-- (some of those are fragment cases) -->

    <p>If the <a href="#stack-of-template-insertion-modes">stack of template insertion modes</a> is not empty, then process the token
    <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in template" href="#parsing-main-intemplate">in
    template</a>" <a href="#insertion-mode">insertion mode</a>.</p>
    <!-- this is needed to handle <head><template>...[EOF] - otherwise we don't construct the <body> element -->

    <p>Otherwise, <a href="#stop-parsing">stop parsing</a>.</p>

   </dd>

   <dt>An end tag whose tag name is "body"</dt>
   <dd>

    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> does not <a data-anolis-xref="has an element in
    scope" href="#has-an-element-in-scope">have a <code>body</code> element in scope</a>, this is a <a href="#parse-error">parse error</a>;
    ignore the token.</p>

    <!-- if we get here, the insertion mode here is forcibly "in body". -->

    <!-- FORK -->
    <p>Otherwise, if there is a node in the <a href="#stack-of-open-elements">stack of open elements</a> that is not either a
    <code><a href="grouping-content.html#the-dd-element">dd</a></code> element, a <code><a href="grouping-content.html#the-dt-element">dt</a></code> element, an <code><a href="grouping-content.html#the-li-element">li</a></code> element, an
    <code><a href="forms.html#the-optgroup-element">optgroup</a></code> element, an <code><a href="forms.html#the-option-element">option</a></code> element, a <code><a href="grouping-content.html#the-p-element">p</a></code> element, an
    <code><a href="text-level-semantics.html#the-rb-element">rb</a></code> element, an <code><a href="text-level-semantics.html#the-rp-element">rp</a></code> element, an <code><a href="text-level-semantics.html#the-rt-element">rt</a></code> element, an
    <code><a href="text-level-semantics.html#the-rtc-element">rtc</a></code> element, a <code><a href="tabular-data.html#the-tbody-element">tbody</a></code> element, a <code><a href="tabular-data.html#the-td-element">td</a></code> element, a
    <code><a href="tabular-data.html#the-tfoot-element">tfoot</a></code> element, a <code><a href="tabular-data.html#the-th-element">th</a></code> element, a <code><a href="tabular-data.html#the-thead-element">thead</a></code> element, a
    <code><a href="tabular-data.html#the-tr-element">tr</a></code> element, the <code><a href="sections.html#the-body-element">body</a></code> element, or the <code><a href="semantics.html#the-html-element">html</a></code> element, then
    this is a <a href="#parse-error">parse error</a>.</p> <!-- (some of those are fragment cases, e.g. for <tbody>
    you'd have hit the first paragraph since the <body> wouldn't be in scope, unless it was a
    fragment case) -->
    <!-- /FORK -->

    <!-- If we ever change the frameset-ok flag to an insertion mode, then we'd have to somehow keep
    track of its state when we switch to after-body. -->

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: after body" href="#parsing-main-afterbody">after
    body</a>".</p>

   </dd>

   <dt>An end tag whose tag name is "html"</dt>
   <dd>

    <!-- fake </body> -->
    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> does not <a data-anolis-xref="has an element in
    scope" href="#has-an-element-in-scope">have a <code>body</code> element in scope</a>, this is a <a href="#parse-error">parse error</a>;
    ignore the token.</p>

    <!-- if we get here, the insertion mode here is forcibly "in body". -->

    <!-- FORK -->
    <p>Otherwise, if there is a node in the <a href="#stack-of-open-elements">stack of open elements</a> that is not either a
    <code><a href="grouping-content.html#the-dd-element">dd</a></code> element, a <code><a href="grouping-content.html#the-dt-element">dt</a></code> element, an <code><a href="grouping-content.html#the-li-element">li</a></code> element, an
    <code><a href="forms.html#the-optgroup-element">optgroup</a></code> element, an <code><a href="forms.html#the-option-element">option</a></code> element, a <code><a href="grouping-content.html#the-p-element">p</a></code> element, an
    <code><a href="text-level-semantics.html#the-rb-element">rb</a></code> element, an <code><a href="text-level-semantics.html#the-rp-element">rp</a></code> element, an <code><a href="text-level-semantics.html#the-rt-element">rt</a></code> element, an
    <code><a href="text-level-semantics.html#the-rtc-element">rtc</a></code> element, a <code><a href="tabular-data.html#the-tbody-element">tbody</a></code> element, a <code><a href="tabular-data.html#the-td-element">td</a></code> element, a
    <code><a href="tabular-data.html#the-tfoot-element">tfoot</a></code> element, a <code><a href="tabular-data.html#the-th-element">th</a></code> element, a <code><a href="tabular-data.html#the-thead-element">thead</a></code> element, a
    <code><a href="tabular-data.html#the-tr-element">tr</a></code> element, the <code><a href="sections.html#the-body-element">body</a></code> element, or the <code><a href="semantics.html#the-html-element">html</a></code> element, then
    this is a <a href="#parse-error">parse error</a>.</p> <!-- (some of those are fragment cases, e.g. for <tbody>
    you'd have hit the first paragraph since the <body> wouldn't be in scope, unless it was a
    fragment case) -->
    <!-- /FORK -->

    <!-- If we ever change the frameset-ok flag to an insertion mode, then we'd have to somehow keep
    track of its state when we switch to after-body. -->

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: after body" href="#parsing-main-afterbody">after
    body</a>".</p>
    <!-- end fake </body> -->

    <p>Reprocess the token.</p>

   </dd>

   <!-- start tags for non-phrasing flow content elements -->

   <!-- the normal ones -->
   <dt>A start tag whose tag name is one of: "address", "article", "aside", "blockquote", "center",
   "details", "dialog", "dir", "div", "dl", "fieldset", "figcaption", "figure", "footer", "header",
   "hgroup", "main", "nav", "ol", "p", "section", "summary", "ul"</dt>
   <dd>

    <!-- As of May 2008 this doesn't match any browser exactly, but is as close to what IE does as I
    can get without doing the non-tree DOM nonsense, and thus should actually afford better
    compatibility when implemented by the other browsers. -->

    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> <a data-anolis-xref="has an element in button scope" href="#has-an-element-in-button-scope">has a
    <code>p</code> element in button scope</a>, then <a href="#close-a-p-element">close a <code>p</code>
    element</a>.</p>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token.</p>

   </dd>

   <!-- as normal, but close h1-h6 if it's the current node -->
   <dt>A start tag whose tag name is one of: "h1", "h2", "h3", "h4",
   "h5", "h6"</dt>
   <dd>

    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> <a data-anolis-xref="has an element in button scope" href="#has-an-element-in-button-scope">has a
    <code>p</code> element in button scope</a>, then <a href="#close-a-p-element">close a <code>p</code>
    element</a>.</p>

    <p>If the <a href="#current-node">current node</a> is an <a data-anolis-xref="HTML elements" href="infrastructure.html#html-elements">HTML element</a> whose
    tag name is one of "h1", "h2", "h3", "h4", "h5", or "h6", then this is a <a href="#parse-error">parse
    error</a>; pop the <a href="#current-node">current node</a> off the <a href="#stack-of-open-elements">stack of open elements</a>.</p>
    <!-- See https://bugs.webkit.org/show_bug.cgi?id=12646 -->

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token.</p>

   </dd>

   <!-- as normal, but drops leading newline -->
   <dt>A start tag whose tag name is one of: "pre", "listing"</dt>
   <dd>

    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> <a data-anolis-xref="has an element in button scope" href="#has-an-element-in-button-scope">has a
    <code>p</code> element in button scope</a>, then <a href="#close-a-p-element">close a <code>p</code>
    element</a>.</p>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token.</p>

    <p>If the <a href="#next-token">next token</a> is a "LF" (U+000A) character token, then ignore that
    token and move on to the next one. (Newlines at the start of <code><a href="grouping-content.html#the-pre-element">pre</a></code> blocks are ignored
    as an authoring convenience.)</p>

    <!-- <pre>[CR]X will eat the [CR], <pre>&#x10;X will eat the
    &#x10;, but <pre>&#x13;X will not eat the &#x13;. -->

    <p>Set the <a href="#frameset-ok-flag">frameset-ok flag</a> to "not ok".</p>

   </dd>

   <!-- as normal, but interacts with the form element pointer -->
   <dt>A start tag whose tag name is "form"</dt>
   <dd>

<!--CLEANUP-->
    <p>If the <a href="#form-element-pointer"><code data-anolis-xref="form">form</code> element pointer</a> is not null, and there is no <code><a href="scripting-1.html#the-template-element">template</a></code> element on the <a href="#stack-of-open-elements">stack of open elements</a>, then this is
    a <a href="#parse-error">parse error</a>; ignore the token.</p>

    <p>Otherwise:</p>

    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> <a data-anolis-xref="has an element in button scope" href="#has-an-element-in-button-scope">has a
    <code>p</code> element in button scope</a>, then <a href="#close-a-p-element">close a <code>p</code>
    element</a>.</p>

<!--CLEANUP-->
    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token, and, if there is no <code><a href="scripting-1.html#the-template-element">template</a></code> element on the <a href="#stack-of-open-elements">stack of open elements</a>, set the <a href="#form-element-pointer"><code data-anolis-xref="form">form</code> element pointer</a> to point to the element created.</p>

   </dd>

   <!-- as normal, but imply </li> when there's another <li> open in weird cases -->
   <dt>A start tag whose tag name is "li"</dt>
   <dd>

    <p>Run these steps:</p>

    <ol><li><p>Set the <a href="#frameset-ok-flag">frameset-ok flag</a> to "not ok".</li>

     <li><p>Initialize <var data-anolis-xref="">node</var> to be the <a href="#current-node">current
     node</a> (the bottommost node of the stack).</li>

     <li>

      <p><i>Loop</i>: If <var data-anolis-xref="">node</var> is an <code><a href="grouping-content.html#the-li-element">li</a></code> element, then run these
      substeps:</p>

      <ol><!-- fake </li> --><li><p><a href="#generate-implied-end-tags">Generate implied end tags</a>, except for <code><a href="grouping-content.html#the-li-element">li</a></code> elements.</li>

       <li><p>If the <a href="#current-node">current node</a> is not an <code><a href="grouping-content.html#the-li-element">li</a></code> element, then this is a
       <a href="#parse-error">parse error</a>.</li>

       <li><p>Pop elements from the <a href="#stack-of-open-elements">stack of open elements</a> until an <code><a href="grouping-content.html#the-li-element">li</a></code>
       element has been popped from the stack.</li>
       <!-- end of fake </li> -->

       <li><p>Jump to the step labeled <i>done</i> below.</li>

      </ol></li>

     <li><p>If <var data-anolis-xref="">node</var> is in the <a href="#special">special</a> category, but is not an
     <code><a href="sections.html#the-address-element">address</a></code>, <code><a href="grouping-content.html#the-div-element">div</a></code>, or <code><a href="grouping-content.html#the-p-element">p</a></code> element, then jump to the step
     labeled <i>done</i> below.</li>
     <!-- an element <foo> is in this list if the following markup:

         <!DOCTYPE html><body><ol><li><foo><li>

     ...results in the second <li> not being (in any way) a descendant of the first <li>, or if
     <foo> is a formatting element that gets reopened later. -->


     <li><p>Otherwise, set <var data-anolis-xref="">node</var> to the previous entry in the <a href="#stack-of-open-elements">stack of open
     elements</a> and return to the step labeled <i>loop</i>.</li>

     <li><p><i>Done</i>: If the <a href="#stack-of-open-elements">stack of open elements</a> <a data-anolis-xref="has an element in
     button scope" href="#has-an-element-in-button-scope">has a <code>p</code> element in button scope</a>, then <a href="#close-a-p-element">close a
     <code>p</code> element</a>.</li>

     <li><p>Finally, <a href="#insert-an-html-element">insert an HTML element</a> for the token.</li>

    </ol></dd>

   <!-- as normal, but imply </dt> or </dd> when there's another <dt> or <dd> open in weird cases  -->
   <dt>A start tag whose tag name is one of: "dd", "dt"</dt>
   <dd>

    <p>Run these steps:</p>

    <ol><li><p>Set the <a href="#frameset-ok-flag">frameset-ok flag</a> to "not ok".</li>

     <li><p>Initialize <var data-anolis-xref="">node</var> to be the <a href="#current-node">current
     node</a> (the bottommost node of the stack).</li>

     <li>

      <p><i>Loop</i>: If <var data-anolis-xref="">node</var> is a <code><a href="grouping-content.html#the-dd-element">dd</a></code> element, then run these
      substeps:</p>

      <ol><!-- fake </dd> --><li><p><a href="#generate-implied-end-tags">Generate implied end tags</a>, except for <code><a href="grouping-content.html#the-dd-element">dd</a></code> elements.</li>

       <li><p>If the <a href="#current-node">current node</a> is not a <code><a href="grouping-content.html#the-dd-element">dd</a></code> element, then this is a
       <a href="#parse-error">parse error</a>.</li>

       <li><p>Pop elements from the <a href="#stack-of-open-elements">stack of open elements</a> until a <code><a href="grouping-content.html#the-dd-element">dd</a></code>
       element has been popped from the stack.</li>
       <!-- end of fake </dd> -->

       <li><p>Jump to the step labeled <i>done</i> below.</li>

      </ol></li>

     <li>

      <p>If <var data-anolis-xref="">node</var> is a <code><a href="grouping-content.html#the-dt-element">dt</a></code> element, then run these substeps:</p>

      <ol><!-- fake </dt> --><li><p><a href="#generate-implied-end-tags">Generate implied end tags</a>, except for <code><a href="grouping-content.html#the-dt-element">dt</a></code> elements.</li>

       <li><p>If the <a href="#current-node">current node</a> is not a <code><a href="grouping-content.html#the-dt-element">dt</a></code> element, then this is a
       <a href="#parse-error">parse error</a>.</li>

       <li><p>Pop elements from the <a href="#stack-of-open-elements">stack of open elements</a> until a <code><a href="grouping-content.html#the-dt-element">dt</a></code>
       element has been popped from the stack.</li>
       <!-- end of fake </dt> -->

       <li><p>Jump to the step labeled <i>done</i> below.</li>

      </ol></li>

     <li><p>If <var data-anolis-xref="">node</var> is in the <a href="#special">special</a> category, but is not an
     <code><a href="sections.html#the-address-element">address</a></code>, <code><a href="grouping-content.html#the-div-element">div</a></code>, or <code><a href="grouping-content.html#the-p-element">p</a></code> element, then jump to the step
     labeled <i>done</i> below.</li>
     <!-- an element <foo> is in this list if the following markup:

         <!DOCTYPE html><body><dl><dt><foo><dt>

     ...results in the second <dt> not being (in any way) a descendant of the first <dt>, or if
     <foo> is a formatting element that gets reopened later. -->


     <li><p>Otherwise, set <var data-anolis-xref="">node</var> to the previous entry in the <a href="#stack-of-open-elements">stack of open
     elements</a> and return to the step labeled <i>loop</i>.</li>

     <li><p><i>Done</i>: If the <a href="#stack-of-open-elements">stack of open elements</a> <a data-anolis-xref="has an element in
     button scope" href="#has-an-element-in-button-scope">has a <code>p</code> element in button scope</a>, then <a href="#close-a-p-element">close a
     <code>p</code> element</a>.</li>

     <li><p>Finally, <a href="#insert-an-html-element">insert an HTML element</a> for the token.</li>

    </ol></dd>

   <!-- same as normal, but effectively ends parsing -->
   <dt>A start tag whose tag name is "plaintext"</dt>
   <dd>


    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> <a data-anolis-xref="has an element in button scope" href="#has-an-element-in-button-scope">has a
    <code>p</code> element in button scope</a>, then <a href="#close-a-p-element">close a <code>p</code>
    element</a>.</p>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token.</p>

    <p>Switch the tokenizer to the <a href="#plaintext-state">PLAINTEXT state</a>.</p>

    <p class="note">Once a start tag with the tag name "plaintext" has been seen, that will be the
    last token ever seen other than character tokens (and the end-of-file token), because there is
    no way to switch out of the <a href="#plaintext-state">PLAINTEXT state</a>.</p>

   </dd>

   <!-- button is a hybrid -->
   <dt>A start tag whose tag name is "button"</dt>
   <dd>

    <ol><li>

      <p>If the <a href="#stack-of-open-elements">stack of open elements</a> <a data-anolis-xref="has an element in scope" href="#has-an-element-in-scope">has a
      <code>button</code> element in scope</a>, then run these substeps:</p>

      <ol><li><p><a href="#parse-error">Parse error</a>.</li>

       <li><p><a href="#generate-implied-end-tags">Generate implied end tags</a>.</li>

       <li><p>Pop elements from the <a href="#stack-of-open-elements">stack of open elements</a> until a <code><a href="forms.html#the-button-element">button</a></code>
       element has been popped from the stack.</li>

      </ol></li>

     <li><p><a href="#reconstruct-the-active-formatting-elements">Reconstruct the active formatting elements</a>, if any.</li>

     <li><p><a href="#insert-an-html-element">Insert an HTML element</a> for the token.</li>

     <li><p>Set the <a href="#frameset-ok-flag">frameset-ok flag</a> to "not ok".</li>

    </ol></dd>

   <!-- end tags for non-phrasing flow content elements (and button) -->

   <!-- the normal ones -->
   <dt>An end tag whose tag name is one of: "address", "article", "aside", "blockquote", "button",
   "center", "details", "dialog", "dir", "div", "dl", "fieldset", "figcaption", "figure", "footer",
   "header", "hgroup", "listing", "main", "nav", "ol", "pre", "section", "summary",
   "ul"</dt>
   <dd>


    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> does not <a data-anolis-xref="has an element in
    scope" href="#has-an-element-in-scope">have an element in scope</a> that is an <a data-anolis-xref="HTML elements" href="infrastructure.html#html-elements">HTML
    element</a> and with the same tag name as that of the token, then this is a <a href="#parse-error">parse
    error</a>; ignore the token.</p>

    <p>Otherwise, run these steps:</p>

    <ol><li><p><a href="#generate-implied-end-tags">Generate implied end tags</a>.</li>

     <li><p>If the <a href="#current-node">current node</a> is not an <a data-anolis-xref="HTML elements" href="infrastructure.html#html-elements">HTML element</a> with
     the same tag name as that of the token, then this is a
     <a href="#parse-error">parse error</a>.</li>


     <li><p>Pop elements from the <a href="#stack-of-open-elements">stack of open elements</a> until an <a data-anolis-xref="HTML
     elements" href="infrastructure.html#html-elements">HTML element</a> with the same tag name as the token has been popped from the
     stack.</li>

    </ol></dd>

   <!-- removes the form element pointer instead of the matching node -->
   <dt>An end tag whose tag name is "form"</dt>
   <dd>

    <p>If there is no <code><a href="scripting-1.html#the-template-element">template</a></code> element on the <a href="#stack-of-open-elements">stack of open elements</a>, then
    run these substeps:</p>

    <ol><li><p>Let <var data-anolis-xref="">node</var> be the element that the <a href="#form-element-pointer"><code data-anolis-xref="">form</code>
     element pointer</a> is set to, or null if it is not set to an element.</li>

     <li><p>Set the <a href="#form-element-pointer"><code data-anolis-xref="">form</code> element pointer</a> to null. Otherwise, let
     <var data-anolis-xref="">node</var> be null.</li>

     <li><p>If <var data-anolis-xref="">node</var> is null or if the <a href="#stack-of-open-elements">stack of open elements</a> does
     not <a data-anolis-xref="has an element in scope" href="#has-an-element-in-scope">have <var data-anolis-xref="">node</var> in scope</a>, then
     this is a <a href="#parse-error">parse error</a>; abort these steps and ignore the token.</li>

     <li><p><a href="#generate-implied-end-tags">Generate implied end tags</a>.</li>

     <li><p>If the <a href="#current-node">current node</a> is not <var data-anolis-xref="">node</var>, then this is a
     <a href="#parse-error">parse error</a>.</li>

     <li><p>Remove <var data-anolis-xref="">node</var> from the <a href="#stack-of-open-elements">stack of open elements</a>.</li>

    </ol><p>If there <em>is</em> a <code><a href="scripting-1.html#the-template-element">template</a></code> element on the <a href="#stack-of-open-elements">stack of open
    elements</a>, then run these substeps instead:</p>

    <ol><li><p>If the <a href="#stack-of-open-elements">stack of open elements</a> does not <a data-anolis-xref="has an element in
     scope" href="#has-an-element-in-scope">have a <code>form</code> element in scope</a>, then this is a <a href="#parse-error">parse
     error</a>; abort these steps and ignore the token.</li>

     <li><p><a href="#generate-implied-end-tags">Generate implied end tags</a>.</li>

     <li><p>If the <a href="#current-node">current node</a> is not a <code><a href="forms.html#the-form-element">form</a></code> element, then this is a
     <a href="#parse-error">parse error</a>.</li>

     <li><p>Pop elements from the <a href="#stack-of-open-elements">stack of open elements</a> until a <code><a href="forms.html#the-form-element">form</a></code>
     element has been popped from the stack.</li>

    </ol></dd>

   <!-- as normal, except </p> implies <p> if there's no <p> in scope, and needs care as the elements have optional tags -->
   <dt>An end tag whose tag name is "p"</dt>
   <dd>

    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> does not <a data-anolis-xref="has an element in button
    scope" href="#has-an-element-in-button-scope">have a <code>p</code> element in button scope</a>, then this is a <a href="#parse-error">parse
    error</a>; <a href="#insert-an-html-element">insert an HTML element</a> for a "p" start tag token with no
    attributes.</p>

    <p><a href="#close-a-p-element">Close a <code>p</code> element</a>.</p>

   </dd>

   <!-- as normal, but needs care as the elements have optional tags, and are further scoped by <ol>/<ul> -->
   <dt>An end tag whose tag name is "li"</dt>
   <dd>


    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> does not <a data-anolis-xref="has an element in list item
    scope" href="#has-an-element-in-list-item-scope">have an <code>li</code> element in list item scope</a>, then this is a <a href="#parse-error">parse
    error</a>; ignore the token.</p>

    <p>Otherwise, run these steps:</p>

    <ol><li><p><a href="#generate-implied-end-tags">Generate implied end tags</a>, except for <code><a href="grouping-content.html#the-li-element">li</a></code> elements.</li>

     <li><p>If the <a href="#current-node">current node</a> is not an <code><a href="grouping-content.html#the-li-element">li</a></code> element, then this is a
     <a href="#parse-error">parse error</a>.</li>

     <li><p>Pop elements from the <a href="#stack-of-open-elements">stack of open elements</a> until an <code><a href="grouping-content.html#the-li-element">li</a></code>
     element has been popped from the stack.</li>

    </ol></dd>

   <!-- as normal, but needs care as the elements have optional tags -->
   <dt>An end tag whose tag name is one of: "dd", "dt"</dt>
   <dd>


    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> does not <a data-anolis-xref="has an element in
    scope" href="#has-an-element-in-scope">have an element in scope</a> that is an <a data-anolis-xref="HTML elements" href="infrastructure.html#html-elements">HTML
    element</a> and with the same tag name as that of the token, then this is a <a href="#parse-error">parse
    error</a>; ignore the token.</p>

    <p>Otherwise, run these steps:</p>

    <ol><li><p><a href="#generate-implied-end-tags">Generate implied end tags</a>, except for <a href="infrastructure.html#html-elements">HTML elements</a> with the
     same tag name as the token.</li>


     <li><p>If the <a href="#current-node">current node</a> is not an <a data-anolis-xref="HTML elements" href="infrastructure.html#html-elements">HTML
     element</a> with the same tag name as that of the token, then this is a <a href="#parse-error">parse
     error</a>.</li>

     <li><p>Pop elements from the <a href="#stack-of-open-elements">stack of open elements</a> until an <a data-anolis-xref="HTML
     elements" href="infrastructure.html#html-elements">HTML element</a> with the same tag name as the token has been popped from the
     stack.</li>

    </ol></dd>

   <!-- as normal, except acts as a closer for any of the h1-h6 elements -->
   <dt>An end tag whose tag name is one of: "h1", "h2", "h3", "h4", "h5", "h6"</dt>
   <dd>


    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> does not <a data-anolis-xref="has an element in
    scope" href="#has-an-element-in-scope">have an element in scope</a> that is an <a data-anolis-xref="HTML elements" href="infrastructure.html#html-elements">HTML
    element</a> and whose tag name is one of "h1", "h2", "h3", "h4", "h5", or "h6", then this is
    a <a href="#parse-error">parse error</a>; ignore the token.</p>

    <p>Otherwise, run these steps:</p>

    <ol><li><p><a href="#generate-implied-end-tags">Generate implied end tags</a>.</li>


     <li><p>If the <a href="#current-node">current node</a> is not an <a data-anolis-xref="HTML elements" href="infrastructure.html#html-elements">HTML
     element</a> with the same tag name as that of the token, then this is a <a href="#parse-error">parse
     error</a>.</li>

     <li><p>Pop elements from the <a href="#stack-of-open-elements">stack of open elements</a> until an <a data-anolis-xref="HTML
     elements" href="infrastructure.html#html-elements">HTML element</a> whose tag name is one of "h1", "h2", "h3", "h4", "h5", or "h6"
     has been popped from the stack.</li>

    </ol></dd>

   <!-- see also applet/marquee/object lower down -->

   <dt>An end tag whose tag name is "sarcasm"</dt>
   <dd>
    <p>Take a deep breath, then act as described in the "any other end
    tag" entry below.</p>
   </dd>

   <!-- ADOPTION AGENCY ELEMENTS
        Mozilla-only: bdo blink del ins sub sup q
        Safari-only: code dfn kbd nobr samp var wbr
        Both: a b big em font i s small strike strong tt u -->

   <dt>A start tag whose tag name is "a"</dt>
   <dd>


    <p>If the <a href="#list-of-active-formatting-elements">list of active formatting elements</a> contains an <code><a href="text-level-semantics.html#the-a-element">a</a></code> element
    between the end of the list and the last marker on the list (or the start of the list if there
    is no marker on the list), then this is a <a href="#parse-error">parse error</a>; run the <a href="#adoption-agency-algorithm">adoption
    agency algorithm</a> for the tag name "a", then remove that element from the <a href="#list-of-active-formatting-elements">list of
    active formatting elements</a> and the <a href="#stack-of-open-elements">stack of open elements</a> if the
    <a href="#adoption-agency-algorithm">adoption agency algorithm</a> didn't already remove it (it might not have if the
    element is not <a data-anolis-xref="has an element in table scope" href="#has-an-element-in-table-scope">in table scope</a>).</p>

    <p class="example">In the non-conforming stream
    <code>&lt;a href="a"&gt;a&lt;table&gt;&lt;a href="b"&gt;b&lt;/table&gt;x</code>, the first
    <code><a href="text-level-semantics.html#the-a-element">a</a></code> element would be closed upon seeing the second one, and the "x" character would
    be inside a link to "b", not to "a". This is despite the fact that the outer <code><a href="text-level-semantics.html#the-a-element">a</a></code>
    element is not in table scope (meaning that a regular <code>&lt;/a&gt;</code> end tag at the start
    of the table wouldn't close the outer <code><a href="text-level-semantics.html#the-a-element">a</a></code> element). The result is that the two
    <code><a href="text-level-semantics.html#the-a-element">a</a></code> elements are indirectly nested inside each other — non-conforming markup
    will often result in non-conforming DOMs when parsed.</p>

    <p><a href="#reconstruct-the-active-formatting-elements">Reconstruct the active formatting elements</a>, if any.</p>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token. <a href="#push-onto-the-list-of-active-formatting-elements">Push onto the list of active
    formatting elements</a> that element.</p>

   </dd>

   <dt>A start tag whose tag name is one of: "b", "big", "code", "em",
   "font", "i", "s", "small", "strike", "strong", "tt", "u"</dt>
   <dd>

    <p><a href="#reconstruct-the-active-formatting-elements">Reconstruct the active formatting elements</a>, if any.</p>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token. <a href="#push-onto-the-list-of-active-formatting-elements">Push onto the list of active
    formatting elements</a> that element.</p>

   </dd>

   <dt>A start tag whose tag name is "nobr"</dt>
   <dd>

    <p><a href="#reconstruct-the-active-formatting-elements">Reconstruct the active formatting elements</a>, if any.</p>


    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> <a data-anolis-xref="has an element in scope" href="#has-an-element-in-scope">has a
    <code>nobr</code> element in scope</a>, then this is a <a href="#parse-error">parse error</a>; run the
    <a href="#adoption-agency-algorithm">adoption agency algorithm</a> for the tag name "nobr", then once again
    <a href="#reconstruct-the-active-formatting-elements">reconstruct the active formatting elements</a>, if any.</p>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token. <a href="#push-onto-the-list-of-active-formatting-elements">Push onto the list of active
    formatting elements</a> that element.</p>

   </dd>

   <dt>An end tag whose tag name is one of: "a",
   "b", "big", "code", "em", "font", "i", "nobr", "s", "small",
   "strike", "strong", "tt", "u"</dt>
   <dd>

    <p>Run the <a href="#adoption-agency-algorithm">adoption agency algorithm</a> for the token's tag name.</p>

   </dd>

   <dt>A start tag whose tag name is one of: "applet", "marquee", "object"</dt>
   <dd>

    <p><a href="#reconstruct-the-active-formatting-elements">Reconstruct the active formatting elements</a>, if any.</p>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token.</p>

    <p>Insert a marker at the end of the <a href="#list-of-active-formatting-elements">list of active formatting elements</a>.</p>

    <p>Set the <a href="#frameset-ok-flag">frameset-ok flag</a> to "not ok".</p>

   </dd>

   <dt>An end tag token whose tag name is one of: "applet", "marquee", "object"</dt>
   <dd>

    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> does not <a data-anolis-xref="has an element in
    scope" href="#has-an-element-in-scope">have an element in scope</a> that is an <a data-anolis-xref="HTML elements" href="infrastructure.html#html-elements">HTML
    element</a> and with the same tag name as that of the token, then this is a <a href="#parse-error">parse
    error</a>; ignore the token.</p>

    <p>Otherwise, run these steps:</p>

    <ol><li><p><a href="#generate-implied-end-tags">Generate implied end tags</a>.</li>

     <li><p>If the <a href="#current-node">current node</a> is not an <a data-anolis-xref="HTML elements" href="infrastructure.html#html-elements">HTML
     element</a> with the same tag name as that of the token, then this is a <a href="#parse-error">parse
     error</a>.</li>

     <li><p>Pop elements from the <a href="#stack-of-open-elements">stack of open elements</a> until an <a data-anolis-xref="HTML
     elements" href="infrastructure.html#html-elements">HTML element</a> with the same tag name as the token has been popped from the
     stack.</li>

     <li><a href="#clear-the-list-of-active-formatting-elements-up-to-the-last-marker">Clear the list of active formatting elements up to the last marker</a>.</li>

    </ol></dd>

   <dt>A start tag whose tag name is "table"</dt>
   <dd>

    <p>If the <code><a href="dom.html#document">Document</a></code> is <em>not</em> set to <a href="infrastructure.html#quirks-mode">quirks mode</a>, and the
    <a href="#stack-of-open-elements">stack of open elements</a> <a data-anolis-xref="has an element in button scope" href="#has-an-element-in-button-scope">has a
    <code>p</code> element in button scope</a>, then <a href="#close-a-p-element">close a <code>p</code>
    element</a>.</p> <!-- i hate myself (this quirk was basically caused by acid2; if i'd
    realised we could change the specs when i wrote acid2, we could have avoided having any
    parsing-mode quirks) -Hixie -->

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token.</p>

    <p>Set the <a href="#frameset-ok-flag">frameset-ok flag</a> to "not ok".</p>

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in table" href="#parsing-main-intable">in
    table</a>".</p>

   </dd>

   <dt>An end tag whose tag name is "br"</dt>
   <dd>

    <p><a href="#parse-error">Parse error</a>. Act as described in the next entry, as if this was a "br" start tag
    token, rather than an end tag token.</p>

   </dd>

   <!-- do not insert things here, since the previous entry refers to the next entry -->

   <dt>A start tag whose tag name is one of: "area", "br", "embed",
   "img", "keygen", "wbr"</dt>
   <dd>

    <p><a href="#reconstruct-the-active-formatting-elements">Reconstruct the active formatting elements</a>, if any.</p>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token. Immediately pop the <a href="#current-node">current
    node</a> off the <a href="#stack-of-open-elements">stack of open elements</a>.</p>

    <p><a data-anolis-xref="acknowledge self-closing flag" href="#acknowledge-self-closing-flag">Acknowledge the token's <i>self-closing
    flag</i></a>, if it is set.</p>

    <p>Set the <a href="#frameset-ok-flag">frameset-ok flag</a> to "not ok".</p>
    <!-- shouldn't really do this for <area> -->

   </dd>

   <dt>A start tag whose tag name is "input"</dt>
   <dd>

    <p><a href="#reconstruct-the-active-formatting-elements">Reconstruct the active formatting elements</a>, if any.</p>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token. Immediately pop the <a href="#current-node">current
    node</a> off the <a href="#stack-of-open-elements">stack of open elements</a>.</p>

    <p><a data-anolis-xref="acknowledge self-closing flag" href="#acknowledge-self-closing-flag">Acknowledge the token's <i>self-closing
    flag</i></a>, if it is set.</p>

    <p>If the token does not have an attribute with the name "type", or if it does, but that
    attribute's value is not an <a href="infrastructure.html#ascii-case-insensitive">ASCII case-insensitive</a> match for the string "<code data-anolis-xref="">hidden</code>", then: set the <a href="#frameset-ok-flag">frameset-ok flag</a> to "not ok".</p>

   </dd>

   <dt>A start tag whose tag name is one of: "param", "source", "track"</dt>
   <dd>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token. Immediately pop the <a href="#current-node">current
    node</a> off the <a href="#stack-of-open-elements">stack of open elements</a>.</p>

    <p><a data-anolis-xref="acknowledge self-closing flag" href="#acknowledge-self-closing-flag">Acknowledge the token's <i>self-closing
    flag</i></a>, if it is set.</p>

   </dd>

   <dt>A start tag whose tag name is "hr"</dt>
   <dd>

    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> <a data-anolis-xref="has an element in button scope" href="#has-an-element-in-button-scope">has a
    <code>p</code> element in button scope</a>, then <a href="#close-a-p-element">close a <code>p</code>
    element</a>.</p>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token. Immediately pop the <a href="#current-node">current
    node</a> off the <a href="#stack-of-open-elements">stack of open elements</a>.</p>

    <p><a data-anolis-xref="acknowledge self-closing flag" href="#acknowledge-self-closing-flag">Acknowledge the token's <i>self-closing
    flag</i></a>, if it is set.</p>

    <p>Set the <a href="#frameset-ok-flag">frameset-ok flag</a> to "not ok".</p>

   </dd>

   <dt>A start tag whose tag name is "image"</dt>
   <dd>
    <!-- As of 2005-12, studies showed that around 0.2% of pages used the <image> element. -->
    <p><a href="#parse-error">Parse error</a>. Change the token's tag name to "img" and reprocess it. (Don't
    ask.)</p>
   </dd>

   <dt id="isindex">A start tag whose tag name is "isindex"</dt>
   <dd>

    <p><a href="#parse-error">Parse error</a>.</p>

    <p>If there is no <code><a href="scripting-1.html#the-template-element">template</a></code> element on the <a href="#stack-of-open-elements">stack of open elements</a> and
    the <a href="#form-element-pointer"><code data-anolis-xref="">form</code> element pointer</a> is not null, then ignore the
    token.</p>

    <p>Otherwise:</p>

    <p><a data-anolis-xref="acknowledge self-closing flag" href="#acknowledge-self-closing-flag">Acknowledge the token's <i>self-closing
    flag</i></a>, if it is set.</p> <!-- purely to reduce the number of errors (we don't care if
    they included the /, they're not supposed to be including the tag at all! -->

    <p>Set the <a href="#frameset-ok-flag">frameset-ok flag</a> to "not ok".</p>

    <!-- fake <form> -->
    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> <a data-anolis-xref="has an element in button scope" href="#has-an-element-in-button-scope">has a
    <code>p</code> element in button scope</a>, then <a href="#close-a-p-element">close a <code>p</code>
    element</a>.</p>

<!--CLEANUP-->
    <p><a href="#insert-an-html-element">Insert an HTML element</a> for a "form" start tag token with no attributes, and, if there is no <code><a href="scripting-1.html#the-template-element">template</a></code> element on the <a href="#stack-of-open-elements">stack of open elements</a>, set
    the <a href="#form-element-pointer"><code data-anolis-xref="form">form</code> element pointer</a> to point to the element
    created.</p>

    <p>If the token has an attribute called "action", set the <code data-anolis-xref="attr-fs-action"><a href="forms.html#attr-fs-action">action</a></code> attribute on the resulting <code><a href="forms.html#the-form-element">form</a></code> element to the
    value of the "action" attribute of the token.</p>

    <!-- fake <hr> -->
    <p><a href="#insert-an-html-element">Insert an HTML element</a> for an "hr" start tag token with no attributes.
    Immediately pop the <a href="#current-node">current node</a> off the <a href="#stack-of-open-elements">stack of open elements</a>.</p>

    <!-- fake <label> -->
    <p><a href="#reconstruct-the-active-formatting-elements">Reconstruct the active formatting elements</a>, if any.</p>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for a "label" start tag token with no attributes.</p>

    <!-- fake text -->
    <p><a data-anolis-xref="insert a character" href="#insert-a-character">Insert characters</a> (see below for <a data-anolis-xref="attr-isindex-prompt" href="#attr-isindex-prompt">what they should say</a>).</p>

    <!-- fake <input> -->
    <p><a href="#insert-an-html-element">Insert an HTML element</a> for an "input" start tag token with all the attributes
    from the "isindex" token except "name", "action", and "prompt", and with an attribute named
    "name" with the value "isindex". (This creates an <code><a href="forms.html#the-input-element">input</a></code> element with the <code data-anolis-xref="attr-fe-name"><a href="forms.html#attr-fe-name">name</a></code> attribute set to the magic balue "<code data-anolis-xref="attr-fe-name-isindex"><a href="forms.html#attr-fe-name-isindex">isindex</a></code>".) Immediately pop the <a href="#current-node">current node</a> off
    the <a href="#stack-of-open-elements">stack of open elements</a>.</p>

    <!-- fake text -->
    <p><a data-anolis-xref="insert a character" href="#insert-a-character">Insert more characters</a> (see below for <a data-anolis-xref="attr-isindex-prompt" href="#attr-isindex-prompt">what they should say</a>).</p>

    <!-- fake </label> -->
    <p>Pop the <a href="#current-node">current node</a> (which will be the <code><a href="forms.html#the-label-element">label</a></code> element created
    earlier) off the <a href="#stack-of-open-elements">stack of open elements</a>.</p>

    <!-- fake <hr> -->
    <p><a href="#insert-an-html-element">Insert an HTML element</a> for an "hr" start tag token with no attributes.
    Immediately pop the <a href="#current-node">current node</a> off the <a href="#stack-of-open-elements">stack of open elements</a>.</p>

    <!-- fake </form> -->
    <p>Pop the <a href="#current-node">current node</a> (which will be the <code><a href="forms.html#the-form-element">form</a></code> element created
    earlier) off the <a href="#stack-of-open-elements">stack of open elements</a>, and, if there is no <code><a href="scripting-1.html#the-template-element">template</a></code>
    element on the <a href="#stack-of-open-elements">stack of open elements</a>, set the <a href="#form-element-pointer"><code data-anolis-xref="form">form</code> element pointer</a> back to null.</p>

    <!-- explanation of text -->
    <p><dfn data-anolis-xref="attr-isindex-prompt" id="attr-isindex-prompt"><strong>Prompt</strong></dfn>: If the token has an attribute
    with the name "prompt", then the first stream of characters must be the same string as given in
    that attribute, and the second stream of characters must be empty. Otherwise, the two streams of
    character tokens together should, together with the <code><a href="forms.html#the-input-element">input</a></code> element, express the
    equivalent of "This is a searchable index. Enter search keywords: (input field)" in the user's
    preferred language.</p>

   </dd>

   <dt>A start tag whose tag name is "textarea"</dt>
   <dd>

    <p>Run these steps:</p>

    <ol><li><p><a href="#insert-an-html-element">Insert an HTML element</a> for the token.</li>

     <li><p>If the <a href="#next-token">next token</a> is a "LF" (U+000A) character token, then ignore
     that token and move on to the next one. (Newlines at the start of <code><a href="forms.html#the-textarea-element">textarea</a></code>
     elements are ignored as an authoring convenience.)</li>

     <!-- see comment in <pre> start tag bit -->

     <li><p>Switch the tokenizer to the <a href="#rcdata-state">RCDATA state</a>.</li>

     <li><p>Let the <a href="#original-insertion-mode">original insertion mode</a> be the current <a href="#insertion-mode">insertion
     mode</a>.</p>

     </li><li><p>Set the <a href="#frameset-ok-flag">frameset-ok flag</a> to "not ok".</li>

     <li><p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode:
     text" href="#parsing-main-incdata">text</a>".</li>

    </ol></dd>

   <dt>A start tag whose tag name is "xmp"</dt>
   <dd>

    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> <a data-anolis-xref="has an element in button scope" href="#has-an-element-in-button-scope">has a
    <code>p</code> element in button scope</a>, then <a href="#close-a-p-element">close a <code>p</code>
    element</a>.</p>

    <p><a href="#reconstruct-the-active-formatting-elements">Reconstruct the active formatting elements</a>, if any.</p>

    <p>Set the <a href="#frameset-ok-flag">frameset-ok flag</a> to "not ok".</p>

    <p>Follow the <a href="#generic-raw-text-element-parsing-algorithm">generic raw text element parsing algorithm</a>.</p>

   </dd>

   <dt>A start tag whose tag name is "iframe"</dt>
   <dd>

    <p>Set the <a href="#frameset-ok-flag">frameset-ok flag</a> to "not ok".</p>

    <p>Follow the <a href="#generic-raw-text-element-parsing-algorithm">generic raw text element parsing algorithm</a>.</p>

   </dd>

   <dt>A start tag whose tag name is "noembed"</dt>
   <dt>A start tag whose tag name is "noscript", if the <a href="#scripting-flag">scripting flag</a> is enabled</dt>
   <dd>

    <p>Follow the <a href="#generic-raw-text-element-parsing-algorithm">generic raw text element parsing algorithm</a>.</p>

   </dd>

   <dt>A start tag whose tag name is "select"</dt>
   <dd>

    <p><a href="#reconstruct-the-active-formatting-elements">Reconstruct the active formatting elements</a>, if any.</p>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token.</p>

    <p>Set the <a href="#frameset-ok-flag">frameset-ok flag</a> to "not ok".</p>

    <p>If the <a href="#insertion-mode">insertion mode</a> is one of "<a data-anolis-xref="insertion mode: in table" href="#parsing-main-intable">in
    table</a>", "<a data-anolis-xref="insertion mode: in caption" href="#parsing-main-incaption">in caption</a>", "<a data-anolis-xref="insertion mode: in table body" href="#parsing-main-intbody">in table body</a>", "<a data-anolis-xref="insertion mode: in
    row" href="#parsing-main-intr">in row</a>", or "<a data-anolis-xref="insertion mode: in cell" href="#parsing-main-intd">in cell</a>", then switch the
    <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in select in table" href="#parsing-main-inselectintable">in select in
    table</a>". Otherwise, switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion
    mode: in select" href="#parsing-main-inselect">in select</a>".</p>

   </dd>

   <dt>A start tag whose tag name is one of: "optgroup", "option"</dt>
   <dd>

    <p>If the <a href="#current-node">current node</a> is an <code><a href="forms.html#the-option-element">option</a></code> element, then pop the
    <a href="#current-node">current node</a> off the <a href="#stack-of-open-elements">stack of open elements</a>.</p>

    <p><a href="#reconstruct-the-active-formatting-elements">Reconstruct the active formatting elements</a>, if any.</p>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token.</p>

   </dd>

   <!-- FORK -->
   <dt>A start tag whose tag name is one of: "rb", "rp", "rtc"</dt>
   <dd>
    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> <a data-anolis-xref="has an element in scope" href="#has-an-element-in-scope">has a
    <code>ruby</code> element in scope</a>, then <a href="#generate-implied-end-tags">generate implied end tags</a>. If the
    <a href="#current-node">current node</a> is not then a <code><a href="text-level-semantics.html#the-ruby-element">ruby</a></code> element, this is a <a href="#parse-error">parse
    error</a>.</p>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token.</p>

   </dd>

   <dt>A start tag whose tag name is "rt"</dt>
   <dd>
    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> <a data-anolis-xref="has an element in scope" href="#has-an-element-in-scope">has a
    <code>ruby</code> element in scope</a>, then <a href="#generate-implied-end-tags">generate implied end tags</a>, except 
    for <code><a href="text-level-semantics.html#the-rtc-element">rtc</a></code> elements. If the <a href="#current-node">current node</a> is not then a <code><a href="text-level-semantics.html#the-ruby-element">ruby</a></code>
    element or an <code><a href="text-level-semantics.html#the-rtc-element">rtc</a></code> element, this is a <a href="#parse-error">parse error</a>.</p>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token.</p>
   </dd>
   <!-- /FORK -->

   <dt>A start tag whose tag name is "math"</dt>
   <dd>

    <p><a href="#reconstruct-the-active-formatting-elements">Reconstruct the active formatting elements</a>, if any.</p>

    <p><a href="#adjust-mathml-attributes">Adjust MathML attributes</a> for the token. (This fixes the case of MathML
    attributes that are not all lowercase.)</p>

    <p><a href="#adjust-foreign-attributes">Adjust foreign attributes</a> for the token. (This fixes the use of namespaced
    attributes, in particular XLink.)</p>

    <p><a href="#insert-a-foreign-element">Insert a foreign element</a> for the token, in the <a href="infrastructure.html#mathml-namespace">MathML
    namespace</a>.</p>

    <!-- If we ever change the frameset-ok flag to an insertion mode, the following change would be
    implied, except we'd have to do it even in the face of a self-closed tag:
    <p>Set the <span>frameset-ok flag</span> to "not ok".</p>
    -->

    <p>If the token has its <i>self-closing flag</i> set, pop the <a href="#current-node">current node</a> off the
    <a href="#stack-of-open-elements">stack of open elements</a> and <a data-anolis-xref="acknowledge self-closing flag" href="#acknowledge-self-closing-flag">acknowledge
    the token's <i>self-closing flag</i></a>.</p>

   </dd>

   <dt>A start tag whose tag name is "svg"</dt>
   <dd>

    <p><a href="#reconstruct-the-active-formatting-elements">Reconstruct the active formatting elements</a>, if any.</p>

    <p><a href="#adjust-svg-attributes">Adjust SVG attributes</a> for the token. (This fixes the case of SVG attributes that
    are not all lowercase.)</p>

    <p><a href="#adjust-foreign-attributes">Adjust foreign attributes</a> for the token. (This fixes the use of namespaced
    attributes, in particular XLink in SVG.)</p>

    <p><a href="#insert-a-foreign-element">Insert a foreign element</a> for the token, in the <a href="infrastructure.html#svg-namespace">SVG namespace</a>.</p>

    <!-- If we ever change the frameset-ok flag to an insertion mode, the following change would be
    implied, except we'd have to do it even in the face of a self-closed tag:
    <p>Set the <span>frameset-ok flag</span> to "not ok".</p>
    -->

    <p>If the token has its <i>self-closing flag</i> set, pop the <a href="#current-node">current node</a> off the
    <a href="#stack-of-open-elements">stack of open elements</a> and <a data-anolis-xref="acknowledge self-closing flag" href="#acknowledge-self-closing-flag">acknowledge
    the token's <i>self-closing flag</i></a>.</p>

   </dd>

   <dt>A start <!--or end--> tag whose tag name is one of: "caption", "col", "colgroup", "frame",
   "head", "tbody", "td", "tfoot", "th", "thead", "tr"</dt>
   <!--<dt>An end tag whose tag name is one of: "area", "base", "basefont", "bgsound", "embed",
   "hr", "iframe", "image", "img", "input", "isindex", "keygen", "link", "meta",
   "noembed", "noframes", "param", "script", "select", "source", "style", "table", "textarea",
   "title", "track", "wbr"</dt>-->
   <!--<dt>An end tag whose tag name is "noscript", if the <span>scripting flag</span> is
   enabled</dt>-->
   <dd>

    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>

    <!-- end tags are commented out because since they can never end up on the stack anyway, the
    default end tag clause will automatically handle them. we don't want to have text in the spec
    that is just an optimisation, as that detracts from the spec itself -->

   </dd>

   <dt>Any other start tag</dt>
   <dd>

    <p><a href="#reconstruct-the-active-formatting-elements">Reconstruct the active formatting elements</a>, if any.</p>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token.</p>

    <p class="note">This element will be an <a href="#ordinary">ordinary</a>
    element.</p>

   </dd>

   <dt>Any other end tag</dt>
   <dd>

    <p>Run these steps:</p>

    <ol><li><p>Initialize <var data-anolis-xref="">node</var> to be the <a href="#current-node">current node</a> (the bottommost
     node of the stack).</li>

     <li><p><i>Loop</i>: If <var data-anolis-xref="">node</var> is an <a data-anolis-xref="HTML elements" href="infrastructure.html#html-elements">HTML
     element</a> with the same tag name as the token, then:</p>

      <ol><li><p><a href="#generate-implied-end-tags">Generate implied end tags</a>, except for <a href="infrastructure.html#html-elements">HTML elements</a> with the
       same tag name as the token.</li>

       <li><p>If <var data-anolis-xref="">node</var> is not the <a href="#current-node">current node</a>, then this is a
       <a href="#parse-error">parse error</a>.</li>

       <li><p>Pop all the nodes from the <a href="#current-node">current node</a> up to <var data-anolis-xref="">node</var>,
       including <var data-anolis-xref="">node</var>, then stop these steps.</li>

      </ol></li>

     <li><p>Otherwise, if <var data-anolis-xref="">node</var> is in the <a href="#special">special</a> category, then
     this is a <a href="#parse-error">parse error</a>; ignore the token, and abort these steps.</li>

     <li><p>Set <var data-anolis-xref="">node</var> to the previous entry in the <a href="#stack-of-open-elements">stack of open
     elements</a>.</li>

     <li><p>Return to the step labeled <i>loop</i>.</li>

    </ol></dd>

  </dl><p>When the steps above say the user agent is to <dfn id="close-a-p-element">close a <code>p</code> element</dfn>, it
  means that the user agent must run the following steps:</p>

  <ol><!-- prereq: p in scope --><li><p><a href="#generate-implied-end-tags">Generate implied end tags</a>, except for <code><a href="grouping-content.html#the-p-element">p</a></code> elements.</li>

   <li><p>If the <a href="#current-node">current node</a> is not a <code><a href="grouping-content.html#the-p-element">p</a></code> element, then this is a
   <a href="#parse-error">parse error</a>.</li>

   <li><p>Pop elements from the <a href="#stack-of-open-elements">stack of open elements</a> until a <code><a href="grouping-content.html#the-p-element">p</a></code> element
   has been popped from the stack.</li>

  </ol><!-- AAA --><p id="adoptionAgency">The <dfn id="adoption-agency-algorithm">adoption agency algorithm</dfn>, which takes as its only argument
  a tag name <var data-anolis-xref="">subject</var> for which the algorithm is being run, consists of the
  following steps:</p>

  <ol><!-- don't forget about the noah's ark clause when looking at this algorithm! --><li>

    <p>If the <a href="#current-node">current node</a> is an <a data-anolis-xref="HTML elements" href="infrastructure.html#html-elements">HTML element</a> whose
    tag name is <var data-anolis-xref="">subject</var>, then run these substeps:

    <ol><li><p>Let <var data-anolis-xref="">element</var> be the <a href="#current-node">current node</a>.</li>

     <li><p>Pop <var data-anolis-xref="">element</var> off the <a href="#stack-of-open-elements">stack of open elements</a>.</li>

     <li><p>If <var data-anolis-xref="">element</var> is also in the <a href="#list-of-active-formatting-elements">list of active formatting
     elements</a>, remove the element from the list.</li>

     <li><p>Abort the <a href="#adoption-agency-algorithm">adoption agency algorithm</a>.</li>

    </ol></li>

   <li><p>Let <var data-anolis-xref="">outer loop counter</var> be zero.</li>

   <li><p><i>Outer loop</i>: If <var data-anolis-xref="">outer loop counter</var> is greater than or equal to
   eight, then abort these steps.</li>

   <li><p>Increment <var data-anolis-xref="">outer loop counter</var> by one.</li>

   <li>

    <p>Let <var data-anolis-xref="">formatting element</var> be the last element in the <a href="#list-of-active-formatting-elements">list of active
    formatting elements</a> that:</p>

    <ul><li>is between the end of the list and the last scope marker in the list, if any, or the start
     of the list otherwise, and</li>

     <li>has the tag name <var data-anolis-xref="">subject</var>.</li>

    </ul><p>If there is no such element, then abort these steps and instead act as described in the "any
    other end tag" entry above.</p>

   </li>

   <li><p>If <var data-anolis-xref="">formatting element</var> is not in the <a href="#stack-of-open-elements">stack of open
   elements</a>, then this is a <a href="#parse-error">parse error</a>; remove the element from the list, and
   abort these steps.</li>

   <li><p>If <var data-anolis-xref="">formatting element</var> is in the <a href="#stack-of-open-elements">stack of open elements</a>,
   but the element is not <a data-anolis-xref="has an element in scope" href="#has-an-element-in-scope">in scope</a>, then this is a
   <a href="#parse-error">parse error</a>; abort these steps.</li>

   <!-- at this point, <var data-x="">formatting element</var> is in <span data-x="stack of open
        elements">the stack</span> and <span data-x="list of active formatting elements">the
        list</span>, and is <span data-x="has an element in scope">in scope</span>. -->

   <li><p>If <var data-anolis-xref="">formatting element</var> is not the <a href="#current-node">current node</a>, this is a
   <a href="#parse-error">parse error</a>. (But do not abort these steps.)</li>

   <li><p>Let <var data-anolis-xref="">furthest block</var> be the topmost node in the <a href="#stack-of-open-elements">stack of open
   elements</a> that is lower in the stack than <var data-anolis-xref="">formatting element</var>, and is an
   element in the <a href="#special">special</a> category. There might not be one.</li>

   <!-- <html> ... <formatting element> ... <furthest block> ... <current node> -->

   <li><p>If there is no <var data-anolis-xref="">furthest block</var>, then the UA must first pop all the
   nodes from the bottom of the <a href="#stack-of-open-elements">stack of open elements</a>, from the <a href="#current-node">current
   node</a> up to and including <var data-anolis-xref="">formatting element</var>, then remove <var data-anolis-xref="">formatting element</var> from the <a href="#list-of-active-formatting-elements">list of active formatting elements</a>, and
   finally abort these steps.</li> <!-- the "reconstruct the active formatting elements"
   algorithm will rebuild them later -->

   <li><p>Let <var data-anolis-xref="">common ancestor</var> be the element immediately above <var data-anolis-xref="">formatting element</var> in the <a href="#stack-of-open-elements">stack of open elements</a>.</li>

   <!-- <html> ... <common ancestor> <formatting element> ... <furthest block> ... <current node> -->

   <li><p>Let a bookmark note the position of <var data-anolis-xref="">formatting element</var> in the
   <a href="#list-of-active-formatting-elements">list of active formatting elements</a> relative to the elements on either side of it in
   the list.</li>

   <li>

    <p>Let <var data-anolis-xref="">node</var> and <var data-anolis-xref="">last node</var> be <var data-anolis-xref="">furthest
    block</var>. Follow these steps:</p>

    <ol><li><p>Let <var data-anolis-xref="">inner loop counter</var> be zero.</li>

     <li><p><i>Inner loop</i>: Increment <var data-anolis-xref="">inner loop counter</var> by one.</li>

     <li><p>Let <var data-anolis-xref="">node</var> be the element immediately above <var data-anolis-xref="">node</var>
     in the <a href="#stack-of-open-elements">stack of open elements</a>, or if <var data-anolis-xref="">node</var> is no longer in the
     <a href="#stack-of-open-elements">stack of open elements</a> (e.g. because it got removed by this algorithm<!-- in
     particular, the step labeled "removal" below -->), the element that was immediately above <var data-anolis-xref="">node</var> in the <a href="#stack-of-open-elements">stack of open elements</a> before <var data-anolis-xref="">node</var>
     was removed.</li>

     <li><p>If <var data-anolis-xref="">node</var> is <var data-anolis-xref="">formatting element</var>, then go to the
     next step in the overall algorithm.</li>

     <li><p>If <var data-anolis-xref="">inner loop counter</var> is greater than three and <var data-anolis-xref="">node</var> is in the <a href="#list-of-active-formatting-elements">list of active formatting elements</a>, then remove <var data-anolis-xref="">node</var> from the <a href="#list-of-active-formatting-elements">list of active formatting elements</a>.</li>

     <li><p><!-- "removal" step: -->If <var data-anolis-xref="">node</var> is not in the <a href="#list-of-active-formatting-elements">list of active
     formatting elements</a>, then remove <var data-anolis-xref="">node</var> from the <a href="#stack-of-open-elements">stack of open
     elements</a> and then go back to the step labeled <i>inner loop</i>.</li>

     <li><p><a href="#create-an-element-for-the-token">Create an element for the token</a> for which the element <var data-anolis-xref="">node</var> was created, in the <a href="infrastructure.html#html-namespace-0">HTML namespace</a>, with <var data-anolis-xref="">common
     ancestor</var> as the intended parent; replace the entry for <var data-anolis-xref="">node</var> in the
     <a href="#list-of-active-formatting-elements">list of active formatting elements</a> with an entry for the new element, replace the
     entry for <var data-anolis-xref="">node</var> in the <a href="#stack-of-open-elements">stack of open elements</a> with an entry for
     the new element, and let <var data-anolis-xref="">node</var> be the new element.</li>

     <li><p>If <var data-anolis-xref="">last node</var> is <var data-anolis-xref="">furthest block</var>, then move the
     aforementioned bookmark to be immediately after the new <var data-anolis-xref="">node</var> in the
     <a href="#list-of-active-formatting-elements">list of active formatting elements</a>.</li>

     <li><p>Insert <var data-anolis-xref="">last node</var> into <var data-anolis-xref="">node</var>, first removing it
     from its previous parent node if any.</li>

     <li><p>Let <var data-anolis-xref="">last node</var> be <var data-anolis-xref="">node</var>.</li>

     <li><p>Return to the step labeled <i>inner loop</i>.</li>

    </ol></li>

   <li><p>Insert whatever <var data-anolis-xref="">last node</var> ended up being in the previous step at the
   <a href="#appropriate-place-for-inserting-a-node">appropriate place for inserting a node</a>, but using <var data-anolis-xref="">common
   ancestor</var> as the <i>override target</i>.</li>

   <li><p><a href="#create-an-element-for-the-token">Create an element for the token</a> for which <var data-anolis-xref="">formatting
   element</var> was created, in the <a href="infrastructure.html#html-namespace-0">HTML namespace</a>, with <var data-anolis-xref="">furthest
   block</var> as the intended parent.</li>

   <li><p>Take all of the child nodes of <var data-anolis-xref="">furthest block</var> and append them to the
   element created in the last step.</li>

   <li><p>Append that new element to <var data-anolis-xref="">furthest block</var>.</li>

   <li><p>Remove <var data-anolis-xref="">formatting element</var> from the <a href="#list-of-active-formatting-elements">list of active formatting
   elements</a>, and insert the new element into the <a href="#list-of-active-formatting-elements">list of active formatting
   elements</a> at the position of the aforementioned bookmark.</li>

   <li><p>Remove <var data-anolis-xref="">formatting element</var> from the <a href="#stack-of-open-elements">stack of open
   elements</a>, and insert the new element into the <a href="#stack-of-open-elements">stack of open elements</a>
   immediately below the position of <var data-anolis-xref="">furthest block</var> in that stack.</li>

   <li><p>Jump back to the step labeled <i>outer loop</i>.</li>

  </ol><p class="note">This algorithm's name, the "adoption agency algorithm", comes from the way it
  causes elements to change parents, and is in contrast with other possible algorithms for dealing
  with misnested content, which included the "incest algorithm", the "secret affair algorithm", and
  the "Heisenberg algorithm".</p>





  <h6 id="parsing-main-incdata"><span class="secno">8.2.5.4.8 </span>The "<dfn data-anolis-xref="insertion mode: text" id="insertion-mode:-text">text</dfn>" insertion mode</h6>


  <p>When the user agent is to apply the rules for the "<a data-anolis-xref="insertion mode:
  text" href="#parsing-main-incdata">text</a>" <a href="#insertion-mode">insertion mode</a>, the user agent must handle the token as
  follows:</p>

  <dl class="switch"><dt>A character token</dt>
   <dd>

    <p><a data-anolis-xref="insert a character" href="#insert-a-character">Insert the token's character</a>.</p>

    <p class="note">This can never be a U+0000 NULL character; the tokenizer converts those to
    U+FFFD REPLACEMENT CHARACTER characters.</p>

   </dd>

   <dt>An end-of-file token</dt>
   <dd>

    <!-- can't be the fragment case -->
    <p><a href="#parse-error">Parse error</a>.</p>

    <p>If the <a href="#current-node">current node</a> is a <code><a href="scripting-1.html#the-script-element">script</a></code> element, mark the
    <code><a href="scripting-1.html#the-script-element">script</a></code> element as <a href="scripting-1.html#already-started">"already started"</a>.</p>

    <p>Pop the <a href="#current-node">current node</a> off the <a href="#stack-of-open-elements">stack of open elements</a>.</p>

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to the <a href="#original-insertion-mode">original insertion mode</a> and
    reprocess the token.</p>

   </dd>

   <dt id="scriptEndTag">An end tag whose tag name is "script"</dt>
   <dd>

    <p><a href="webappapis.html#perform-a-microtask-checkpoint">Perform a microtask checkpoint</a>.</p>

    <p><a href="webappapis.html#provide-a-stable-state">Provide a stable state</a>.</p>

    <p>Let <var data-anolis-xref="">script</var> be the <a href="#current-node">current node</a> (which will be a
    <code><a href="scripting-1.html#the-script-element">script</a></code> element).</p>

    <p>Pop the <a href="#current-node">current node</a> off the <a href="#stack-of-open-elements">stack of open elements</a>.</p>

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to the <a href="#original-insertion-mode">original insertion mode</a>.</p>

    <p>Let the <var data-anolis-xref="">old insertion point</var> have the same value as the current
    <a href="#insertion-point">insertion point</a>. Let the <a href="#insertion-point">insertion point</a> be just before the <a href="#next-input-character">next
    input character</a>.</p>

    <p>Increment the parser's <a href="#script-nesting-level">script nesting level</a> by one.</p>

    <p><a data-anolis-xref="prepare a script" href="scripting-1.html#prepare-a-script">Prepare</a> the <var data-anolis-xref="">script</var>. This might
    cause some script to execute, which might cause <a data-anolis-xref="dom-document-write" href="webappapis.html#dom-document-write">new characters
    to be inserted into the tokenizer</a>, and might cause the tokenizer to output more tokens,
    resulting in a <a href="#nestedParsing">reentrant invocation of the parser</a>.</p>

    <p>Decrement the parser's <a href="#script-nesting-level">script nesting level</a> by one. If the parser's <a href="#script-nesting-level">script
    nesting level</a> is zero, then set the <a href="#parser-pause-flag">parser pause flag</a> to false.</p>

    <p>Let the <a href="#insertion-point">insertion point</a> have the value of the <var data-anolis-xref="">old insertion
    point</var>. (In other words, restore the <a href="#insertion-point">insertion point</a> to its previous value.
    This value might be the "undefined" value.)</p>

    <p id="scriptTagParserResumes">At this stage, if there is a <a href="scripting-1.html#pending-parsing-blocking-script">pending parsing-blocking
    script</a>, then:</p>

    <dl class="switch"><dt>If the <a href="#script-nesting-level">script nesting level</a> is not zero:</dt>

     <dd>

      <p>Set the <a href="#parser-pause-flag">parser pause flag</a> to true, and abort the processing of any nested
      invocations of the tokenizer, yielding control back to the caller. (Tokenization will resume
      when the caller returns to the "outer" tree construction stage.)</p>

      <p class="note">The tree construction stage of this particular parser is <a href="#nestedParsing">being called reentrantly</a>, say from a call to <code data-anolis-xref="dom-document-write"><a href="webappapis.html#dom-document-write">document.write()</a></code>.</p>

     </dd>


     <dt>Otherwise:</dt>

     <dd>

      <p>Run these steps:</p>

      <ol><li><p>Let <var data-anolis-xref="">the script</var> be the <a href="scripting-1.html#pending-parsing-blocking-script">pending parsing-blocking
       script</a>. There is no longer a <a href="scripting-1.html#pending-parsing-blocking-script">pending parsing-blocking script</a>.</li>

       <li><p>Block the <a data-anolis-xref="tokenization" href="#tokenization">tokenizer</a> for this instance of the
       <a href="#html-parser">HTML parser</a>, such that the <a href="webappapis.html#event-loop">event loop</a> will not run <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">tasks</a> that invoke the <a data-anolis-xref="tokenization" href="#tokenization">tokenizer</a>.</li>

       <li><p>If the parser's <code><a href="dom.html#document">Document</a></code> <a href="document-metadata.html#has-a-style-sheet-that-is-blocking-scripts">has a style sheet that is blocking
       scripts</a> or <var data-anolis-xref="">the script</var>'s <a href="scripting-1.html#ready-to-be-parser-executed">"ready to be parser-executed"</a>
       flag is not set: <a href="webappapis.html#spin-the-event-loop">spin the event loop</a> until the parser's <code><a href="dom.html#document">Document</a></code>
       <a href="document-metadata.html#has-no-style-sheet-that-is-blocking-scripts">has no style sheet that is blocking scripts</a> and <var data-anolis-xref="">the script</var>'s
       <a href="scripting-1.html#ready-to-be-parser-executed">"ready to be parser-executed"</a> flag is set.</li>

       <li>

        <p>If this <a data-anolis-xref="abort a parser" href="#abort-a-parser">parser has been aborted</a> in the meantime,
        abort these steps.</p>

        <p class="note">This could happen if, e.g., while the <a href="webappapis.html#spin-the-event-loop">spin the event loop</a>
        algorithm is running, the <a href="browsers.html#browsing-context">browsing context</a> gets closed, or the <code data-anolis-xref="dom-document-open"><a href="webappapis.html#dom-document-open">document.open()</a></code> method gets invoked on the
        <code><a href="dom.html#document">Document</a></code>.</p>

       </li>

       <li><p>Unblock the <a data-anolis-xref="tokenization" href="#tokenization">tokenizer</a> for this instance of the
       <a href="#html-parser">HTML parser</a>, such that <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">tasks</a> that invoke the
       <a data-anolis-xref="tokenization" href="#tokenization">tokenizer</a> can again be run.</li>

       <li><p>Let the <a href="#insertion-point">insertion point</a> be just before the <a href="#next-input-character">next input
       character</a>.</li>

       <li><p>Increment the parser's <a href="#script-nesting-level">script nesting level</a> by one (it should be zero
       before this step, so this sets it to one).</li>

       <li><p><a data-anolis-xref="execute the script block" href="scripting-1.html#execute-the-script-block">Execute</a> <var data-anolis-xref="">the
       script</var>.</li>

       <li><p>Decrement the parser's <a href="#script-nesting-level">script nesting level</a> by one. If the parser's
       <a href="#script-nesting-level">script nesting level</a> is zero (which it always should be at this point), then set
       the <a href="#parser-pause-flag">parser pause flag</a> to false.</p>

       </li><li><p>Let the <a href="#insertion-point">insertion point</a> be undefined again.</li>

       <li><p>If there is once again a <a href="scripting-1.html#pending-parsing-blocking-script">pending parsing-blocking script</a>, then repeat
       these steps from step 1.</li>

      </ol></dd>

    </dl></dd>

   <dt>Any other end tag</dt>
   <dd>

    <p>Pop the <a href="#current-node">current node</a> off the <a href="#stack-of-open-elements">stack of open elements</a>.</p>

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to the <a href="#original-insertion-mode">original insertion mode</a>.</p>

   </dd>

  </dl><h6 id="parsing-main-intable"><span class="secno">8.2.5.4.9 </span>The "<dfn data-anolis-xref="insertion mode: in table" id="insertion-mode:-in-table">in table</dfn>" insertion mode</h6>

  <p>When the user agent is to apply the rules for the "<a data-anolis-xref="insertion mode: in table" href="#parsing-main-intable">in
  table</a>" <a href="#insertion-mode">insertion mode</a>, the user agent must handle the token as follows:</p>

  <dl class="switch"><dt>A character token, if the <a href="#current-node">current node</a> is <code><a href="tabular-data.html#the-table-element">table</a></code>, <code><a href="tabular-data.html#the-tbody-element">tbody</a></code>, <code><a href="tabular-data.html#the-tfoot-element">tfoot</a></code>, <code><a href="tabular-data.html#the-thead-element">thead</a></code>, or <code><a href="tabular-data.html#the-tr-element">tr</a></code> element</dt>
   <dd>

     <p>Let the <dfn id="pending-table-character-tokens"><var>pending table character tokens</var></dfn> be an empty list of tokens.</p>

     <p>Let the <a href="#original-insertion-mode">original insertion mode</a> be the current <a href="#insertion-mode">insertion mode</a>.</p>

     <p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in table text" href="#parsing-main-intabletext">in
     table text</a>" and reprocess the token.</p>

   </dd>

   <dt>A comment token</dt>
   <dd>
    <p><a href="#insert-a-comment">Insert a comment</a>.</p>
   </dd>

   <dt>A DOCTYPE token</dt>
   <dd>
    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>
   </dd>

   <dt>A start tag whose tag name is "caption"</dt>
   <dd>

    <p><a href="#clear-the-stack-back-to-a-table-context">Clear the stack back to a table context</a>. (See below.)</p>

    <p>Insert a marker at the end of the <a href="#list-of-active-formatting-elements">list of active formatting elements</a>.</p>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token, then switch the <a href="#insertion-mode">insertion
    mode</a> to "<a data-anolis-xref="insertion mode: in caption" href="#parsing-main-incaption">in caption</a>".</p>

   </dd>

   <dt>A start tag whose tag name is "colgroup"</dt>
   <dd>

    <p><a href="#clear-the-stack-back-to-a-table-context">Clear the stack back to a table context</a>. (See below.)</p>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token, then switch the <a href="#insertion-mode">insertion
    mode</a> to "<a data-anolis-xref="insertion mode: in column group" href="#parsing-main-incolgroup">in column group</a>".</p>

   </dd>

   <dt>A start tag whose tag name is "col"</dt>
   <dd>

    <!-- fake <colgroup> -->
    <p><a href="#clear-the-stack-back-to-a-table-context">Clear the stack back to a table context</a>. (See below.)</p>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for a "colgroup" start tag token with no attributes, then
    switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in column group" href="#parsing-main-incolgroup">in
    column group</a>".</p>
    <!-- end of fake <colgroup> -->

    <p>Reprocess the current token.</p>

   </dd>

   <dt>A start tag whose tag name is one of: "tbody", "tfoot", "thead"</dt>
   <dd>

    <p><a href="#clear-the-stack-back-to-a-table-context">Clear the stack back to a table context</a>. (See below.)</p>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token, then switch the <a href="#insertion-mode">insertion
    mode</a> to "<a data-anolis-xref="insertion mode: in table body" href="#parsing-main-intbody">in table body</a>".</p>

   </dd>

   <dt>A start tag whose tag name is one of: "td", "th", "tr"</dt>
   <dd>

    <!-- fake <colgroup> -->
    <p><a href="#clear-the-stack-back-to-a-table-context">Clear the stack back to a table context</a>. (See below.)</p>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for a "tbody" start tag token with no attributes, then
    switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in table body" href="#parsing-main-intbody">in table
    body</a>".</p>
    <!-- end of fake <colgroup> -->

    <p>Reprocess the current token.</p>

   </dd>

   <dt>A start tag whose tag name is "table"</dt>
   <dd>

    <p><a href="#parse-error">Parse error</a>.</p>

    <!-- fake </table> -->
    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> does not <a data-anolis-xref="has an element in table
    scope" href="#has-an-element-in-table-scope">have a <code>table</code> element in table scope</a>, ignore the token.</p>

    <p>Otherwise:</p>

    <p>Pop elements from this stack until a <code><a href="tabular-data.html#the-table-element">table</a></code> element has been popped from the
    stack.</p>

    <p><a href="#reset-the-insertion-mode-appropriately">Reset the insertion mode appropriately</a>.</p>
    <!-- end of fake </table> -->

    <p>Reprocess the token.</p>

   </dd>

   <dt>An end tag whose tag name is "table"</dt>
   <dd>

    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> does not <a data-anolis-xref="has an element in table
    scope" href="#has-an-element-in-table-scope">have a <code>table</code> element in table scope</a>, this is a <a href="#parse-error">parse
    error</a>; ignore the token.</p>

    <p>Otherwise:</p>

    <p>Pop elements from this stack until a <code><a href="tabular-data.html#the-table-element">table</a></code> element has been popped from the
    stack.</p>

    <p><a href="#reset-the-insertion-mode-appropriately">Reset the insertion mode appropriately</a>.</p>

   </dd>

   <dt>An end tag whose tag name is one of: "body", "caption", "col", "colgroup", "html", "tbody",
   "td", "tfoot", "th", "thead", "tr"</dt>
   <dd>
    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>
   </dd>

   <dt>A start tag whose tag name is one of: "style", "script", "template"</dt>
   <dt>An end tag whose tag name is "template"</dt>
   <dd>

    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in head" href="#parsing-main-inhead">in head</a>" <a href="#insertion-mode">insertion
    mode</a>.</p>

   </dd>

   <dt>A start tag whose tag name is "input"</dt>
   <dd>

    <p>If the token does not have an attribute with the name "type", or if it does, but that
    attribute's value is not an <a href="infrastructure.html#ascii-case-insensitive">ASCII case-insensitive</a> match for the string "<code data-anolis-xref="">hidden</code>", then: act as described in the "anything else" entry below.</p>

    <p>Otherwise:</p>

    <p><a href="#parse-error">Parse error</a>.</p>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token.</p>

    <p>Pop that <code><a href="forms.html#the-input-element">input</a></code> element off the <a href="#stack-of-open-elements">stack of open elements</a>.</p>

    <p><a data-anolis-xref="acknowledge self-closing flag" href="#acknowledge-self-closing-flag">Acknowledge the token's <i>self-closing
    flag</i></a>, if it is set.</p>

   </dd>

   <dt>A start tag whose tag name is "form"</dt>
   <dd>

    <p><a href="#parse-error">Parse error</a>.</p>

    <p>If there is a <code><a href="scripting-1.html#the-template-element">template</a></code> element on the <a href="#stack-of-open-elements">stack of open elements</a>, or if
    the <a href="#form-element-pointer"><code data-anolis-xref="form">form</code> element pointer</a> is not null, ignore the
    token.</p> <!-- in a <template>, the <form> would have no effect and thus be a waste of time... -->

    <p>Otherwise:</p>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token, and set the <a href="#form-element-pointer"><code data-anolis-xref="form">form</code> element pointer</a> to point to the element created.</p>

    <p>Pop that <code><a href="forms.html#the-form-element">form</a></code> element off the <a href="#stack-of-open-elements">stack of open elements</a>.</p>

   </dd>

   <!-- "form" end tag falls through to in-body, which does the right thing -->

   <dt>An end-of-file token</dt>
   <dd>

    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    body" href="#parsing-main-inbody">in body</a>" <a href="#insertion-mode">insertion mode</a>.</p>

   </dd>

   <dt>Anything else</dt>
   <dd>

    <p><a href="#parse-error">Parse error</a>. Enable <a data-anolis-xref="foster parent" href="#foster-parent">foster parenting</a>, process
    the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in body" href="#parsing-main-inbody">in
    body</a>" <a href="#insertion-mode">insertion mode</a>, and then disable <a data-anolis-xref="foster parent" href="#foster-parent">foster
    parenting</a>.</p>

   </dd>

  </dl><p>When the steps above require the UA to <dfn id="clear-the-stack-back-to-a-table-context">clear the stack back to a table context</dfn>, it
  means that the UA must, while the <a href="#current-node">current node</a> is not a <code><a href="tabular-data.html#the-table-element">table</a></code>,
  <code><a href="scripting-1.html#the-template-element">template</a></code>, or <code><a href="semantics.html#the-html-element">html</a></code> element, pop elements from the <a href="#stack-of-open-elements">stack of open
  elements</a>.</p>

  <p class="note">The <a href="#current-node">current node</a> being an <code><a href="semantics.html#the-html-element">html</a></code> element after this
  process is a <a href="#fragment-case">fragment case</a>.</p>



  <h6 id="parsing-main-intabletext"><span class="secno">8.2.5.4.10 </span>The "<dfn data-anolis-xref="insertion mode: in table text" id="insertion-mode:-in-table-text">in table text</dfn>" insertion mode</h6>

  <p>When the user agent is to apply the rules for the "<a data-anolis-xref="insertion mode: in table
  text" href="#parsing-main-intabletext">in table text</a>" <a href="#insertion-mode">insertion mode</a>, the user agent must handle the token as
  follows:</p>

  <dl class="switch"><dt>A character token that is U+0000 NULL</dt>
   <dd>

    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>

   </dd>


   <dt>Any other character token</dt>
   <dd>

    <p>Append the character token to the <var><a href="#pending-table-character-tokens">pending table character tokens</a></var> list.</p>

   </dd>


   <dt>Anything else</dt>
   <dd>

    <!-- this can only be called if the current node is one of the table model elements -->

    <p>If any of the tokens in the <var><a href="#pending-table-character-tokens">pending table character tokens</a></var> list are character
    tokens that are not <a data-anolis-xref="space character" href="infrastructure.html#space-character">space characters</a>, then reprocess the
    character tokens in the <var><a href="#pending-table-character-tokens">pending table character tokens</a></var> list using the rules given in
    the "anything else" entry in the "<a data-anolis-xref="insertion mode: in table" href="#parsing-main-intable">in table</a>"
    insertion mode.</p>

    <!-- if there's active formatting elements, it'll recreate those and foster parent the top one
    and then put the text nodes in the formatting elements; otherwise, it'll foster parent the
    character tokens. -->

    <p>Otherwise, <a data-anolis-xref="insert a character" href="#insert-a-character">insert the characters</a> given by the
    <var><a href="#pending-table-character-tokens">pending table character tokens</a></var> list.</p> <!-- i.e. inter-element whitespace in the
    table model isn't foster parented -->

    <!-- no need to empty the list, we're leaving the insertion mode and the list is always emptied
    before we reenter the mode -->

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to the <a href="#original-insertion-mode">original insertion mode</a> and
    reprocess the token.</p>

   </dd>

  </dl><h6 id="parsing-main-incaption"><span class="secno">8.2.5.4.11 </span>The "<dfn data-anolis-xref="insertion mode: in caption" id="insertion-mode:-in-caption">in caption</dfn>" insertion mode</h6>

  <p>When the user agent is to apply the rules for the "<a data-anolis-xref="insertion mode: in caption" href="#parsing-main-incaption">in
  caption</a>" <a href="#insertion-mode">insertion mode</a>, the user agent must handle the token as follows:</p>

  <dl class="switch"><dt>An end tag whose tag name is "caption"</dt>
   <dd>

    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> does not <a data-anolis-xref="has an element in table
    scope" href="#has-an-element-in-table-scope">have a <code>caption</code> element in table scope</a>, this is a <a href="#parse-error">parse
    error</a>; ignore the token. (<a href="#fragment-case">fragment case</a>)</p>

    <p>Otherwise:</p>

    <p><a href="#generate-implied-end-tags">Generate implied end tags</a>.</p>

    <p>Now, if the <a href="#current-node">current node</a> is not a <code><a href="tabular-data.html#the-caption-element">caption</a></code> element, then this is a
    <a href="#parse-error">parse error</a>.</p>

    <p>Pop elements from this stack until a <code><a href="tabular-data.html#the-caption-element">caption</a></code> element has been popped from the
    stack.</p>

    <p><a href="#clear-the-list-of-active-formatting-elements-up-to-the-last-marker">Clear the list of active formatting elements up to the last marker</a>.</p>

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in table" href="#parsing-main-intable">in
    table</a>".</p>

   </dd>

   <dt>A start tag whose tag name is one of: "caption", "col", "colgroup", "tbody", "td", "tfoot",
   "th", "thead", "tr"</dt> <dt>An end tag whose tag name is "table"</dt>
   <dd>

    <p><a href="#parse-error">Parse error</a>.</p>

    <!-- fake </caption> -->
    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> does not <a data-anolis-xref="has an element in table
    scope" href="#has-an-element-in-table-scope">have a <code>caption</code> element in table scope</a>, ignore the token.
    (<a href="#fragment-case">fragment case</a>)</p>

    <p>Otherwise:</p>

    <p>Pop elements from this stack until a <code><a href="tabular-data.html#the-caption-element">caption</a></code> element has been popped from the
    stack.</p>

    <p><a href="#clear-the-list-of-active-formatting-elements-up-to-the-last-marker">Clear the list of active formatting elements up to the last marker</a>.</p>

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in table" href="#parsing-main-intable">in
    table</a>".</p>
    <!-- end of fake </caption> -->

    <p>Reprocess the token.</p>

   </dd>

   <dt>An end tag whose tag name is one of: "body", "col", "colgroup", "html", "tbody", "td",
   "tfoot", "th", "thead", "tr"</dt>
   <dd>
    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>
   </dd>

   <dt>Anything else</dt>
   <dd>

    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    body" href="#parsing-main-inbody">in body</a>" <a href="#insertion-mode">insertion mode</a>.</p>

   </dd>

  </dl><h6 id="parsing-main-incolgroup"><span class="secno">8.2.5.4.12 </span>The "<dfn data-anolis-xref="insertion mode: in column group" id="insertion-mode:-in-column-group">in column group</dfn>" insertion mode</h6>

  <p>When the user agent is to apply the rules for the "<a data-anolis-xref="insertion mode: in column
  group" href="#parsing-main-incolgroup">in column group</a>" <a href="#insertion-mode">insertion mode</a>, the user agent must handle the token
  as follows:</p>

  <dl class="switch"><dt>A character token that is one of U+0009 CHARACTER TABULATION, "LF" (U+000A), "FF" (U+000C), "CR" (U+000D), or U+0020 SPACE</dt>
   <dd>
    <p><a data-anolis-xref="insert a character" href="#insert-a-character">Insert the character</a>.</p>
   </dd>

   <dt>A comment token</dt>
   <dd>
    <p><a href="#insert-a-comment">Insert a comment</a>.</p>
   </dd>

   <dt>A DOCTYPE token</dt>
   <dd>
    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>
   </dd>

   <dt>A start tag whose tag name is "html"</dt>
   <dd>

    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    body" href="#parsing-main-inbody">in body</a>" <a href="#insertion-mode">insertion mode</a>.</p>

   </dd>

   <dt>A start tag whose tag name is "col"</dt>
   <dd>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token. Immediately pop the <a href="#current-node">current
    node</a> off the <a href="#stack-of-open-elements">stack of open elements</a>.</p>

    <p><a data-anolis-xref="acknowledge self-closing flag" href="#acknowledge-self-closing-flag">Acknowledge the token's <i>self-closing
    flag</i></a>, if it is set.</p>
   </dd>

   <dt>An end tag whose tag name is "colgroup"</dt>
   <dd>

    <p>If the <a href="#current-node">current node</a> is not a <code><a href="tabular-data.html#the-colgroup-element">colgroup</a></code> element, then this is a
    <a href="#parse-error">parse error</a>; ignore the token.</p> <!-- e.g. colgroup fragment case, or
    <template><col></colgroup> -->

    <p>Otherwise, pop the <a href="#current-node">current node</a> from the <a href="#stack-of-open-elements">stack of open elements</a>.
    Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in table" href="#parsing-main-intable">in
    table</a>".</p>

   </dd>

   <dt>An end tag whose tag name is "col"</dt>
   <dd>
    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>
   </dd>

   <dt>A start tag whose tag name is "template"</dt>
   <dt>An end tag whose tag name is "template"</dt>
   <dd>

    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    head" href="#parsing-main-inhead">in head</a>" <a href="#insertion-mode">insertion mode</a>.</p>

   </dd>

   <dt>An end-of-file token</dt>
   <dd>

    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    body" href="#parsing-main-inbody">in body</a>" <a href="#insertion-mode">insertion mode</a>.</p>

   </dd>

   <dt>Anything else</dt>
   <dd>

    <!-- fake </colgroup> -->
    <p>If the <a href="#current-node">current node</a> is not a <code><a href="tabular-data.html#the-colgroup-element">colgroup</a></code> element, then this is a
    <a href="#parse-error">parse error</a>; ignore the token.</p> <!-- e.g. colgroup fragment case, or
    <template><col></colgroup> -->

    <p>Otherwise, pop the <a href="#current-node">current node</a> from the <a href="#stack-of-open-elements">stack of open
    elements</a>.</p>

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in table" href="#parsing-main-intable">in
    table</a>".</p>
    <!-- end of fake </colgroup> -->

    <p>Reprocess the token.</p>

   </dd>

  </dl><h6 id="parsing-main-intbody"><span class="secno">8.2.5.4.13 </span>The "<dfn data-anolis-xref="insertion mode: in table body" id="insertion-mode:-in-table-body">in table body</dfn>" insertion mode</h6>

  <p>When the user agent is to apply the rules for the "<a data-anolis-xref="insertion mode: in table
  body" href="#parsing-main-intbody">in table body</a>" <a href="#insertion-mode">insertion mode</a>, the user agent must handle the token as
  follows:</p>

  <dl class="switch"><dt>A start tag whose tag name is "tr"</dt>
   <dd>

    <p><a href="#clear-the-stack-back-to-a-table-body-context">Clear the stack back to a table body context</a>. (See below.)</p>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token, then switch the <a href="#insertion-mode">insertion
    mode</a> to "<a data-anolis-xref="insertion mode: in row" href="#parsing-main-intr">in row</a>".</p>

   </dd>

   <dt>A start tag whose tag name is one of: "th", "td"</dt>
   <dd>

    <p><a href="#parse-error">Parse error</a>.</p>

    <!-- fake </tr> -->
    <p><a href="#clear-the-stack-back-to-a-table-body-context">Clear the stack back to a table body context</a>. (See below.)</p>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for a "tr" start tag token with no attributes, then
    switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in row" href="#parsing-main-intr">in
    row</a>".</p>
    <!-- end of fake </tr> -->

    <p>Reprocess the current token.</p>

   </dd>

   <dt>An end tag whose tag name is one of: "tbody", "tfoot",
   "thead"</dt>
   <dd>

    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> does not <a data-anolis-xref="has an element in table
    scope" href="#has-an-element-in-table-scope">have an element in table scope</a> that is an <a data-anolis-xref="HTML elements" href="infrastructure.html#html-elements">HTML
    element</a> and with the same tag name as the token, this is a <a href="#parse-error">parse error</a>;
    ignore the token.</p>

    <p>Otherwise:</p>

    <p><a href="#clear-the-stack-back-to-a-table-body-context">Clear the stack back to a table body context</a>. (See below.)</p>

    <p>Pop the <a href="#current-node">current node</a> from the <a href="#stack-of-open-elements">stack of open elements</a>. Switch the
    <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in table" href="#parsing-main-intable">in table</a>".</p>

   </dd>

   <dt>A start tag whose tag name is one of: "caption", "col",
   "colgroup", "tbody", "tfoot", "thead"</dt>
   <dt>An end tag whose tag name is "table"</dt>
   <dd>

    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> does not <a data-anolis-xref="has an element in table
    scope" href="#has-an-element-in-table-scope">have a <code>tbody</code>, <code>thead</code>, or <code>tfoot</code> element in table
    scope</a>, this is a <a href="#parse-error">parse error</a>; ignore the token.</p>

    <p>Otherwise:</p>

    <p><a href="#clear-the-stack-back-to-a-table-body-context">Clear the stack back to a table body context</a>. (See below.)</p>

    <!-- fake </tbody>, </tfoot>, or </thead>, whatever is the current node -->

    <p>Pop the <a href="#current-node">current node</a> from the <a href="#stack-of-open-elements">stack of open elements</a>. Switch the
    <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in table" href="#parsing-main-intable">in table</a>".</p>

    <!-- end of fake </tbody>, </tfoot>, or </thead>, whatever was the current node -->

    <p>Reprocess the token.</p>

   </dd>

   <dt>An end tag whose tag name is one of: "body", "caption", "col", "colgroup", "html", "td",
   "th", "tr"</dt>
   <dd>
    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>
   </dd>

   <dt>Anything else</dt>
   <dd>
    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    table" href="#parsing-main-intable">in table</a>" <a href="#insertion-mode">insertion mode</a>.</p>
   </dd>

  </dl><p>When the steps above require the UA to <dfn id="clear-the-stack-back-to-a-table-body-context">clear the stack back to a table body context</dfn>,
  it means that the UA must, while the <a href="#current-node">current node</a> is not a <code><a href="tabular-data.html#the-tbody-element">tbody</a></code>,
  <code><a href="tabular-data.html#the-tfoot-element">tfoot</a></code>, <code><a href="tabular-data.html#the-thead-element">thead</a></code>, <code><a href="scripting-1.html#the-template-element">template</a></code>, or <code><a href="semantics.html#the-html-element">html</a></code> element, pop
  elements from the <a href="#stack-of-open-elements">stack of open elements</a>.</p>

  <p class="note">The <a href="#current-node">current node</a> being an <code><a href="semantics.html#the-html-element">html</a></code> element after this
  process is a <a href="#fragment-case">fragment case</a>.</p>


  <h6 id="parsing-main-intr"><span class="secno">8.2.5.4.14 </span>The "<dfn data-anolis-xref="insertion mode: in row" id="insertion-mode:-in-row">in row</dfn>" insertion mode</h6>

  <p>When the user agent is to apply the rules for the "<a data-anolis-xref="insertion mode: in row" href="#parsing-main-intr">in
  row</a>" <a href="#insertion-mode">insertion mode</a>, the user agent must handle the token as follows:</p>

  <dl class="switch"><dt>A start tag whose tag name is one of: "th", "td"</dt>
   <dd>

    <p><a href="#clear-the-stack-back-to-a-table-row-context">Clear the stack back to a table row context</a>. (See below.)</p>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token, then switch the <a href="#insertion-mode">insertion
    mode</a> to "<a data-anolis-xref="insertion mode: in cell" href="#parsing-main-intd">in cell</a>".</p>

    <p>Insert a marker at the end of the <a href="#list-of-active-formatting-elements">list of active formatting elements</a>.</p>

   </dd>

   <dt>An end tag whose tag name is "tr"</dt>
   <dd>

    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> does not <a data-anolis-xref="has an element in table
    scope" href="#has-an-element-in-table-scope">have a <code>tr</code> element in table scope</a>, this is a <a href="#parse-error">parse error</a>;
    ignore the token.</p>

    <p>Otherwise:</p>

    <p><a href="#clear-the-stack-back-to-a-table-row-context">Clear the stack back to a table row context</a>. (See below.)</p>

    <p>Pop the <a href="#current-node">current node</a> (which will be a <code><a href="tabular-data.html#the-tr-element">tr</a></code> element) from the
    <a href="#stack-of-open-elements">stack of open elements</a>. Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in table body" href="#parsing-main-intbody">in table body</a>".</p>

   </dd>

   <dt>A start tag whose tag name is one of: "caption", "col", "colgroup", "tbody", "tfoot",
   "thead", "tr"</dt>
   <dt>An end tag whose tag name is "table"</dt>
   <dd>

    <!-- fake <tr> -->
    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> does not <a data-anolis-xref="has an element in table
    scope" href="#has-an-element-in-table-scope">have a <code>tr</code> element in table scope</a>, this is a <a href="#parse-error">parse error</a>;
    ignore the token.</p>

    <p>Otherwise:</p>

    <p><a href="#clear-the-stack-back-to-a-table-row-context">Clear the stack back to a table row context</a>. (See below.)</p>

    <p>Pop the <a href="#current-node">current node</a> (which will be a <code><a href="tabular-data.html#the-tr-element">tr</a></code> element) from the
    <a href="#stack-of-open-elements">stack of open elements</a>. Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in table body" href="#parsing-main-intbody">in table body</a>".</p>
    <!-- end of fake </tr> -->

    <p>Reprocess the token.</p>

   </dd>

   <dt>An end tag whose tag name is one of: "tbody", "tfoot", "thead"</dt>
   <dd>

    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> does not <a data-anolis-xref="has an element in table
    scope" href="#has-an-element-in-table-scope">have an element in table scope</a> that is an <a data-anolis-xref="HTML elements" href="infrastructure.html#html-elements">HTML
    element</a> and with the same tag name as the token, this is a <a href="#parse-error">parse error</a>;
    ignore the token.</p>

    <!-- fake <tr> -->
    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> does not <a data-anolis-xref="has an element in table
    scope" href="#has-an-element-in-table-scope">have a <code>tr</code> element in table scope</a>, ignore the token.</p>

    <p>Otherwise:</p>

    <p><a href="#clear-the-stack-back-to-a-table-row-context">Clear the stack back to a table row context</a>. (See below.)</p>

    <p>Pop the <a href="#current-node">current node</a> (which will be a <code><a href="tabular-data.html#the-tr-element">tr</a></code> element) from the
    <a href="#stack-of-open-elements">stack of open elements</a>. Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in table body" href="#parsing-main-intbody">in table body</a>".</p>
    <!-- end of fake </tr> -->

    <p>Reprocess the token.</p>

   </dd>

   <dt>An end tag whose tag name is one of: "body", "caption", "col", "colgroup", "html", "td",
   "th"</dt>
   <dd>
    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>
   </dd>

   <dt>Anything else</dt>
   <dd>

    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    table" href="#parsing-main-intable">in table</a>" <a href="#insertion-mode">insertion mode</a>.</p>

   </dd>

  </dl><p>When the steps above require the UA to <dfn id="clear-the-stack-back-to-a-table-row-context">clear the stack back to a table row context</dfn>,
  it means that the UA must, while the <a href="#current-node">current node</a> is not a <code><a href="tabular-data.html#the-tr-element">tr</a></code>,
  <code><a href="scripting-1.html#the-template-element">template</a></code>, or <code><a href="semantics.html#the-html-element">html</a></code> element, pop elements from the <a href="#stack-of-open-elements">stack of open
  elements</a>.</p>

  <p class="note">The <a href="#current-node">current node</a> being an <code><a href="semantics.html#the-html-element">html</a></code> element after this
  process is a <a href="#fragment-case">fragment case</a>.</p>


  <h6 id="parsing-main-intd"><span class="secno">8.2.5.4.15 </span>The "<dfn data-anolis-xref="insertion mode: in cell" id="insertion-mode:-in-cell">in cell</dfn>" insertion mode</h6>

  <p>When the user agent is to apply the rules for the "<a data-anolis-xref="insertion mode: in cell" href="#parsing-main-intd">in cell</a>" <a href="#insertion-mode">insertion mode</a>, the user agent must handle the token as follows:</p>

  <dl class="switch"><dt>An end tag whose tag name is one of: "td", "th"</dt>
   <dd>

    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> does not <a data-anolis-xref="has an element in table
    scope" href="#has-an-element-in-table-scope">have an element in table scope</a> that is an <a data-anolis-xref="HTML elements" href="infrastructure.html#html-elements">HTML
    element</a> and with the same tag name as that of the token, then this is a <a href="#parse-error">parse
    error</a>; ignore the token.</p>

    <p>Otherwise:</p>

    <p><a href="#generate-implied-end-tags">Generate implied end tags</a>.</p>

    <p>Now, if the <a href="#current-node">current node</a> is not an <a data-anolis-xref="HTML elements" href="infrastructure.html#html-elements">HTML
    element</a> with the same tag name as the token, then this is a <a href="#parse-error">parse error</a>.</p>

    <p>Pop elements from the <a href="#stack-of-open-elements">stack of open elements</a> stack until an <a data-anolis-xref="HTML
    elements" href="infrastructure.html#html-elements">HTML element</a> with the same tag name as the token has been popped from the
    stack.</p>

    <p><a href="#clear-the-list-of-active-formatting-elements-up-to-the-last-marker">Clear the list of active formatting elements up to the last marker</a>.</p>

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in row" href="#parsing-main-intr">in
    row</a>".</p> <!-- current node here will be a <tr> normally; but could be <html> in the
    fragment case, or <template> in the template case -->

   </dd>

   <dt>A start tag whose tag name is one of: "caption", "col",
   "colgroup", "tbody", "td", "tfoot", "th", "thead", "tr"</dt>
   <dd>

    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> does <em>not</em> <a data-anolis-xref="has an element in
    table scope" href="#has-an-element-in-table-scope">have a <code>td</code> or <code>th</code> element in table scope</a>, then this
    is a <a href="#parse-error">parse error</a>; ignore the token. (<a href="#fragment-case">fragment case</a>)</p>

    <p>Otherwise, <a href="#close-the-cell">close the cell</a> (see below) and reprocess the token.</p>

   </dd>

   <dt>An end tag whose tag name is one of: "body", "caption",
   "col", "colgroup", "html"</dt>
   <dd>
    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>
   </dd>

   <dt>An end tag whose tag name is one of: "table", "tbody",
   "tfoot", "thead", "tr"</dt>
   <dd>

    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> does not <a data-anolis-xref="has an element in table
    scope" href="#has-an-element-in-table-scope">have an element in table scope</a> that is an <a data-anolis-xref="HTML elements" href="infrastructure.html#html-elements">HTML
    element</a> and with the same tag name as that of the token, then this is a <a href="#parse-error">parse
    error</a>; ignore the token.</p>

    <p>Otherwise, <a href="#close-the-cell">close the cell</a> (see below) and reprocess the token.</p>

   </dd>

   <dt>Anything else</dt>
   <dd>

    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    body" href="#parsing-main-inbody">in body</a>" <a href="#insertion-mode">insertion mode</a>.</p>

   </dd>

  </dl><p>Where the steps above say to <dfn id="close-the-cell">close the cell</dfn>, they mean to run the following
  algorithm:</p>

  <ol><!-- fake </td> or </th> --><li><p><a href="#generate-implied-end-tags">Generate implied end tags</a>.</li>

   <li><p>If the <a href="#current-node">current node</a> is not now a <code><a href="tabular-data.html#the-td-element">td</a></code> element or a <code><a href="tabular-data.html#the-th-element">th</a></code>
   element, then this is a <a href="#parse-error">parse error</a>.</li>

   <li><p>Pop elements from the <a href="#stack-of-open-elements">stack of open elements</a> stack until a <code><a href="tabular-data.html#the-td-element">td</a></code>
   element or a <code><a href="tabular-data.html#the-th-element">th</a></code> element has been popped from the stack.</li>

   <li><p><a href="#clear-the-list-of-active-formatting-elements-up-to-the-last-marker">Clear the list of active formatting elements up to the last marker</a>.</li>

   <li><p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in row" href="#parsing-main-intr">in
   row</a>".</li> <!-- current node here will be a <tr> normally; but could be <html> in the
   fragment case, or <template> in the template case -->
   <!-- end of fake </td> or </th> -->

  </ol><p class="note">The <a href="#stack-of-open-elements">stack of open elements</a> cannot have both a <code><a href="tabular-data.html#the-td-element">td</a></code> and a
  <code><a href="tabular-data.html#the-th-element">th</a></code> element <a data-anolis-xref="has an element in table scope" href="#has-an-element-in-table-scope">in table scope</a> at the
  same time, nor can it have neither when the <a href="#close-the-cell">close the cell</a> algorithm is invoked.</p>


  <h6 id="parsing-main-inselect"><span class="secno">8.2.5.4.16 </span>The "<dfn data-anolis-xref="insertion mode: in select" id="insertion-mode:-in-select">in select</dfn>" insertion mode</h6>

  <p>When the user agent is to apply the rules for the "<a data-anolis-xref="insertion mode: in select" href="#parsing-main-inselect">in
  select</a>" <a href="#insertion-mode">insertion mode</a>, the user agent must handle the token as follows:</p>

  <dl class="switch"><dt>A character token that is U+0000 NULL</dt>
   <dd>
    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>
   </dd>

   <dt>Any other character token</dt>
   <dd>

    <p><a data-anolis-xref="insert a character" href="#insert-a-character">Insert the token's character</a>.</p>

   </dd>

   <dt>A comment token</dt>
   <dd>
    <p><a href="#insert-a-comment">Insert a comment</a>.</p>
   </dd>

   <dt>A DOCTYPE token</dt>
   <dd>
    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>
   </dd>

   <dt>A start tag whose tag name is "html"</dt>
   <dd>

    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    body" href="#parsing-main-inbody">in body</a>" <a href="#insertion-mode">insertion mode</a>.</p>

   </dd>

   <dt>A start tag whose tag name is "option"</dt>
   <dd>

    <!-- fake </option> (maybe) -->
    <p>If the <a href="#current-node">current node</a> is an <code><a href="forms.html#the-option-element">option</a></code> element, pop that node from the
    <a href="#stack-of-open-elements">stack of open elements</a>.</p>
    <!-- end of fake </option> -->

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token.</p>

   </dd>

   <dt>A start tag whose tag name is "optgroup"</dt>
   <dd>

    <!-- fake </option> (maybe) -->
    <p>If the <a href="#current-node">current node</a> is an <code><a href="forms.html#the-option-element">option</a></code> element, pop that node from the
    <a href="#stack-of-open-elements">stack of open elements</a>.</p>
    <!-- end of fake </option> -->

    <!-- fake </optgroup> (maybe) -->
    <p>If the <a href="#current-node">current node</a> is an <code><a href="forms.html#the-optgroup-element">optgroup</a></code> element, pop that node from the
    <a href="#stack-of-open-elements">stack of open elements</a>.</p>
    <!-- end of fake </optgroup> -->

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token.</p>

   </dd>

   <dt>An end tag whose tag name is "optgroup"</dt>
   <dd>

    <!-- fake </option> (maybe) -->
    <p>First, if the <a href="#current-node">current node</a> is an <code><a href="forms.html#the-option-element">option</a></code> element, and the node
    immediately before it in the <a href="#stack-of-open-elements">stack of open elements</a> is an <code><a href="forms.html#the-optgroup-element">optgroup</a></code>
    element, then pop the <a href="#current-node">current node</a> from the <a href="#stack-of-open-elements">stack of open
    elements</a>.</p>
    <!-- end of fake </option> -->

    <p>If the <a href="#current-node">current node</a> is an <code><a href="forms.html#the-optgroup-element">optgroup</a></code> element, then pop that node from
    the <a href="#stack-of-open-elements">stack of open elements</a>. Otherwise, this is a <a href="#parse-error">parse error</a>; ignore
    the token.</p>

   </dd>

   <dt>An end tag whose tag name is "option"</dt>
   <dd>

    <p>If the <a href="#current-node">current node</a> is an <code><a href="forms.html#the-option-element">option</a></code> element, then pop that node from
    the <a href="#stack-of-open-elements">stack of open elements</a>. Otherwise, this is a <a href="#parse-error">parse error</a>; ignore
    the token.</p>

   </dd>

   <dt>An end tag whose tag name is "select"</dt>
   <dd>

    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> does not <a data-anolis-xref="has an element in select
    scope" href="#has-an-element-in-select-scope">have a <code>select</code> element in select scope</a>, this is a <a href="#parse-error">parse
    error</a>; ignore the token. (<a href="#fragment-case">fragment case</a>)</p>

    <p>Otherwise:</p>

    <p>Pop elements from the <a href="#stack-of-open-elements">stack of open elements</a> until a <code><a href="forms.html#the-select-element">select</a></code> element
    has been popped from the stack.</p>

    <p><a href="#reset-the-insertion-mode-appropriately">Reset the insertion mode appropriately</a>.</p>

   </dd>

   <dt>A start tag whose tag name is "select"</dt>
   <dd>

    <p><a href="#parse-error">Parse error</a>.</p>

    <!-- fake </select> -->
    <p>Pop elements from the <a href="#stack-of-open-elements">stack of open elements</a> until a <code><a href="forms.html#the-select-element">select</a></code> element
    has been popped from the stack.</p>

    <p><a href="#reset-the-insertion-mode-appropriately">Reset the insertion mode appropriately</a>.</p>
    <!-- end of fake </select> -->

    <p class="note">It just gets treated like an end tag.</p>

   </dd>

   <dt>A start tag whose tag name is one of: "input", "keygen", "textarea"</dt>
   <dd>

    <p><a href="#parse-error">Parse error</a>.</p>

    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> does not <a data-anolis-xref="has an element in select
    scope" href="#has-an-element-in-select-scope">have a <code>select</code> element in select scope</a>, ignore the token.
    (<a href="#fragment-case">fragment case</a>)</p>

    <!-- fake </select> -->
    <p>Pop elements from the <a href="#stack-of-open-elements">stack of open elements</a> until a <code><a href="forms.html#the-select-element">select</a></code> element
    has been popped from the stack.</p>

    <p><a href="#reset-the-insertion-mode-appropriately">Reset the insertion mode appropriately</a>.</p>
    <!-- end of fake </select> -->

    <p>Reprocess the token.</p>

   </dd>

   <dt>A start tag whose tag name is one of: "script", "template"</dt>
   <dt>An end tag whose tag name is "template"</dt>
   <dd>

    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    head" href="#parsing-main-inhead">in head</a>" <a href="#insertion-mode">insertion mode</a>.</p>

   </dd>

   <dt>An end-of-file token</dt>
   <dd>

    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    body" href="#parsing-main-inbody">in body</a>" <a href="#insertion-mode">insertion mode</a>.</p>

   </dd>

   <dt>Anything else</dt>
   <dd>
    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>
   </dd>

  </dl><h6 id="parsing-main-inselectintable"><span class="secno">8.2.5.4.17 </span>The "<dfn data-anolis-xref="insertion mode: in select in table" id="insertion-mode:-in-select-in-table">in select in table</dfn>" insertion mode</h6>

  <p>When the user agent is to apply the rules for the "<a data-anolis-xref="insertion mode: in select in
  table" href="#parsing-main-inselectintable">in select in table</a>" <a href="#insertion-mode">insertion mode</a>, the user agent must handle the
  token as follows:</p>

  <dl class="switch"><dt>A start tag whose tag name is one of: "caption", "table", "tbody", "tfoot", "thead", "tr",
   "td", "th"</dt>
   <dd>

    <p><a href="#parse-error">Parse error</a>.</p>

    <!-- fake </select> -->
    <p>Pop elements from the <a href="#stack-of-open-elements">stack of open elements</a> until a <code><a href="forms.html#the-select-element">select</a></code> element
    has been popped from the stack.</p>

    <p><a href="#reset-the-insertion-mode-appropriately">Reset the insertion mode appropriately</a>.</p>
    <!-- end of fake </select> -->

    <p>Reprocess the token.</p>

   </dd>

   <dt>An end tag whose tag name is one of: "caption", "table", "tbody", "tfoot", "thead", "tr",
   "td", "th"</dt>
   <dd>

    <p><a href="#parse-error">Parse error</a>.</p>

    <p>If the <a href="#stack-of-open-elements">stack of open elements</a> does not <a data-anolis-xref="has an element in table
    scope" href="#has-an-element-in-table-scope">have an element in table scope</a> that is an <a data-anolis-xref="HTML elements" href="infrastructure.html#html-elements">HTML
    element</a> and with the same tag name as that of the token, then ignore the token.</p>

    <p>Otherwise:</p>

    <!-- fake </select> -->
    <p>Pop elements from the <a href="#stack-of-open-elements">stack of open elements</a> until a <code><a href="forms.html#the-select-element">select</a></code> element
    has been popped from the stack.</p>

    <p><a href="#reset-the-insertion-mode-appropriately">Reset the insertion mode appropriately</a>.</p>
    <!-- end of fake </select> -->

    <p>Reprocess the token.</p>

   </dd>

   <dt>Anything else</dt>
   <dd>

    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    select" href="#parsing-main-inselect">in select</a>" <a href="#insertion-mode">insertion mode</a>.</p>

   </dd>

  </dl><h6 id="parsing-main-intemplate"><span class="secno">8.2.5.4.18 </span>The "<dfn data-anolis-xref="insertion mode: in template" id="insertion-mode:-in-template">in template</dfn>" insertion mode</h6>

  <p>When the user agent is to apply the rules for the "<a data-anolis-xref="insertion mode: in template" href="#parsing-main-intemplate">in
  template</a>" <a href="#insertion-mode">insertion mode</a>, the user agent must handle the token as follows:</p>

  <dl class="switch"><!-- first, tokens we always ignore: --><!-- html: ignored in "in body" mode if there's a <template> on the stack --><!-- head: ignored in "in body" mode always --><!-- body: ignored in "in body" mode if there's a <template> on the stack --><!-- frameset: ignored in "in body" mode if frameset-ok is set to not-ok, which <template> sets it to --><!-- second, tokens that are ambiguous (allowed in multiple modes), let's just handle them in a generic way and not pick a mode: --><dt>A character token</dt>
   <dt>A comment token</dt>
   <dt>A DOCTYPE token</dt>
   <dd>

    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    body" href="#parsing-main-inbody">in body</a>" <a href="#insertion-mode">insertion mode</a>.</p>

   </dd>

   <dt>A start tag whose tag name is one of: "base", "basefont", "bgsound", "link", "meta", "noframes", "script", "style", "template", "title"</dt>
   <dt>An end tag whose tag name is "template"</dt>
   <dd>

    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    head" href="#parsing-main-inhead">in head</a>" <a href="#insertion-mode">insertion mode</a>.</p>

   </dd>

   <!-- now, tokens that imply certain modes -->

   <dt>A start tag whose tag name is one of: "caption", "colgroup", "tbody", "tfoot", "thead"</dt>
   <dd>

    <p>Pop the <a href="#current-template-insertion-mode">current template insertion mode</a> off the <a href="#stack-of-template-insertion-modes">stack of template
    insertion modes</a>.</p>

    <p>Push "<a data-anolis-xref="insertion mode: in table" href="#parsing-main-intable">in table</a>" onto the <a href="#stack-of-template-insertion-modes">stack of
    template insertion modes</a> so that it is the new <a href="#current-template-insertion-mode">current template insertion
    mode</a>.</p>

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in table" href="#parsing-main-intable">in
    table</a>", and reprocess the token.</p>

   </dd>

   <dt>A start tag whose tag name is "col"</dt>
   <dd>

    <p>Pop the <a href="#current-template-insertion-mode">current template insertion mode</a> off the <a href="#stack-of-template-insertion-modes">stack of template
    insertion modes</a>.</p>

    <p>Push "<a data-anolis-xref="insertion mode: in column group" href="#parsing-main-incolgroup">in column group</a>" onto the
    <a href="#stack-of-template-insertion-modes">stack of template insertion modes</a> so that it is the new <a href="#current-template-insertion-mode">current template
    insertion mode</a>.</p>

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in column group" href="#parsing-main-incolgroup">in
    column group</a>", and reprocess the token.</p>

   </dd>

   <dt>A start tag whose tag name is "tr"</dt>
   <dd>

    <p>Pop the <a href="#current-template-insertion-mode">current template insertion mode</a> off the <a href="#stack-of-template-insertion-modes">stack of template
    insertion modes</a>.</p>

    <p>Push "<a data-anolis-xref="insertion mode: in table body" href="#parsing-main-intbody">in table body</a>" onto the <a href="#stack-of-template-insertion-modes">stack
    of template insertion modes</a> so that it is the new <a href="#current-template-insertion-mode">current template insertion
    mode</a>.</p>

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in table body" href="#parsing-main-intbody">in
    table body</a>", and reprocess the token.</p>

   </dd>

   <dt>A start tag whose tag name is one of: "td", "th"</dt>
   <dd>

    <p>Pop the <a href="#current-template-insertion-mode">current template insertion mode</a> off the <a href="#stack-of-template-insertion-modes">stack of template
    insertion modes</a>.</p>

    <p>Push "<a data-anolis-xref="insertion mode: in row" href="#parsing-main-intr">in row</a>" onto the <a href="#stack-of-template-insertion-modes">stack of template
    insertion modes</a> so that it is the new <a href="#current-template-insertion-mode">current template insertion mode</a>.</p>

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in row" href="#parsing-main-intr">in
    row</a>", and reprocess the token.</p>

   </dd>

   <!-- default to in-body mode -->

   <dt>Any other start tag</dt>
   <dd>

    <p>Pop the <a href="#current-template-insertion-mode">current template insertion mode</a> off the <a href="#stack-of-template-insertion-modes">stack of template
    insertion modes</a>.</p>

    <p>Push "<a data-anolis-xref="insertion mode: in body" href="#parsing-main-inbody">in body</a>" onto the <a href="#stack-of-template-insertion-modes">stack of template
    insertion modes</a> so that it is the new <a href="#current-template-insertion-mode">current template insertion mode</a>.</p>

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: in body" href="#parsing-main-inbody">in
    body</a>", and reprocess the token.</p>

   </dd>

   <dt>Any other end tag</dt>
   <dd>
    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>
   </dd>

   <!-- EOF -->


   <dt>An end-of-file token</dt>
   <dd>

    <p>If there is no <code><a href="scripting-1.html#the-template-element">template</a></code> element on the <a href="#stack-of-open-elements">stack of open elements</a>, then
    <a href="#stop-parsing">stop parsing</a>. (<a href="#fragment-case">fragment case</a>)</p>

    <p>Otherwise, this is a <a href="#parse-error">parse error</a>.</p>

    <!-- fake </template> -->
    <p>Pop elements from the <a href="#stack-of-open-elements">stack of open elements</a> until a <code><a href="scripting-1.html#the-template-element">template</a></code>
    element has been popped from the stack.</p>

    <p><a href="#clear-the-list-of-active-formatting-elements-up-to-the-last-marker">Clear the list of active formatting elements up to the last marker</a>.</p>

    <p>Pop the <a href="#current-template-insertion-mode">current template insertion mode</a> off the <a href="#stack-of-template-insertion-modes">stack of template
    insertion modes</a>.</p>

    <p><a href="#reset-the-insertion-mode-appropriately">Reset the insertion mode appropriately</a>.</p>
    <!-- end of fake </template> -->

    <p>Reprocess the token.</p>

   </dd>

  </dl><h6 id="parsing-main-afterbody"><span class="secno">8.2.5.4.19 </span>The "<dfn data-anolis-xref="insertion mode: after body" id="insertion-mode:-after-body">after body</dfn>" insertion mode</h6>

  <p>When the user agent is to apply the rules for the "<a data-anolis-xref="insertion mode: after body" href="#parsing-main-afterbody">after body</a>" <a href="#insertion-mode">insertion mode</a>, the user agent must handle the token as follows:</p>

  <dl class="switch"><dt>A character token that is one of U+0009 CHARACTER TABULATION, "LF" (U+000A), "FF" (U+000C), "CR" (U+000D), or U+0020 SPACE</dt>
   <dd>

    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    body" href="#parsing-main-inbody">in body</a>" <a href="#insertion-mode">insertion mode</a>.</p>

   </dd>

   <dt>A comment token</dt>
   <dd>

    <p><a href="#insert-a-comment">Insert a comment</a> as the last child of the first element in the <a href="#stack-of-open-elements">stack of
    open elements</a> (the <code><a href="semantics.html#the-html-element">html</a></code> element).</p>

   </dd>

   <dt>A DOCTYPE token</dt>
   <dd>
    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>
   </dd>

   <dt>A start tag whose tag name is "html"</dt>
   <dd>

    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    body" href="#parsing-main-inbody">in body</a>" <a href="#insertion-mode">insertion mode</a>.</p>

   </dd>

   <dt>An end tag whose tag name is "html"</dt>
   <dd>

    <p>If the parser was originally created as part of the <a href="#html-fragment-parsing-algorithm">HTML fragment parsing
    algorithm</a>, this is a <a href="#parse-error">parse error</a>; ignore the token. (<a href="#fragment-case">fragment
    case</a>)</p>

    <p>Otherwise, switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: after
    after body" href="#the-after-after-body-insertion-mode">after after body</a>".</p>

   </dd>

   <dt>An end-of-file token</dt>
   <dd>
    <p><a href="#stop-parsing">Stop parsing</a>.</p>
   </dd>

   <dt>Anything else</dt>
   <dd>

    <p><a href="#parse-error">Parse error</a>. Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion
    mode: in body" href="#parsing-main-inbody">in body</a>" and reprocess the token.</p>

   </dd>

  </dl><h6 id="parsing-main-inframeset"><span class="secno">8.2.5.4.20 </span>The "<dfn data-anolis-xref="insertion mode: in frameset" id="insertion-mode:-in-frameset">in frameset</dfn>" insertion mode</h6>

  <p>When the user agent is to apply the rules for the "<a data-anolis-xref="insertion mode: in frameset" href="#parsing-main-inframeset">in
  frameset</a>" <a href="#insertion-mode">insertion mode</a>, the user agent must handle the token as follows:</p>

  <dl class="switch"><dt>A character token that is one of U+0009 CHARACTER TABULATION, "LF" (U+000A), "FF" (U+000C), "CR" (U+000D), or U+0020 SPACE</dt>
   <dd>
    <p><a data-anolis-xref="insert a character" href="#insert-a-character">Insert the character</a>.</p>
   </dd>

   <dt>A comment token</dt>
   <dd>
    <p><a href="#insert-a-comment">Insert a comment</a>.</p>
   </dd>

   <dt>A DOCTYPE token</dt>
   <dd>
    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>
   </dd>

   <dt>A start tag whose tag name is "html"</dt>
   <dd>

    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    body" href="#parsing-main-inbody">in body</a>" <a href="#insertion-mode">insertion mode</a>.</p>

   </dd>

   <dt>A start tag whose tag name is "frameset"</dt>
   <dd>
    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token.</p>
   </dd>

   <dt>An end tag whose tag name is "frameset"</dt>
   <dd>

    <p>If the <a href="#current-node">current node</a> is the root <code><a href="semantics.html#the-html-element">html</a></code> element, then this is a
    <a href="#parse-error">parse error</a>; ignore the token. (<a href="#fragment-case">fragment case</a>)</p>

    <p>Otherwise, pop the <a href="#current-node">current node</a> from the <a href="#stack-of-open-elements">stack of open
    elements</a>.</p>

    <p>If the parser was <em>not</em> originally created as part of the <a href="#html-fragment-parsing-algorithm">HTML fragment parsing
    algorithm</a> (<a href="#fragment-case">fragment case</a>), and the <a href="#current-node">current node</a> is no longer a
    <code><a href="obsolete.html#frameset">frameset</a></code> element, then switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: after frameset" href="#parsing-main-afterframeset">after frameset</a>".</p>

   </dd>

   <dt>A start tag whose tag name is "frame"</dt>
   <dd>

    <p><a href="#insert-an-html-element">Insert an HTML element</a> for the token. Immediately pop the <a href="#current-node">current
    node</a> off the <a href="#stack-of-open-elements">stack of open elements</a>.</p>

    <p><a data-anolis-xref="acknowledge self-closing flag" href="#acknowledge-self-closing-flag">Acknowledge the token's <i>self-closing
    flag</i></a>, if it is set.</p>

   </dd>

   <dt>A start tag whose tag name is "noframes"</dt>
   <dd>

    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    head" href="#parsing-main-inhead">in head</a>" <a href="#insertion-mode">insertion mode</a>.</p>

   </dd>

   <dt>An end-of-file token</dt>
   <dd>

    <p>If the <a href="#current-node">current node</a> is not the root <code><a href="semantics.html#the-html-element">html</a></code> element, then this is a
    <a href="#parse-error">parse error</a>.</p>

    <p class="note">The <a href="#current-node">current node</a> can only be the root
    <code><a href="semantics.html#the-html-element">html</a></code> element in the <a href="#fragment-case">fragment case</a>.</p>

    <p><a href="#stop-parsing">Stop parsing</a>.</p>

   </dd>

   <dt>Anything else</dt>
   <dd>
    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>
   </dd>

  </dl><h6 id="parsing-main-afterframeset"><span class="secno">8.2.5.4.21 </span>The "<dfn data-anolis-xref="insertion mode: after frameset" id="insertion-mode:-after-frameset">after frameset</dfn>" insertion mode</h6>

  <p>When the user agent is to apply the rules for the "<a data-anolis-xref="insertion mode: after
  frameset" href="#parsing-main-afterframeset">after frameset</a>" <a href="#insertion-mode">insertion mode</a>, the user agent must handle the token
  as follows:</p>

  <!-- due to rules in the "in frameset" mode, this can't be entered in the fragment case -->
  <dl class="switch"><dt>A character token that is one of U+0009 CHARACTER TABULATION, "LF" (U+000A), "FF" (U+000C), "CR" (U+000D), or U+0020 SPACE</dt>
   <dd>
    <p><a data-anolis-xref="insert a character" href="#insert-a-character">Insert the character</a>.</p>
   </dd>

   <dt>A comment token</dt>
   <dd>
    <p><a href="#insert-a-comment">Insert a comment</a>.</p>
   </dd>

   <dt>A DOCTYPE token</dt>
   <dd>
    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>
   </dd>

   <dt>A start tag whose tag name is "html"</dt>
   <dd>

    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    body" href="#parsing-main-inbody">in body</a>" <a href="#insertion-mode">insertion mode</a>.</p>

   </dd>

   <dt>An end tag whose tag name is "html"</dt>
   <dd>

    <p>Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion mode: after after
    frameset" href="#the-after-after-frameset-insertion-mode">after after frameset</a>".</p>

   </dd>

   <dt>A start tag whose tag name is "noframes"</dt>
   <dd>

    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    head" href="#parsing-main-inhead">in head</a>" <a href="#insertion-mode">insertion mode</a>.</p>

   </dd>

   <dt>An end-of-file token</dt>
   <dd>
    <p><a href="#stop-parsing">Stop parsing</a>.</p>
   </dd>

   <dt>Anything else</dt>
   <dd>
    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>
   </dd>

  </dl><h6 id="the-after-after-body-insertion-mode"><span class="secno">8.2.5.4.22 </span>The "<dfn data-anolis-xref="insertion mode: after after body" id="insertion-mode:-after-after-body">after after body</dfn>" insertion mode</h6>

  <p>When the user agent is to apply the rules for the "<a data-anolis-xref="insertion mode: after after
  body" href="#the-after-after-body-insertion-mode">after after body</a>" <a href="#insertion-mode">insertion mode</a>, the user agent must handle the token
  as follows:</p>

  <dl class="switch"><dt>A comment token</dt>
   <dd>
    <p><a href="#insert-a-comment">Insert a comment</a> as the last child of the <code><a href="dom.html#document">Document</a></code> object.</p>
   </dd>

   <dt>A DOCTYPE token</dt>
   <dt>A character token that is one of U+0009 CHARACTER TABULATION, "LF" (U+000A), "FF" (U+000C), "CR" (U+000D), or U+0020 SPACE</dt>
   <dt>A start tag whose tag name is "html"</dt>
   <dd>

    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    body" href="#parsing-main-inbody">in body</a>" <a href="#insertion-mode">insertion mode</a>.</p>

   </dd>

   <dt>An end-of-file token</dt>
   <dd>
    <p><a href="#stop-parsing">Stop parsing</a>.</p>
   </dd>

   <dt>Anything else</dt>
   <dd>

    <p><a href="#parse-error">Parse error</a>. Switch the <a href="#insertion-mode">insertion mode</a> to "<a data-anolis-xref="insertion
    mode: in body" href="#parsing-main-inbody">in body</a>" and reprocess the token.</p>

   </dd>

  </dl><h6 id="the-after-after-frameset-insertion-mode"><span class="secno">8.2.5.4.23 </span>The "<dfn data-anolis-xref="insertion mode: after after frameset" id="insertion-mode:-after-after-frameset">after after frameset</dfn>" insertion mode</h6>

  <p>When the user agent is to apply the rules for the "<a data-anolis-xref="insertion mode: after after
  frameset" href="#the-after-after-frameset-insertion-mode">after after frameset</a>" <a href="#insertion-mode">insertion mode</a>, the user agent must handle the
  token as follows:</p>

  <dl class="switch"><dt>A comment token</dt>
   <dd>
    <p><a href="#insert-a-comment">Insert a comment</a> as the last child of the <code><a href="dom.html#document">Document</a></code> object.</p>
   </dd>

   <dt>A DOCTYPE token</dt>
   <dt>A character token that is one of U+0009 CHARACTER TABULATION, "LF" (U+000A), "FF" (U+000C), "CR" (U+000D), or U+0020 SPACE</dt>
   <dt>A start tag whose tag name is "html"</dt>
   <dd>

    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    body" href="#parsing-main-inbody">in body</a>" <a href="#insertion-mode">insertion mode</a>.</p>

   </dd>

   <dt>An end-of-file token</dt>
   <dd>
    <p><a href="#stop-parsing">Stop parsing</a>.</p>
   </dd>

   <dt>A start tag whose tag name is "noframes"</dt>
   <dd>

    <p>Process the token <a href="#using-the-rules-for">using the rules for</a> the "<a data-anolis-xref="insertion mode: in
    head" href="#parsing-main-inhead">in head</a>" <a href="#insertion-mode">insertion mode</a>.</p>

   </dd>

   <dt>Anything else</dt>
   <dd>
    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>
   </dd>

  </dl><h5 id="parsing-main-inforeign"><span class="secno">8.2.5.5 </span>The rules for parsing tokens <dfn data-anolis-xref="insertion mode: in foreign content" id="insertion-mode:-in-foreign-content">in foreign content</dfn></h5>

  <p>When the user agent is to apply the rules for parsing tokens in foreign content, the user agent
  must handle the token as follows:</p>

  <dl class="switch"><dt>A character token that is U+0000 NULL</dt>
   <dd>

    <p><a href="#parse-error">Parse error</a>. <a data-anolis-xref="insert a character" href="#insert-a-character">Insert a U+FFFD REPLACEMENT
    CHARACTER character</a>.</p>

   </dd>

   <dt>A character token that is one of U+0009 CHARACTER TABULATION, "LF" (U+000A), "FF" (U+000C), "CR" (U+000D), or U+0020 SPACE</dt>
   <dd>

    <p><a data-anolis-xref="insert a character" href="#insert-a-character">Insert the token's character</a>.</p>

   </dd>

   <dt>Any other character token</dt>
   <dd>

    <p><a data-anolis-xref="insert a character" href="#insert-a-character">Insert the token's character</a>.</p>

    <p>Set the <a href="#frameset-ok-flag">frameset-ok flag</a> to "not ok".</p>

   </dd>

   <dt>A comment token</dt>
   <dd>

    <p><a href="#insert-a-comment">Insert a comment</a>.</p>

   </dd>

   <dt>A DOCTYPE token</dt>
   <dd>
    <p><a href="#parse-error">Parse error</a>. Ignore the token.</p>
   </dd>

   <dt>A start tag whose tag name is one of: <!--"a",--> "b", "big", "blockquote", "body"<!--by
   inspection-->, "br", "center", "code", "dd", "div", "dl", "dt"<!-- so that dd and dt can be
   handled uniformly throughout the parser -->, "em", "embed", "h1", "h2", "h3", "h4"<!--for
   completeness-->, "h5", "h6"<!--for completeness-->, "head"<!--by inspection-->, "hr", "i", "img",
   "li", "listing"<!-- so that pre and listing can be handled uniformly throughout the parser -->,
<!-- FORK - may be redundant as main added to WHATWG SF-->"main",
   "meta", "nobr", "ol"<!-- so that dl, ul, and ol can be handled uniformly throughout the
   parser -->, "p", "pre", "ruby", "s", <!--"script",--> "small", "span", "strong", "strike"<!-- so
   that s and strike can be handled uniformly throughout the parser -->, <!--"style",--> "sub",
   "sup", "table"<!--by inspection-->, "tt", "u", "ul", "var"</dt> <!-- this list was determined
   empirically by studying over 6,000,000,000 pages that were specifically not XML pages -->
   <dt>A start tag whose tag name is "font", if the token has any attributes named "color", "face",
   or "size"</dt> <!-- the attributes here are required so that SVG <font> will go through as SVG
   but legacy <font>s won't -->

   <dd>

    <p><a href="#parse-error">Parse error</a>.</p>

    <!-- for sanity's sake, we limit this wacked quirk to legacy full-document parsing, not to
    innerHTML. We have no data showing whether (or that) this is needed for innerHTML. If innerHTML
    is used on an SVG or MathML node, it definitely doesn't make any sense (there's nothing to pop
    to in the first place). Therefore, rather than trying to figure out in what convoluted
    conditions we could actually do this quirk for innerHTML, we just don't do it at all. -->

    <p>If the parser was originally created for the <a href="#html-fragment-parsing-algorithm">HTML fragment parsing algorithm</a>,
    then act as described in the "any other start tag" entry below. (<a href="#fragment-case">fragment case</a>)</p>

    <p>Otherwise:</p>

    <p>Pop an element from the <a href="#stack-of-open-elements">stack of open elements</a>, and then keep popping more
    elements from the <a href="#stack-of-open-elements">stack of open elements</a> until the <a href="#current-node">current node</a> is a
    <a href="#mathml-text-integration-point">MathML text integration point</a>, an <a href="#html-integration-point">HTML integration point</a>, or an
    element in the <a href="infrastructure.html#html-namespace-0">HTML namespace</a>.</p>

    <p>Then, reprocess the token.</p>

   </dd>

   <dt>Any other start tag</dt>
   <dd>

    <p>If the <a href="#adjusted-current-node">adjusted current node</a> is an element in the <a href="infrastructure.html#mathml-namespace">MathML namespace</a>,
    <a href="#adjust-mathml-attributes">adjust MathML attributes</a> for the token. (This fixes the case of MathML attributes
    that are not all lowercase.)</p>

    <p>If the <a href="#adjusted-current-node">adjusted current node</a> is an element in the <a href="infrastructure.html#svg-namespace">SVG namespace</a>, and the
    token's tag name is one of the ones in the first column of the following table, change the tag
    name to the name given in the corresponding cell in the second column. (This fixes the case of
    SVG elements that are not all lowercase.)</p>

    <table><thead><tr><th> Tag name </th><th> Element name
     <tbody></th></tr><tr><td> <code data-anolis-xref="">altglyph</code> </td><td> <code data-anolis-xref="">altGlyph</code>
      </td></tr><tr><td> <code data-anolis-xref="">altglyphdef</code> </td><td> <code data-anolis-xref="">altGlyphDef</code>
      </td></tr><tr><td> <code data-anolis-xref="">altglyphitem</code> </td><td> <code data-anolis-xref="">altGlyphItem</code>
      </td></tr><tr><td> <code data-anolis-xref="">animatecolor</code> </td><td> <code data-anolis-xref="">animateColor</code>
      </td></tr><tr><td> <code data-anolis-xref="">animatemotion</code> </td><td> <code data-anolis-xref="">animateMotion</code>
      </td></tr><tr><td> <code data-anolis-xref="">animatetransform</code> </td><td> <code data-anolis-xref="">animateTransform</code>
      </td></tr><tr><td> <code data-anolis-xref="">clippath</code> </td><td> <code data-anolis-xref="">clipPath</code>
      </td></tr><tr><td> <code data-anolis-xref="">feblend</code> </td><td> <code data-anolis-xref="">feBlend</code>
      </td></tr><tr><td> <code data-anolis-xref="">fecolormatrix</code> </td><td> <code data-anolis-xref="">feColorMatrix</code>
      </td></tr><tr><td> <code data-anolis-xref="">fecomponenttransfer</code> </td><td> <code data-anolis-xref="">feComponentTransfer</code>
      </td></tr><tr><td> <code data-anolis-xref="">fecomposite</code> </td><td> <code data-anolis-xref="">feComposite</code>
      </td></tr><tr><td> <code data-anolis-xref="">feconvolvematrix</code> </td><td> <code data-anolis-xref="">feConvolveMatrix</code>
      </td></tr><tr><td> <code data-anolis-xref="">fediffuselighting</code> </td><td> <code data-anolis-xref="">feDiffuseLighting</code>
      </td></tr><tr><td> <code data-anolis-xref="">fedisplacementmap</code> </td><td> <code data-anolis-xref="">feDisplacementMap</code>
      </td></tr><tr><td> <code data-anolis-xref="">fedistantlight</code> </td><td> <code data-anolis-xref="">feDistantLight</code>
      </td></tr><tr><td> <code data-anolis-xref="">fedropshadow</code> </td><td> <code data-anolis-xref="">feDropShadow</code>
      </td></tr><tr><td> <code data-anolis-xref="">feflood</code> </td><td> <code data-anolis-xref="">feFlood</code>
      </td></tr><tr><td> <code data-anolis-xref="">fefunca</code> </td><td> <code data-anolis-xref="">feFuncA</code>
      </td></tr><tr><td> <code data-anolis-xref="">fefuncb</code> </td><td> <code data-anolis-xref="">feFuncB</code>
      </td></tr><tr><td> <code data-anolis-xref="">fefuncg</code> </td><td> <code data-anolis-xref="">feFuncG</code>
      </td></tr><tr><td> <code data-anolis-xref="">fefuncr</code> </td><td> <code data-anolis-xref="">feFuncR</code>
      </td></tr><tr><td> <code data-anolis-xref="">fegaussianblur</code> </td><td> <code data-anolis-xref="">feGaussianBlur</code>
      </td></tr><tr><td> <code data-anolis-xref="">feimage</code> </td><td> <code data-anolis-xref="">feImage</code>
      </td></tr><tr><td> <code data-anolis-xref="">femerge</code> </td><td> <code data-anolis-xref="">feMerge</code>
      </td></tr><tr><td> <code data-anolis-xref="">femergenode</code> </td><td> <code data-anolis-xref="">feMergeNode</code>
      </td></tr><tr><td> <code data-anolis-xref="">femorphology</code> </td><td> <code data-anolis-xref="">feMorphology</code>
      </td></tr><tr><td> <code data-anolis-xref="">feoffset</code> </td><td> <code data-anolis-xref="">feOffset</code>
      </td></tr><tr><td> <code data-anolis-xref="">fepointlight</code> </td><td> <code data-anolis-xref="">fePointLight</code>
      </td></tr><tr><td> <code data-anolis-xref="">fespecularlighting</code> </td><td> <code data-anolis-xref="">feSpecularLighting</code>
      </td></tr><tr><td> <code data-anolis-xref="">fespotlight</code> </td><td> <code data-anolis-xref="">feSpotLight</code>
      </td></tr><tr><td> <code data-anolis-xref="">fetile</code> </td><td> <code data-anolis-xref="">feTile</code>
      </td></tr><tr><td> <code data-anolis-xref="">feturbulence</code> </td><td> <code data-anolis-xref="">feTurbulence</code>
      </td></tr><tr><td> <code data-anolis-xref="">foreignobject</code> </td><td> <code data-anolis-xref="">foreignObject</code>
      </td></tr><tr><td> <code data-anolis-xref="">glyphref</code> </td><td> <code data-anolis-xref="">glyphRef</code>
      </td></tr><tr><td> <code data-anolis-xref="">lineargradient</code> </td><td> <code data-anolis-xref="">linearGradient</code>
      </td></tr><tr><td> <code data-anolis-xref="">radialgradient</code> </td><td> <code data-anolis-xref="">radialGradient</code>
      <!--<tr> <td> <code data-x="">solidcolor</code> <td> <code data-x="">solidColor</code> (SVG 1.2)-->
      </td></tr><tr><td> <code data-anolis-xref="">textpath</code> </td><td> <code data-anolis-xref="">textPath</code>
    </td></tr></table><p>If the <a href="#adjusted-current-node">adjusted current node</a> is an element in the <a href="infrastructure.html#svg-namespace">SVG namespace</a>,
    <a href="#adjust-svg-attributes">adjust SVG attributes</a> for the token. (This fixes the case of SVG attributes that
    are not all lowercase.)</p>

    <p><a href="#adjust-foreign-attributes">Adjust foreign attributes</a> for the token. (This fixes the use of namespaced
    attributes, in particular XLink in SVG.)</p>

    <p><a href="#insert-a-foreign-element">Insert a foreign element</a> for the token, in the same namespace as the
    <a href="#adjusted-current-node">adjusted current node</a>.</p>

    <p>If the token has its <i>self-closing flag</i> set, then run the appropriate steps from the
    following list:</p>

    <dl class="switch"><dt>If the token's tag name is "script"</dt>

     <dd>

      <p><a data-anolis-xref="acknowledge self-closing flag" href="#acknowledge-self-closing-flag">Acknowledge the token's <i>self-closing
      flag</i></a>, and then act as described in the steps for a "script" end tag below.</p>

     </dd>

     <dt>Otherwise</dt>

     <dd>

      <p>Pop the <a href="#current-node">current node</a> off the <a href="#stack-of-open-elements">stack of open elements</a> and <a data-anolis-xref="acknowledge self-closing flag" href="#acknowledge-self-closing-flag">acknowledge the token's <i>self-closing
      flag</i></a>.</p>

     </dd>

    </dl></dd>

   <dt id="scriptForeignEndTag">An end tag whose tag name is "script", if the <a href="#current-node">current node</a> is a <code data-anolis-xref="">script</code> element in the <a href="infrastructure.html#svg-namespace">SVG namespace</a></dt>
   <dd>

    <p>Pop the <a href="#current-node">current node</a> off the <a href="#stack-of-open-elements">stack of open elements</a>.</p>

    <p>Let the <var data-anolis-xref="">old insertion point</var> have the same value as the current
    <a href="#insertion-point">insertion point</a>. Let the <a href="#insertion-point">insertion point</a> be just before the <a href="#next-input-character">next
    input character</a>.</p>

    <p>Increment the parser's <a href="#script-nesting-level">script nesting level</a> by one. Set the <a href="#parser-pause-flag">parser pause
    flag</a> to true.</p>

    <p><a href="http://www.w3.org/TR/SVGMobile12/script.html#ScriptContentProcessing">Process the
    <code data-anolis-xref="">script</code> element</a> according to the SVG rules, if the user agent supports
    SVG. <a href="references.html#refsSVG">[SVG]</a></p>

    <p class="note">Even if this causes <a data-anolis-xref="dom-document-write" href="webappapis.html#dom-document-write">new characters to be
    inserted into the tokenizer</a>, the parser will not be executed reentrantly, since the
    <a href="#parser-pause-flag">parser pause flag</a> is true.</p>

    <p>Decrement the parser's <a href="#script-nesting-level">script nesting level</a> by one. If the parser's <a href="#script-nesting-level">script
    nesting level</a> is zero, then set the <a href="#parser-pause-flag">parser pause flag</a> to false.</p>

    <p>Let the <a href="#insertion-point">insertion point</a> have the value of the <var data-anolis-xref="">old insertion
    point</var>. (In other words, restore the <a href="#insertion-point">insertion point</a> to its previous value.
    This value might be the "undefined" value.)</p>

   </dd>

   <dt>Any other end tag</dt>

   <dd>

    <p>Run these steps:</p>

    <ol><li><p>Initialize <var data-anolis-xref="">node</var> to be the <a href="#current-node">current node</a> (the bottommost
     node of the stack).</li>

     <li><p>If <var data-anolis-xref="">node</var>'s tag name, <a href="infrastructure.html#converted-to-ascii-lowercase">converted to ASCII lowercase</a>, is
     not the same as the tag name of the token, then this is a <a href="#parse-error">parse error</a>.</li>

     <li><p><i>Loop</i>: If <var data-anolis-xref="">node</var> is the topmost element in the <a href="#stack-of-open-elements">stack of
     open elements</a>, abort these steps. (<a href="#fragment-case">fragment case</a>)</li>

     <li><p>If <var data-anolis-xref="">node</var>'s tag name, <a href="infrastructure.html#converted-to-ascii-lowercase">converted to ASCII lowercase</a>, is
     the same as the tag name of the token, pop elements from the <a href="#stack-of-open-elements">stack of open
     elements</a> until <var data-anolis-xref="">node</var> has been popped from the stack, and then abort
     these steps.</li>

     <li><p>Set <var data-anolis-xref="">node</var> to the previous entry in the <a href="#stack-of-open-elements">stack of open
     elements</a>.</li>

     <li><p>If <var data-anolis-xref="">node</var> is not an element in the <a href="infrastructure.html#html-namespace-0">HTML namespace</a>, return
     to the step labeled <i>loop</i>.</li>

     <li><p>Otherwise, process the token according to the rules given in the section corresponding
     to the current <a href="#insertion-mode">insertion mode</a> in HTML content.</li>

    </ol></dd>

  </dl></div>


  <div class="impl">

  <h4 id="the-end"><span class="secno">8.2.6 </span>The end</h4>

  <p>Once the user agent <dfn data-anolis-xref="stop parsing" id="stop-parsing">stops parsing</dfn> the document, the user agent
  must run the following steps:</p>

  <ol><!-- this happens as part of one of the tasks that runs the parser --><li><p>Set the <a href="dom.html#current-document-readiness">current document readiness</a> to "<code data-anolis-xref="">interactive</code>"
   <!-- this also synchronously fires an event --> and the <a href="#insertion-point">insertion point</a> to
   undefined.</li>

   <li><p>Pop <em>all</em> the nodes off the <a href="#stack-of-open-elements">stack of open elements</a>.</li>

   <li><p>If the <a href="scripting-1.html#list-of-scripts-that-will-execute-when-the-document-has-finished-parsing">list of scripts that will execute when the document has finished
   parsing</a> is not empty, run these substeps:</p>

    <ol><li><p><a href="webappapis.html#spin-the-event-loop">Spin the event loop</a> until the first <code><a href="scripting-1.html#the-script-element">script</a></code> in the <a href="scripting-1.html#list-of-scripts-that-will-execute-when-the-document-has-finished-parsing">list
     of scripts that will execute when the document has finished parsing</a> has its <a href="scripting-1.html#ready-to-be-parser-executed">"ready
     to be parser-executed"</a> flag set <em>and</em> the parser's <code><a href="dom.html#document">Document</a></code>
     <a href="document-metadata.html#has-no-style-sheet-that-is-blocking-scripts">has no style sheet that is blocking scripts</a>.</li>

     <li><p><a data-anolis-xref="execute the script block" href="scripting-1.html#execute-the-script-block">Execute</a> the first <code><a href="scripting-1.html#the-script-element">script</a></code> in
     the <a href="scripting-1.html#list-of-scripts-that-will-execute-when-the-document-has-finished-parsing">list of scripts that will execute when the document has finished
     parsing</a>.</li>

     <li><p>Remove the first <code><a href="scripting-1.html#the-script-element">script</a></code> element from the <a href="scripting-1.html#list-of-scripts-that-will-execute-when-the-document-has-finished-parsing">list of scripts that will
     execute when the document has finished parsing</a> (i.e. shift out the first entry in the
     list).</li>

     <li><p>If the <a href="scripting-1.html#list-of-scripts-that-will-execute-when-the-document-has-finished-parsing">list of scripts that will execute when the document has finished
     parsing</a> is still not empty, repeat these substeps again from substep 1.</p>

    </li></ol></li>

   <li><p><a href="webappapis.html#queue-a-task">Queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> that bubbles named <code data-anolis-xref="event-DOMContentLoaded">DOMContentLoaded</code> at the <code><a href="dom.html#document">Document</a></code>.</li>

   <li><p><a href="webappapis.html#spin-the-event-loop">Spin the event loop</a> until the <a href="scripting-1.html#set-of-scripts-that-will-execute-as-soon-as-possible">set of scripts that will execute as soon
   as possible</a> and the <a href="scripting-1.html#list-of-scripts-that-will-execute-in-order-as-soon-as-possible">list of scripts that will execute in order as soon as
   possible</a> are empty.</li> <!-- this step is not redundant with the next one, since
   <script> nodes delay the load event of the document they are in, but they might change document
   between being added to one document's set/list and executing those scripts, so they might be
   delaying another document but still be in this document's set/list. -->

   <li><p><a href="webappapis.html#spin-the-event-loop">Spin the event loop</a> until there is nothing that <dfn data-anolis-xref="delay the load
   event" id="delay-the-load-event">delays the load event</dfn> in the <code><a href="dom.html#document">Document</a></code>.</li>

   <li>

    <p><a href="webappapis.html#queue-a-task">Queue a task</a> to run the following substeps:</p>

    <ol><li><p>Set the <a href="dom.html#current-document-readiness">current document readiness</a> to "<code data-anolis-xref="">complete</code>"<!--
     this also fires an event synchronously during the task -->.</li>

     <li><p>If the <code><a href="dom.html#document">Document</a></code> is in a <a href="browsers.html#browsing-context">browsing context</a>, create a <a data-anolis-xref="concept-events-trusted" href="infrastructure.html#concept-events-trusted">trusted</a> event named <code data-anolis-xref="event-load">load</code> that does not bubble and is not cancelable and which uses the
     <code><a href="infrastructure.html#event">Event</a></code> interface, and <a data-anolis-xref="concept-event-dispatch" href="infrastructure.html#concept-event-dispatch">dispatch</a> it at
     the <code><a href="dom.html#document">Document</a></code>'s <code><a href="browsers.html#window">Window</a></code> object, with <i>target override</i> set to the
     <code><a href="dom.html#document">Document</a></code> object.</li>

    </ol></li>

   <li>

    <p>If the <code><a href="dom.html#document">Document</a></code> is in a <a href="browsers.html#browsing-context">browsing context</a>, then <a href="webappapis.html#queue-a-task">queue a
    task</a> to run the following substeps:</p>

    <ol><li><p>If the <code><a href="dom.html#document">Document</a></code>'s <a href="browsers.html#page-showing">page showing</a> flag is true, then abort this
     task (i.e. don't fire the event below).</li> <!-- i don't see how this could be, but just
     to be sure... -->

     <li><p>Set the <code><a href="dom.html#document">Document</a></code>'s <a href="browsers.html#page-showing">page showing</a> flag to true.</li>

     <li><p><a data-anolis-xref="concept-event-fire" href="infrastructure.html#concept-event-fire">Fire</a> a <a data-anolis-xref="concept-events-trusted" href="infrastructure.html#concept-events-trusted">trusted</a> event with the name <code data-anolis-xref="event-pageshow"><a href="browsers.html#event-pageshow">pageshow</a></code> at the <code><a href="browsers.html#window">Window</a></code> object of the
     <code><a href="dom.html#document">Document</a></code>, but with its <code data-anolis-xref="dom-event-target"><a href="infrastructure.html#dom-event-target">target</a></code> set to the
     <code><a href="dom.html#document">Document</a></code> object (and the <code data-anolis-xref="dom-event-currentTarget">currentTarget</code> set to the <code><a href="browsers.html#window">Window</a></code> object),
     using the <code><a href="browsers.html#pagetransitionevent">PageTransitionEvent</a></code> interface, with the <code data-anolis-xref="dom-PageTransitionEvent-persisted"><a href="browsers.html#dom-pagetransitionevent-persisted">persisted</a></code> attribute initialized to false. This
     event must not bubble, must not be cancelable, and has no default action.</li>

    </ol></li>

   <li><p>If the <code><a href="dom.html#document">Document</a></code> has any <a href="browsers.html#pending-application-cache-download-process-tasks">pending application cache download process
   tasks</a>, then <a data-anolis-xref="queue a task" href="webappapis.html#queue-a-task">queue</a> each such <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a> in the order they were added to the list of <a href="browsers.html#pending-application-cache-download-process-tasks">pending
   application cache download process tasks</a>, and then empty the list of <a href="browsers.html#pending-application-cache-download-process-tasks">pending
   application cache download process tasks</a>. The <a href="webappapis.html#task-source">task source</a> for these <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">tasks</a> is the <a href="webappapis.html#networking-task-source">networking task source</a>.</li>

   <li><p>If the <code><a href="dom.html#document">Document</a></code>'s <a href="webappapis.html#print-when-loaded">print when loaded</a> flag is set, then run the
   <a href="webappapis.html#printing-steps">printing steps</a>.</li>

   <li><p>The <code><a href="dom.html#document">Document</a></code> is now <dfn id="ready-for-post-load-tasks">ready for post-load tasks</dfn>.</li>

   <li><p><a href="webappapis.html#queue-a-task">Queue a task</a> to mark the <code><a href="dom.html#document">Document</a></code> as <dfn id="completely-loaded">completely
   loaded</dfn>.</li>

  </ol><p>When the user agent is to <dfn id="abort-a-parser">abort a parser</dfn>, it must run the following steps:</p>

  <ol><li><p>Throw away any pending content in the <a href="#input-stream">input stream</a>, and discard any future
   content that would have been added to it.</li>

   <li><p>Set the <a href="dom.html#current-document-readiness">current document readiness</a> to "<code data-anolis-xref="">interactive</code>"<!--
   this synchronously fires an event -->.</li>

   <li><p>Pop <em>all</em> the nodes off the <a href="#stack-of-open-elements">stack of open elements</a>.</li>

   <li><p>Set the <a href="dom.html#current-document-readiness">current document readiness</a> to "<code data-anolis-xref="">complete</code>"<!--
   this also synchronously fires an event -->.</li>

   <!-- anything else? this is things that happen when you call document.open() on a document that's
   still being parsed, or when you navigate a document that's still parsing, or navigate the parent
   of a frame with a document that's still parsing, or the user hits "stop". Should the pending
   scripts be blown away or anything? -->

  </ol><p>Except where otherwise specified, the <a href="webappapis.html#task-source">task source</a> for the <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">tasks</a> mentioned in this section is the <a href="webappapis.html#dom-manipulation-task-source">DOM manipulation task
  source</a>.</p>

  </div>


  <div class="impl">

  <h4 id="coercing-an-html-dom-into-an-infoset"><span class="secno">8.2.7 </span>Coercing an HTML DOM into an infoset</h4>


  <p>When an application uses an <a href="#html-parser">HTML parser</a> in conjunction with an XML pipeline, it is
  possible that the constructed DOM is not compatible with the XML tool chain in certain subtle
  ways. For example, an XML toolchain might not be able to represent attributes with the name <code data-anolis-xref="">xmlns</code>, since they conflict with the Namespaces in XML syntax. There is also some
  data that the <a href="#html-parser">HTML parser</a> generates that isn't included in the DOM itself. This
  section specifies some rules for handling these issues.</p>

  <p>If the XML API being used doesn't support DOCTYPEs, the tool may drop DOCTYPEs altogether.</p>

  <p>If the XML API doesn't support attributes in no namespace that are named "<code data-anolis-xref="">xmlns</code>", attributes whose names start with "<code data-anolis-xref="">xmlns:</code>", or
  attributes in the <a href="infrastructure.html#xmlns-namespace">XMLNS namespace</a>, then the tool may drop such attributes.</p>

  <p>The tool may annotate the output with any namespace declarations required for proper
  operation.</p>

  <p>If the XML API being used restricts the allowable characters in the local names of elements and
  attributes, then the tool may map all element and attribute local names that the API wouldn't
  support to a set of names that <em>are</em> allowed, by replacing any character that isn't
  supported with the uppercase letter U and the six digits of the character's Unicode code point
  when expressed in hexadecimal, using digits 0-9 and capital letters A-F as the symbols, in
  increasing numeric order.</p>

  <p class="example">For example, the element name <code data-anolis-xref="">foo&lt;bar</code>, which can be
  output by the <a href="#html-parser">HTML parser</a>, though it is neither a legal HTML element name nor a
  well-formed XML element name, would be converted into <code data-anolis-xref="">fooU00003Cbar</code>, which
  <em>is</em> a well-formed XML element name (though it's still not legal in HTML by any means).</p>

  <p class="example">As another example, consider the attribute <code>xlink:href</code>. Used on a
  MathML element, it becomes, after being <a data-anolis-xref="adjust foreign attributes" href="#adjust-foreign-attributes">adjusted</a>,
  an attribute with a prefix "<code data-anolis-xref="">xlink</code>" and a local name "<code data-anolis-xref="">href</code>". However, used on an HTML element, it becomes an attribute with no prefix
  and the local name "<code data-anolis-xref="">xlink:href</code>", which is not a valid NCName, and thus might
  not be accepted by an XML API. It could thus get converted, becoming "<code data-anolis-xref="">xlinkU00003Ahref</code>".</p>

  <p class="note">The resulting names from this conversion conveniently can't clash with any
  attribute generated by the <a href="#html-parser">HTML parser</a>, since those are all either lowercase or those
  listed in the <a href="#adjust-foreign-attributes">adjust foreign attributes</a> algorithm's table.</p>

  <p>If the XML API restricts comments from having two consecutive U+002D HYPHEN-MINUS characters
  (--), the tool may insert a single U+0020 SPACE character between any such offending
  characters.</p>

  <p>If the XML API restricts comments from ending in a "-" (U+002D) character, the tool
  may insert a single U+0020 SPACE character at the end of such comments.</p>

  <p>If the XML API restricts allowed characters in character data, attribute values, or comments,
  the tool may replace any "FF" (U+000C) character with a U+0020 SPACE character, and any
  other literal non-XML character with a U+FFFD REPLACEMENT CHARACTER.</p>

  <p>If the tool has no way to convey out-of-band information, then the tool may drop the following
  information:</p>

  <ul><li>Whether the document is set to <i><a href="infrastructure.html#no-quirks-mode">no-quirks mode</a></i>, <i><a href="infrastructure.html#limited-quirks-mode">limited-quirks mode</a></i>, or
   <i><a href="infrastructure.html#quirks-mode">quirks mode</a></i></li>

   <li>The association between form controls and forms that aren't their nearest <code><a href="forms.html#the-form-element">form</a></code>
   element ancestor (use of the <a href="#form-element-pointer"><code>form</code> element pointer</a> in the parser)</li>

   <li>The <a href="scripting-1.html#template-contents">template contents</a> of any <code><a href="scripting-1.html#the-template-element">template</a></code> elements.</li>

  </ul><p class="note">The mutations allowed by this section apply <em>after</em> the <a href="#html-parser">HTML
  parser</a>'s rules have been applied. For example, a <code data-anolis-xref="">&lt;a::&gt;</code> start tag
  will be closed by a <code data-anolis-xref="">&lt;/a::&gt;</code> end tag, and never by a <code data-anolis-xref="">&lt;/aU00003AU00003A&gt;</code> end tag, even if the user agent is using the rules above to
  then generate an actual element in the DOM with the name <code data-anolis-xref="">aU00003AU00003A</code> for
  that start tag.</p>

  </div>


  <div class="impl">

  <h4 id="an-introduction-to-error-handling-and-strange-cases-in-the-parser"><span class="secno">8.2.8 </span>An introduction to error handling and strange cases in the parser</h4>

  <p><i>This section is non-normative.</i></p>
  <p>This section examines some erroneous markup and discusses how the <a href="#html-parser">HTML parser</a>
  handles these cases.</p>


  <h5 id="misnested-tags:-b-i-/b-/i"><span class="secno">8.2.8.1 </span>Misnested tags: &lt;b&gt;&lt;i&gt;&lt;/b&gt;&lt;/i&gt;</h5>

  <p><i>This section is non-normative.</i></p>
  <p>The most-often discussed example of erroneous markup is as follows:</p>

  <pre>&lt;p&gt;1&lt;b&gt;2&lt;i&gt;3&lt;/b&gt;4&lt;/i&gt;5&lt;/p&gt;</pre>

  <p>The parsing of this markup is straightforward up to the "3". At this point, the DOM looks like
  this:</p>

  <ul class="domTree"><li class="t1"><code><a href="semantics.html#the-html-element">html</a></code><ul><li class="t1"><code><a href="document-metadata.html#the-head-element">head</a></code></li><li class="t1"><code><a href="sections.html#the-body-element">body</a></code><ul><li class="t1"><code><a href="grouping-content.html#the-p-element">p</a></code><ul><li class="t3"><code><a href="infrastructure.html#text-0">#text</a></code>: <span data-anolis-xref="">1</span></li><li class="t1"><code><a href="text-level-semantics.html#the-b-element">b</a></code><ul><li class="t3"><code><a href="infrastructure.html#text-0">#text</a></code>: <span data-anolis-xref="">2</span></li><li class="t1"><code><a href="text-level-semantics.html#the-i-element">i</a></code><ul><li class="t3"><code><a href="infrastructure.html#text-0">#text</a></code>: <span data-anolis-xref="">3</span></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><p>Here, the <a href="#stack-of-open-elements">stack of open elements</a> has five elements on it: <code><a href="semantics.html#the-html-element">html</a></code>,
  <code><a href="sections.html#the-body-element">body</a></code>, <code><a href="grouping-content.html#the-p-element">p</a></code>, <code><a href="text-level-semantics.html#the-b-element">b</a></code>, and <code><a href="text-level-semantics.html#the-i-element">i</a></code>. The <a href="#list-of-active-formatting-elements">list of active
  formatting elements</a> just has two: <code><a href="text-level-semantics.html#the-b-element">b</a></code> and <code><a href="text-level-semantics.html#the-i-element">i</a></code>. The <a href="#insertion-mode">insertion
  mode</a> is "<a data-anolis-xref="insertion mode: in body" href="#parsing-main-inbody">in body</a>".</p>

  <p>Upon receiving the end tag token with the tag name "b", the "<a href="#adoptionAgency">adoption
  agency algorithm</a>" is invoked. This is a simple case, in that the <var data-anolis-xref="">formatting
  element</var> is the <code><a href="text-level-semantics.html#the-b-element">b</a></code> element, and there is no <var data-anolis-xref="">furthest block</var>.
  Thus, the <a href="#stack-of-open-elements">stack of open elements</a> ends up with just three elements: <code><a href="semantics.html#the-html-element">html</a></code>,
  <code><a href="sections.html#the-body-element">body</a></code>, and <code><a href="grouping-content.html#the-p-element">p</a></code>, while the <a href="#list-of-active-formatting-elements">list of active formatting elements</a>
  has just one: <code><a href="text-level-semantics.html#the-i-element">i</a></code>. The DOM tree is unmodified at this point.</p>

  <p>The next token is a character ("4"), triggers the <a data-anolis-xref="reconstruct the active
  formatting elements" href="#reconstruct-the-active-formatting-elements">reconstruction of the active formatting elements</a>, in this case just
  the <code><a href="text-level-semantics.html#the-i-element">i</a></code> element. A new <code><a href="text-level-semantics.html#the-i-element">i</a></code> element is thus created for the "4"
  <code><a href="infrastructure.html#text-0">Text</a></code> node. After the end tag token for the "i" is also received, and the "5"
  <code><a href="infrastructure.html#text-0">Text</a></code> node is inserted, the DOM looks as follows:</p>

  <ul class="domTree"><li class="t1"><code><a href="semantics.html#the-html-element">html</a></code><ul><li class="t1"><code><a href="document-metadata.html#the-head-element">head</a></code></li><li class="t1"><code><a href="sections.html#the-body-element">body</a></code><ul><li class="t1"><code><a href="grouping-content.html#the-p-element">p</a></code><ul><li class="t3"><code><a href="infrastructure.html#text-0">#text</a></code>: <span data-anolis-xref="">1</span></li><li class="t1"><code><a href="text-level-semantics.html#the-b-element">b</a></code><ul><li class="t3"><code><a href="infrastructure.html#text-0">#text</a></code>: <span data-anolis-xref="">2</span></li><li class="t1"><code><a href="text-level-semantics.html#the-i-element">i</a></code><ul><li class="t3"><code><a href="infrastructure.html#text-0">#text</a></code>: <span data-anolis-xref="">3</span></li></ul></li></ul></li><li class="t1"><code><a href="text-level-semantics.html#the-i-element">i</a></code><ul><li class="t3"><code><a href="infrastructure.html#text-0">#text</a></code>: <span data-anolis-xref="">4</span></li></ul></li><li class="t3"><code><a href="infrastructure.html#text-0">#text</a></code>: <span data-anolis-xref="">5</span></li></ul></li></ul></li></ul></li></ul><h5 id="misnested-tags:-b-p-/b-/p"><span class="secno">8.2.8.2 </span>Misnested tags: &lt;b&gt;&lt;p&gt;&lt;/b&gt;&lt;/p&gt;</h5>

  <p><i>This section is non-normative.</i></p>
  <p>A case similar to the previous one is the following:</p>

  <pre>&lt;b&gt;1&lt;p&gt;2&lt;/b&gt;3&lt;/p&gt;</pre>

  <p>Up to the "2" the parsing here is straightforward:</p>

  <ul class="domTree"><li class="t1"><code><a href="semantics.html#the-html-element">html</a></code><ul><li class="t1"><code><a href="document-metadata.html#the-head-element">head</a></code></li><li class="t1"><code><a href="sections.html#the-body-element">body</a></code><ul><li class="t1"><code><a href="text-level-semantics.html#the-b-element">b</a></code><ul><li class="t3"><code><a href="infrastructure.html#text-0">#text</a></code>: <span data-anolis-xref="">1</span></li><li class="t1"><code><a href="grouping-content.html#the-p-element">p</a></code><ul><li class="t3"><code><a href="infrastructure.html#text-0">#text</a></code>: <span data-anolis-xref="">2</span></li></ul></li></ul></li></ul></li></ul></li></ul><p>The interesting part is when the end tag token with the tag name "b" is parsed.</p>

  <p>Before that token is seen, the <a href="#stack-of-open-elements">stack of open elements</a> has four elements on it:
  <code><a href="semantics.html#the-html-element">html</a></code>, <code><a href="sections.html#the-body-element">body</a></code>, <code><a href="text-level-semantics.html#the-b-element">b</a></code>, and <code><a href="grouping-content.html#the-p-element">p</a></code>. The <a href="#list-of-active-formatting-elements">list of active
  formatting elements</a> just has the one: <code><a href="text-level-semantics.html#the-b-element">b</a></code>. The <a href="#insertion-mode">insertion mode</a> is
  "<a data-anolis-xref="insertion mode: in body" href="#parsing-main-inbody">in body</a>".</p>

  <p>Upon receiving the end tag token with the tag name "b", the "<a href="#adoptionAgency">adoption
  agency algorithm</a>" is invoked, as in the previous example. However, in this case, there
  <em>is</em> a <var data-anolis-xref="">furthest block</var>, namely the <code><a href="grouping-content.html#the-p-element">p</a></code> element. Thus, this
  time the adoption agency algorithm isn't skipped over.</p>

  <p>The <var data-anolis-xref="">common ancestor</var> is the <code><a href="sections.html#the-body-element">body</a></code> element. A conceptual
  "bookmark" marks the position of the <code><a href="text-level-semantics.html#the-b-element">b</a></code> in the <a href="#list-of-active-formatting-elements">list of active formatting
  elements</a>, but since that list has only one element in it, the bookmark won't have much
  effect.</p>

  <p>As the algorithm progresses, <var data-anolis-xref="">node</var> ends up set to the formatting element
  (<code><a href="text-level-semantics.html#the-b-element">b</a></code>), and <var data-anolis-xref="">last node</var> ends up set to the <var data-anolis-xref="">furthest
  block</var> (<code><a href="grouping-content.html#the-p-element">p</a></code>).</p>

  <p>The <var data-anolis-xref="">last node</var> gets appended (moved) to the <var data-anolis-xref="">common
  ancestor</var>, so that the DOM looks like:</p>

  <ul class="domTree"><li class="t1"><code><a href="semantics.html#the-html-element">html</a></code><ul><li class="t1"><code><a href="document-metadata.html#the-head-element">head</a></code></li><li class="t1"><code><a href="sections.html#the-body-element">body</a></code><ul><li class="t1"><code><a href="text-level-semantics.html#the-b-element">b</a></code><ul><li class="t3"><code><a href="infrastructure.html#text-0">#text</a></code>: <span data-anolis-xref="">1</span></li></ul></li><li class="t1"><code><a href="grouping-content.html#the-p-element">p</a></code><ul><li class="t3"><code><a href="infrastructure.html#text-0">#text</a></code>: <span data-anolis-xref="">2</span></li></ul></li></ul></li></ul></li></ul><p>A new <code><a href="text-level-semantics.html#the-b-element">b</a></code> element is created, and the children of the <code><a href="grouping-content.html#the-p-element">p</a></code> element are
  moved to it:</p>

  <ul class="domTree"><li class="t1"><code><a href="semantics.html#the-html-element">html</a></code><ul><li class="t1"><code><a href="document-metadata.html#the-head-element">head</a></code></li><li class="t1"><code><a href="sections.html#the-body-element">body</a></code><ul><li class="t1"><code><a href="text-level-semantics.html#the-b-element">b</a></code><ul><li class="t3"><code><a href="infrastructure.html#text-0">#text</a></code>: <span data-anolis-xref="">1</span></li></ul></li><li class="t1"><code><a href="grouping-content.html#the-p-element">p</a></code></li></ul></li></ul></li></ul><ul class="domTree"><li class="t1"><code><a href="text-level-semantics.html#the-b-element">b</a></code><ul><li class="t3"><code><a href="infrastructure.html#text-0">#text</a></code>: <span data-anolis-xref="">2</span></li></ul></li></ul><p>Finally, the new <code><a href="text-level-semantics.html#the-b-element">b</a></code> element is appended to the <code><a href="grouping-content.html#the-p-element">p</a></code> element, so that the
  DOM looks like:</p>

  <ul class="domTree"><li class="t1"><code><a href="semantics.html#the-html-element">html</a></code><ul><li class="t1"><code><a href="document-metadata.html#the-head-element">head</a></code></li><li class="t1"><code><a href="sections.html#the-body-element">body</a></code><ul><li class="t1"><code><a href="text-level-semantics.html#the-b-element">b</a></code><ul><li class="t3"><code><a href="infrastructure.html#text-0">#text</a></code>: <span data-anolis-xref="">1</span></li></ul></li><li class="t1"><code><a href="grouping-content.html#the-p-element">p</a></code><ul><li class="t1"><code><a href="text-level-semantics.html#the-b-element">b</a></code><ul><li class="t3"><code><a href="infrastructure.html#text-0">#text</a></code>: <span data-anolis-xref="">2</span></li></ul></li></ul></li></ul></li></ul></li></ul><p>The <code><a href="text-level-semantics.html#the-b-element">b</a></code> element is removed from the <a href="#list-of-active-formatting-elements">list of active formatting elements</a>
  and the <a href="#stack-of-open-elements">stack of open elements</a>, so that when the "3" is parsed, it is appended to the
  <code><a href="grouping-content.html#the-p-element">p</a></code> element:</p>

  <ul class="domTree"><li class="t1"><code><a href="semantics.html#the-html-element">html</a></code><ul><li class="t1"><code><a href="document-metadata.html#the-head-element">head</a></code></li><li class="t1"><code><a href="sections.html#the-body-element">body</a></code><ul><li class="t1"><code><a href="text-level-semantics.html#the-b-element">b</a></code><ul><li class="t3"><code><a href="infrastructure.html#text-0">#text</a></code>: <span data-anolis-xref="">1</span></li></ul></li><li class="t1"><code><a href="grouping-content.html#the-p-element">p</a></code><ul><li class="t1"><code><a href="text-level-semantics.html#the-b-element">b</a></code><ul><li class="t3"><code><a href="infrastructure.html#text-0">#text</a></code>: <span data-anolis-xref="">2</span></li></ul></li><li class="t3"><code><a href="infrastructure.html#text-0">#text</a></code>: <span data-anolis-xref="">3</span></li></ul></li></ul></li></ul></li></ul><h5 id="unexpected-markup-in-tables"><span class="secno">8.2.8.3 </span>Unexpected markup in tables</h5>

  <p><i>This section is non-normative.</i></p>
  <p>Error handling in tables is, for historical reasons, especially strange. For example, consider
  the following markup:</p>

  <pre>&lt;table&gt;<strong><a href="text-level-semantics.html#the-b-element">&lt;b&gt;</a></strong>&lt;tr&gt;&lt;td&gt;aaa&lt;/td&gt;&lt;/tr&gt;<strong>bbb</strong>&lt;/table&gt;ccc</pre>

  <p>The highlighted <code><a href="text-level-semantics.html#the-b-element">b</a></code> element start tag is not allowed directly inside a table like
  that, and the parser handles this case by placing the element <em>before</em> the table. (This is
  called <i data-anolis-xref="foster parent"><a href="#foster-parent">foster parenting</a></i>.) This can be seen by examining the DOM tree
  as it stands just after the <code><a href="tabular-data.html#the-table-element">table</a></code> element's start tag has been seen:</p>

  <ul class="domTree"><li class="t1"><code><a href="semantics.html#the-html-element">html</a></code><ul><li class="t1"><code><a href="document-metadata.html#the-head-element">head</a></code></li><li class="t1"><code><a href="sections.html#the-body-element">body</a></code><ul><li class="t1"><code><a href="tabular-data.html#the-table-element">table</a></code></li></ul></li></ul></li></ul><p>...and then immediately after the <code><a href="text-level-semantics.html#the-b-element">b</a></code> element start tag has been seen:</p>

  <ul class="domTree"><li class="t1"><code><a href="semantics.html#the-html-element">html</a></code><ul><li class="t1"><code><a href="document-metadata.html#the-head-element">head</a></code></li><li class="t1"><code><a href="sections.html#the-body-element">body</a></code><ul><li class="t1"><code><a href="text-level-semantics.html#the-b-element">b</a></code></li><li class="t1"><code><a href="tabular-data.html#the-table-element">table</a></code></li></ul></li></ul></li></ul><p>At this point, the <a href="#stack-of-open-elements">stack of open elements</a> has on it the elements
  <code><a href="semantics.html#the-html-element">html</a></code>, <code><a href="sections.html#the-body-element">body</a></code>, <code><a href="tabular-data.html#the-table-element">table</a></code>, and <code><a href="text-level-semantics.html#the-b-element">b</a></code> (in that order,
  despite the resulting DOM tree); the <a href="#list-of-active-formatting-elements">list of active formatting elements</a> just has the
  <code><a href="text-level-semantics.html#the-b-element">b</a></code> element in it; and the <a href="#insertion-mode">insertion mode</a> is "<a data-anolis-xref="insertion mode:
  in table" href="#parsing-main-intable">in table</a>".</p>

  <p>The <code><a href="tabular-data.html#the-tr-element">tr</a></code> start tag causes the <code><a href="text-level-semantics.html#the-b-element">b</a></code> element to be popped off the stack and
  a <code><a href="tabular-data.html#the-tbody-element">tbody</a></code> start tag to be implied; the <code><a href="tabular-data.html#the-tbody-element">tbody</a></code> and <code><a href="tabular-data.html#the-tr-element">tr</a></code> elements
  are then handled in a rather straight-forward manner, taking the parser through the "<a data-anolis-xref="insertion mode: in table body" href="#parsing-main-intbody">in table body</a>" and "<a data-anolis-xref="insertion mode: in
  row" href="#parsing-main-intr">in row</a>" insertion modes, after which the DOM looks as follows:</p>

  <ul class="domTree"><li class="t1"><code><a href="semantics.html#the-html-element">html</a></code><ul><li class="t1"><code><a href="document-metadata.html#the-head-element">head</a></code></li><li class="t1"><code><a href="sections.html#the-body-element">body</a></code><ul><li class="t1"><code><a href="text-level-semantics.html#the-b-element">b</a></code></li><li class="t1"><code><a href="tabular-data.html#the-table-element">table</a></code><ul><li class="t1"><code><a href="tabular-data.html#the-tbody-element">tbody</a></code><ul><li class="t1"><code><a href="tabular-data.html#the-tr-element">tr</a></code></li></ul></li></ul></li></ul></li></ul></li></ul><p>Here, the <a href="#stack-of-open-elements">stack of open elements</a> has on it the elements <code><a href="semantics.html#the-html-element">html</a></code>,
  <code><a href="sections.html#the-body-element">body</a></code>, <code><a href="tabular-data.html#the-table-element">table</a></code>, <code><a href="tabular-data.html#the-tbody-element">tbody</a></code>, and <code><a href="tabular-data.html#the-tr-element">tr</a></code>; the <a href="#list-of-active-formatting-elements">list of
  active formatting elements</a> still has the <code><a href="text-level-semantics.html#the-b-element">b</a></code> element in it; and the
  <a href="#insertion-mode">insertion mode</a> is "<a data-anolis-xref="insertion mode: in row" href="#parsing-main-intr">in row</a>".</p>

  <p>The <code><a href="tabular-data.html#the-td-element">td</a></code> element start tag token, after putting a <code><a href="tabular-data.html#the-td-element">td</a></code> element on the
  tree, puts a marker on the <a href="#list-of-active-formatting-elements">list of active formatting elements</a> (it also switches to
  the "<a data-anolis-xref="insertion mode: in cell" href="#parsing-main-intd">in cell</a>" <a href="#insertion-mode">insertion mode</a>).</p>

  <ul class="domTree"><li class="t1"><code><a href="semantics.html#the-html-element">html</a></code><ul><li class="t1"><code><a href="document-metadata.html#the-head-element">head</a></code></li><li class="t1"><code><a href="sections.html#the-body-element">body</a></code><ul><li class="t1"><code><a href="text-level-semantics.html#the-b-element">b</a></code></li><li class="t1"><code><a href="tabular-data.html#the-table-element">table</a></code><ul><li class="t1"><code><a href="tabular-data.html#the-tbody-element">tbody</a></code><ul><li class="t1"><code><a href="tabular-data.html#the-tr-element">tr</a></code><ul><li class="t1"><code><a href="tabular-data.html#the-td-element">td</a></code></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><p>The marker means that when the "aaa" character tokens are seen, no <code><a href="text-level-semantics.html#the-b-element">b</a></code> element is
  created to hold the resulting <code><a href="infrastructure.html#text-0">Text</a></code> node:</p>

  <ul class="domTree"><li class="t1"><code><a href="semantics.html#the-html-element">html</a></code><ul><li class="t1"><code><a href="document-metadata.html#the-head-element">head</a></code></li><li class="t1"><code><a href="sections.html#the-body-element">body</a></code><ul><li class="t1"><code><a href="text-level-semantics.html#the-b-element">b</a></code></li><li class="t1"><code><a href="tabular-data.html#the-table-element">table</a></code><ul><li class="t1"><code><a href="tabular-data.html#the-tbody-element">tbody</a></code><ul><li class="t1"><code><a href="tabular-data.html#the-tr-element">tr</a></code><ul><li class="t1"><code><a href="tabular-data.html#the-td-element">td</a></code><ul><li class="t3"><code><a href="infrastructure.html#text-0">#text</a></code>: <span data-anolis-xref="">aaa</span></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><p>The end tags are handled in a straight-forward manner; after handling them, the <a href="#stack-of-open-elements">stack of
  open elements</a> has on it the elements <code><a href="semantics.html#the-html-element">html</a></code>, <code><a href="sections.html#the-body-element">body</a></code>,
  <code><a href="tabular-data.html#the-table-element">table</a></code>, and <code><a href="tabular-data.html#the-tbody-element">tbody</a></code>; the <a href="#list-of-active-formatting-elements">list of active formatting elements</a>
  still has the <code><a href="text-level-semantics.html#the-b-element">b</a></code> element in it (the marker having been removed by the "td" end tag
  token); and the <a href="#insertion-mode">insertion mode</a> is "<a data-anolis-xref="insertion mode: in table body" href="#parsing-main-intbody">in
  table body</a>".</p>

  <p>Thus it is that the "bbb" character tokens are found. These trigger the "<a data-anolis-xref="insertion
  mode: in table text" href="#parsing-main-intabletext">in table text</a>" insertion mode to be used (with the <a href="#original-insertion-mode">original
  insertion mode</a> set to "<a data-anolis-xref="insertion mode: in table body" href="#parsing-main-intbody">in table body</a>").
  The character tokens are collected, and when the next token (the <code><a href="tabular-data.html#the-table-element">table</a></code> element end
  tag) is seen, they are processed as a group. Since they are not all spaces, they are handled as
  per the "anything else" rules in the "<a data-anolis-xref="insertion mode: in table" href="#parsing-main-intable">in table</a>"
  insertion mode, which defer to the "<a data-anolis-xref="insertion mode: in body" href="#parsing-main-inbody">in body</a>"
  insertion mode but with <a data-anolis-xref="foster parent" href="#foster-parent">foster parenting</a>.</p>

  <p>When <a data-anolis-xref="reconstruct the active formatting elements" href="#reconstruct-the-active-formatting-elements">the active formatting elements
  are reconstructed</a>, a <code><a href="text-level-semantics.html#the-b-element">b</a></code> element is created and <a data-anolis-xref="foster
  parent" href="#foster-parent">foster parented</a>, and then the "bbb" <code><a href="infrastructure.html#text-0">Text</a></code> node is appended to it:</p>

  <ul class="domTree"><li class="t1"><code><a href="semantics.html#the-html-element">html</a></code><ul><li class="t1"><code><a href="document-metadata.html#the-head-element">head</a></code></li><li class="t1"><code><a href="sections.html#the-body-element">body</a></code><ul><li class="t1"><code><a href="text-level-semantics.html#the-b-element">b</a></code></li><li class="t1"><code><a href="text-level-semantics.html#the-b-element">b</a></code><ul><li class="t3"><code><a href="infrastructure.html#text-0">#text</a></code>: <span data-anolis-xref="">bbb</span></li></ul></li><li class="t1"><code><a href="tabular-data.html#the-table-element">table</a></code><ul><li class="t1"><code><a href="tabular-data.html#the-tbody-element">tbody</a></code><ul><li class="t1"><code><a href="tabular-data.html#the-tr-element">tr</a></code><ul><li class="t1"><code><a href="tabular-data.html#the-td-element">td</a></code><ul><li class="t3"><code><a href="infrastructure.html#text-0">#text</a></code>: <span data-anolis-xref="">aaa</span></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><p>The <a href="#stack-of-open-elements">stack of open elements</a> has on it the elements <code><a href="semantics.html#the-html-element">html</a></code>,
  <code><a href="sections.html#the-body-element">body</a></code>, <code><a href="tabular-data.html#the-table-element">table</a></code>, <code><a href="tabular-data.html#the-tbody-element">tbody</a></code>, and the new <code><a href="text-level-semantics.html#the-b-element">b</a></code> (again, note
  that this doesn't match the resulting tree!); the <a href="#list-of-active-formatting-elements">list of active formatting elements</a>
  has the new <code><a href="text-level-semantics.html#the-b-element">b</a></code> element in it; and the <a href="#insertion-mode">insertion mode</a> is still "<a data-anolis-xref="insertion mode: in table body" href="#parsing-main-intbody">in table body</a>".</p>

  <p>Had the character tokens been only <a data-anolis-xref="space character" href="infrastructure.html#space-character">space characters</a>
  instead of "bbb", then those <a data-anolis-xref="space character" href="infrastructure.html#space-character">space characters</a> would just be
  appended to the <code><a href="tabular-data.html#the-tbody-element">tbody</a></code> element.</p>

  <p>Finally, the <code><a href="tabular-data.html#the-table-element">table</a></code> is closed by a "table" end tag. This pops all the nodes from
  the <a href="#stack-of-open-elements">stack of open elements</a> up to and including the <code><a href="tabular-data.html#the-table-element">table</a></code> element, but it
  doesn't affect the <a href="#list-of-active-formatting-elements">list of active formatting elements</a>, so the "ccc" character tokens
  after the table result in yet another <code><a href="text-level-semantics.html#the-b-element">b</a></code> element being created, this time after the
  table:</p>

  <ul class="domTree"><li class="t1"><code><a href="semantics.html#the-html-element">html</a></code><ul><li class="t1"><code><a href="document-metadata.html#the-head-element">head</a></code></li><li class="t1"><code><a href="sections.html#the-body-element">body</a></code><ul><li class="t1"><code><a href="text-level-semantics.html#the-b-element">b</a></code></li><li class="t1"><code><a href="text-level-semantics.html#the-b-element">b</a></code><ul><li class="t3"><code><a href="infrastructure.html#text-0">#text</a></code>: <span data-anolis-xref="">bbb</span></li></ul></li><li class="t1"><code><a href="tabular-data.html#the-table-element">table</a></code><ul><li class="t1"><code><a href="tabular-data.html#the-tbody-element">tbody</a></code><ul><li class="t1"><code><a href="tabular-data.html#the-tr-element">tr</a></code><ul><li class="t1"><code><a href="tabular-data.html#the-td-element">td</a></code><ul><li class="t3"><code><a href="infrastructure.html#text-0">#text</a></code>: <span data-anolis-xref="">aaa</span></li></ul></li></ul></li></ul></li></ul></li><li class="t1"><code><a href="text-level-semantics.html#the-b-element">b</a></code><ul><li class="t3"><code><a href="infrastructure.html#text-0">#text</a></code>: <span data-anolis-xref="">ccc</span></li></ul></li></ul></li></ul></li></ul><h5 id="scripts-that-modify-the-page-as-it-is-being-parsed"><span class="secno">8.2.8.4 </span>Scripts that modify the page as it is being parsed</h5>

  <p><i>This section is non-normative.</i></p>
  <p>Consider the following markup, which for this example we will assume is the document with
  <span>URL</span> <code data-anolis-xref="">http://example.com/inner</code>, being rendered as the content of
  an <code><a href="embedded-content-0.html#the-iframe-element">iframe</a></code> in another document with the <span>URL</span> <code data-anolis-xref="">http://example.com/outer</code>:</p>

  <pre>&lt;div id=a&gt;
 &lt;script&gt;
  var div = document.getElementById('a');
  parent.document.body.appendChild(div);
 &lt;/script&gt;
 &lt;script&gt;
  alert(document.URL);
 &lt;/script&gt;
&lt;/div&gt;
&lt;script&gt;
 alert(document.URL);
&lt;/script&gt;</pre>

  <p>Up to the first "script" end tag, before the script is parsed, the result is relatively
  straightforward:</p>

  <ul class="domTree"><li class="t1"><code><a href="semantics.html#the-html-element">html</a></code><ul><li class="t1"><code><a href="document-metadata.html#the-head-element">head</a></code></li><li class="t1"><code><a href="sections.html#the-body-element">body</a></code><ul><li class="t1"><code><a href="grouping-content.html#the-div-element">div</a></code> <span class="t2" data-anolis-xref=""><code class="attribute name">id</code>="<code class="attribute value"><a href="text-level-semantics.html#the-a-element">a</a></code>"</span><ul><li class="t3"><code><a href="infrastructure.html#text-0">#text</a></code>: <span data-anolis-xref="">
 </span></li><li class="t1"><code><a href="scripting-1.html#the-script-element">script</a></code><ul><li class="t3"><code><a href="infrastructure.html#text-0">#text</a></code>: <span data-anolis-xref="">var div = document.getElementById('a'); ⏎ parent.document.body.appendChild(div);</span></li></ul></li></ul></li></ul></li></ul></li></ul><p>After the script is parsed, though, the <code><a href="grouping-content.html#the-div-element">div</a></code> element and its child
  <code><a href="scripting-1.html#the-script-element">script</a></code> element are gone:</p>

  <ul class="domTree"><li class="t1"><code><a href="semantics.html#the-html-element">html</a></code><ul><li class="t1"><code><a href="document-metadata.html#the-head-element">head</a></code></li><li class="t1"><code><a href="sections.html#the-body-element">body</a></code></li></ul></li></ul><p>They are, at this point, in the <code><a href="dom.html#document">Document</a></code> of the aforementioned outer
  <a href="browsers.html#browsing-context">browsing context</a>. However, the <a href="#stack-of-open-elements">stack of open elements</a> <em>still contains
  the <code><a href="grouping-content.html#the-div-element">div</a></code> element</em>.</p>

  <p>Thus, when the second <code><a href="scripting-1.html#the-script-element">script</a></code> element is parsed, it is inserted <em>into the outer
  <code><a href="dom.html#document">Document</a></code> object</em>.</p>

  <p>Those parsed into different <code><a href="dom.html#document">Document</a></code>s than the one the parser was created for do
  not execute, so the first alert does not show.</p>

  <p>Once the <code><a href="grouping-content.html#the-div-element">div</a></code> element's end tag is parsed, the <code><a href="grouping-content.html#the-div-element">div</a></code> element is popped
  off the stack, and so the next <code><a href="scripting-1.html#the-script-element">script</a></code> element is in the inner
  <code><a href="dom.html#document">Document</a></code>:</p>

  <ul class="domTree"><li class="t1"><code><a href="semantics.html#the-html-element">html</a></code><ul><li class="t1"><code><a href="document-metadata.html#the-head-element">head</a></code></li><li class="t1"><code><a href="sections.html#the-body-element">body</a></code><ul><li class="t1"><code><a href="scripting-1.html#the-script-element">script</a></code><ul><li class="t3"><code><a href="infrastructure.html#text-0">#text</a></code>: <span data-anolis-xref="">alert(document.URL);</span></li></ul></li></ul></li></ul></li></ul><p>This script does execute, resulting in an alert that says "http://example.com/inner".</p>


  <h5 id="the-execution-of-scripts-that-are-moving-across-multiple-documents"><span class="secno">8.2.8.5 </span>The execution of scripts that are moving across multiple documents</h5>

  <p><i>This section is non-normative.</i></p>
  <p>Elaborating on the example in the previous section, consider the case where the second
  <code><a href="scripting-1.html#the-script-element">script</a></code> element is an external script (i.e. one with a <code data-anolis-xref="attr-script-src"><a href="scripting-1.html#attr-script-src">src</a></code> attribute). Since the element was not in the parser's
  <code><a href="dom.html#document">Document</a></code> when it was created, that external script is not even downloaded.</p>

  <p>In a case where a <code><a href="scripting-1.html#the-script-element">script</a></code> element with a <code data-anolis-xref="attr-script-src"><a href="scripting-1.html#attr-script-src">src</a></code>
  attribute is parsed normally into its parser's <code><a href="dom.html#document">Document</a></code>, but while the external
  script is being downloaded, the element is moved to another document, the script continues to
  download, but does not execute.</p>

  <p class="note">In general, moving <code><a href="scripting-1.html#the-script-element">script</a></code> elements between <code><a href="dom.html#document">Document</a></code>s is
  considered a bad practice.</p>



  <h5 id="unclosed-formatting-elements"><span class="secno">8.2.8.6 </span>Unclosed formatting elements</h5>

  <p><i>This section is non-normative.</i></p>
  <p>The following markup shows how nested formatting elements (such as <code><a href="text-level-semantics.html#the-b-element">b</a></code>) get
  collected and continue to be applied even as the elements they are contained in are closed, but
  that excessive duplicates are thrown away.</p>

  <pre>&lt;!DOCTYPE html&gt;
&lt;p&gt;&lt;b class=x&gt;&lt;b class=x&gt;&lt;b&gt;&lt;b class=x&gt;&lt;b class=x&gt;&lt;b&gt;X
&lt;p&gt;X
&lt;p&gt;&lt;b&gt;&lt;b class=x&gt;&lt;b&gt;X
&lt;p&gt;&lt;/b&gt;&lt;/b&gt;&lt;/b&gt;&lt;/b&gt;&lt;/b&gt;&lt;/b&gt;X</pre>

  <p>The resulting DOM tree is as follows:</p>

  <ul class="domTree"><li class="t10">DOCTYPE: <code><a href="semantics.html#the-html-element">html</a></code></li><li class="t1"><code><a href="semantics.html#the-html-element">html</a></code><ul><li class="t1"><code><a href="document-metadata.html#the-head-element">head</a></code></li><li class="t1"><code><a href="sections.html#the-body-element">body</a></code><ul><li class="t1"><code><a href="grouping-content.html#the-p-element">p</a></code><ul><li class="t1"><code><a href="text-level-semantics.html#the-b-element">b</a></code> <span class="t2" data-anolis-xref=""><code class="attribute name">class</code>="<code class="attribute value">x</code>"</span><ul><li class="t1"><code><a href="text-level-semantics.html#the-b-element">b</a></code> <span class="t2" data-anolis-xref=""><code class="attribute name">class</code>="<code class="attribute value">x</code>"</span><ul><li class="t1"><code><a href="text-level-semantics.html#the-b-element">b</a></code><ul><li class="t1"><code><a href="text-level-semantics.html#the-b-element">b</a></code> <span class="t2" data-anolis-xref=""><code class="attribute name">class</code>="<code class="attribute value">x</code>"</span><ul><li class="t1"><code><a href="text-level-semantics.html#the-b-element">b</a></code> <span class="t2" data-anolis-xref=""><code class="attribute name">class</code>="<code class="attribute value">x</code>"</span><ul><li class="t1"><code><a href="text-level-semantics.html#the-b-element">b</a></code><ul><li class="t3"><code><a href="infrastructure.html#text-0">#text</a></code>: <span data-anolis-xref="">X⏎</span></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="t1"><code><a href="grouping-content.html#the-p-element">p</a></code><ul><li class="t1"><code><a href="text-level-semantics.html#the-b-element">b</a></code> <span class="t2" data-anolis-xref=""><code class="attribute name">class</code>="<code class="attribute value">x</code>"</span><ul><li class="t